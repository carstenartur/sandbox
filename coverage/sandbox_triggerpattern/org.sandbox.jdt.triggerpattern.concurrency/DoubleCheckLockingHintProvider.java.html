<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DoubleCheckLockingHintProvider.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_triggerpattern</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.triggerpattern.concurrency</a> &gt; <span class="el_source">DoubleCheckLockingHintProvider.java</span></div><h1>DoubleCheckLockingHintProvider.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer - initial API and implementation
 *******************************************************************************/
package org.sandbox.jdt.triggerpattern.concurrency;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTMatcher;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;
import org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal;
import org.eclipse.swt.graphics.Image;
import org.sandbox.jdt.triggerpattern.api.Hint;
import org.sandbox.jdt.triggerpattern.api.HintContext;
import org.sandbox.jdt.triggerpattern.api.PatternKind;
import org.sandbox.jdt.triggerpattern.api.TriggerPattern;

/**
 * Hint provider for detecting the double-checked locking anti-pattern.
 *
 * &lt;p&gt;Double-checked locking is a concurrency pattern where a field is checked
 * for null, then a synchronized block is entered, and the field is checked
 * again. This pattern can be problematic in Java without proper memory
 * visibility guarantees.&lt;/p&gt;
 *
 * &lt;p&gt;Inspired by the
 * &lt;a href=&quot;https://github.com/apache/netbeans/blob/master/java/java.hints/src/org/netbeans/modules/java/hints/DoubleCheck.java&quot;&gt;
 * NetBeans DoubleCheck hint&lt;/a&gt;.&lt;/p&gt;
 *
 * &lt;h3&gt;Detected Pattern&lt;/h3&gt;
 * &lt;pre&gt;
 * if (field == null) {
 *     synchronized (lock) {
 *         if (field == null) {
 *             field = new Something();
 *         }
 *     }
 * }
 * &lt;/pre&gt;
 *
 * &lt;h3&gt;Suggested Fix&lt;/h3&gt;
 * &lt;p&gt;The fix removes the outer null check, keeping only the synchronized block
 * with the inner null check. This eliminates the double-checked locking pattern
 * at the cost of always entering the synchronized block:&lt;/p&gt;
 * &lt;pre&gt;
 * synchronized (lock) {
 *     if (field == null) {
 *         field = new Something();
 *     }
 * }
 * &lt;/pre&gt;
 *
 * @since 1.2.5
 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-checked_locking&quot;&gt;Double-checked locking (Wikipedia)&lt;/a&gt;
 */
<span class="nc" id="L72">public class DoubleCheckLockingHintProvider {</span>

	/**
	 * Detects the double-checked locking pattern and suggests removing the outer
	 * null check to eliminate the anti-pattern.
	 *
	 * &lt;p&gt;The expression-level pattern {@code $field == null} is used as the entry
	 * point. When a null check is found, the method walks up the AST tree to verify
	 * the full double-checked locking structure: an outer {@code if} wrapping a
	 * {@code synchronized} block that contains an inner {@code if} with the same
	 * null check condition.&lt;/p&gt;
	 *
	 * &lt;p&gt;&lt;b&gt;Before:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;
	 * if (field == null) {
	 *     synchronized (lock) {
	 *         if (field == null) {
	 *             field = new Something();
	 *         }
	 *     }
	 * }
	 * &lt;/pre&gt;
	 *
	 * &lt;p&gt;&lt;b&gt;After:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;
	 * synchronized (lock) {
	 *     if (field == null) {
	 *         field = new Something();
	 *     }
	 * }
	 * &lt;/pre&gt;
	 *
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$field == null&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Double-checked locking&quot;,
	      description = &quot;Detects double-checked locking pattern. &quot;
	                   + &quot;Suggests removing the outer null check to use plain synchronization instead.&quot;,
	      category = &quot;concurrency&quot;,
	      suppressWarnings = &quot;DoubleCheckedLocking&quot;)
	public static IJavaCompletionProposal detectDoubleCheckLocking(HintContext ctx) {
<span class="nc" id="L114">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L117">			return null;</span>
		}

		// Walk up to find the enclosing IfStatement
<span class="nc" id="L121">		IfStatement innerIf = findEnclosingIf(matchedNode);</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">		if (innerIf == null || innerIf.getElseStatement() != null) {</span>
<span class="nc" id="L123">			return null;</span>
		}

		// Check that this inner if is inside a synchronized block
<span class="nc" id="L127">		SynchronizedStatement syncStmt = findEnclosingSynchronized(innerIf);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">		if (syncStmt == null) {</span>
<span class="nc" id="L129">			return null;</span>
		}

		// Check that the synchronized block is inside an outer if with the same condition
<span class="nc" id="L133">		IfStatement outerIf = findEnclosingIf(syncStmt);</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">		if (outerIf == null || outerIf.getElseStatement() != null) {</span>
<span class="nc" id="L135">			return null;</span>
		}

		// Verify both if conditions are null checks on the same expression
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if (!isSameNullCheck(outerIf.getExpression(), innerIf.getExpression())) {</span>
<span class="nc" id="L140">			return null;</span>
		}

		// Create the fix: replace the outer if with the synchronized block
<span class="nc" id="L144">		ASTRewrite rewrite = ctx.getASTRewrite();</span>
<span class="nc" id="L145">		AST ast = rewrite.getAST();</span>

<span class="nc" id="L147">		SynchronizedStatement replacement = (SynchronizedStatement) ASTNode.copySubtree(ast, syncStmt);</span>
<span class="nc" id="L148">		rewrite.replace(outerIf, replacement, null);</span>

		// Create the proposal
<span class="nc" id="L151">		String label = &quot;Remove outer null check (double-checked locking)&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L152">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L153">			label,</span>
<span class="nc" id="L154">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L155">			rewrite,</span>
<span class="nc" id="L156">			10, // relevance</span>
<span class="nc" id="L157">			(Image) null</span>
		);

<span class="nc" id="L160">		return proposal;</span>
	}

	/**
	 * Finds the nearest enclosing {@link IfStatement} for a given node.
	 *
	 * @param node the starting node
	 * @return the enclosing IfStatement, or null if not found
	 */
	private static IfStatement findEnclosingIf(ASTNode node) {
<span class="nc" id="L170">		ASTNode current = node.getParent();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">		while (current != null) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">			if (current instanceof IfStatement ifStatement) {</span>
<span class="nc" id="L173">				return ifStatement;</span>
			}
<span class="nc bnc" id="L175" title="All 2 branches missed.">			if (current instanceof Block) {</span>
<span class="nc" id="L176">				current = current.getParent();</span>
<span class="nc" id="L177">				continue;</span>
			}
			// Stop at other statement types
<span class="nc bnc" id="L180" title="All 2 branches missed.">			if (current instanceof Statement) {</span>
<span class="nc" id="L181">				return null;</span>
			}
<span class="nc" id="L183">			current = current.getParent();</span>
		}
<span class="nc" id="L185">		return null;</span>
	}

	/**
	 * Finds the nearest enclosing {@link SynchronizedStatement} for a given node.
	 *
	 * @param node the starting node
	 * @return the enclosing SynchronizedStatement, or null if not found
	 */
	private static SynchronizedStatement findEnclosingSynchronized(ASTNode node) {
<span class="nc" id="L195">		ASTNode current = node.getParent();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		while (current != null) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">			if (current instanceof SynchronizedStatement syncStatement) {</span>
<span class="nc" id="L198">				return syncStatement;</span>
			}
<span class="nc bnc" id="L200" title="All 2 branches missed.">			if (current instanceof Block) {</span>
<span class="nc" id="L201">				current = current.getParent();</span>
<span class="nc" id="L202">				continue;</span>
			}
			// Stop at other statement types
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (current instanceof Statement) {</span>
<span class="nc" id="L206">				return null;</span>
			}
<span class="nc" id="L208">			current = current.getParent();</span>
		}
<span class="nc" id="L210">		return null;</span>
	}

	/**
	 * Checks whether two expressions represent the same null check
	 * ({@code expr == null}).
	 *
	 * @param expr1 the first expression
	 * @param expr2 the second expression
	 * @return true if both are null checks on the same variable
	 */
	private static boolean isSameNullCheck(org.eclipse.jdt.core.dom.Expression expr1,
			org.eclipse.jdt.core.dom.Expression expr2) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">		if (!(expr1 instanceof InfixExpression infix1) || !(expr2 instanceof InfixExpression infix2)) {</span>
<span class="nc" id="L224">			return false;</span>
		}
<span class="nc bnc" id="L226" title="All 2 branches missed.">		if (infix1.getOperator() != InfixExpression.Operator.EQUALS</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">				|| infix2.getOperator() != InfixExpression.Operator.EQUALS) {</span>
<span class="nc" id="L228">			return false;</span>
		}
		// Check null on right side for both
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (!(infix1.getRightOperand() instanceof NullLiteral)</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">				|| !(infix2.getRightOperand() instanceof NullLiteral)) {</span>
<span class="nc" id="L233">			return false;</span>
		}
		// Compare the left operand (the field being checked) using structural comparison
<span class="nc" id="L236">		return infix1.getLeftOperand().subtreeMatch(new ASTMatcher(), infix2.getLeftOperand());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>