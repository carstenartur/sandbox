<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StringSimplificationHintProvider.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_triggerpattern</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.triggerpattern.string</a> &gt; <span class="el_source">StringSimplificationHintProvider.java</span></div><h1>StringSimplificationHintProvider.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer - initial API and implementation
 *******************************************************************************/
package org.sandbox.jdt.triggerpattern.string;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;
import org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal;
import org.eclipse.swt.graphics.Image;
import org.sandbox.jdt.triggerpattern.api.Hint;
import org.sandbox.jdt.triggerpattern.api.HintContext;
import org.sandbox.jdt.triggerpattern.api.PatternKind;
import org.sandbox.jdt.triggerpattern.api.TriggerPattern;

/**
 * Hint provider for string and boolean simplification patterns using TriggerPattern.
 * 
 * &lt;p&gt;This class demonstrates using the TriggerPattern engine to suggest
 * cleaner code patterns. It provides hints for:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Empty string concatenation: {@code &quot;&quot; + $x} → {@code String.valueOf($x)}&lt;/li&gt;
 * &lt;li&gt;Redundant toString: {@code $x + &quot;&quot;} → {@code String.valueOf($x)}&lt;/li&gt;
 * &lt;li&gt;String length check: {@code $str.length() == 0} → {@code $str.isEmpty()}&lt;/li&gt;
 * &lt;li&gt;String equals empty: {@code $str.equals(&quot;&quot;)} → {@code $str.isEmpty()}&lt;/li&gt;
 * &lt;li&gt;Boolean comparison: {@code $x == true} → {@code $x}&lt;/li&gt;
 * &lt;li&gt;Ternary boolean return: {@code $cond ? true : false} → {@code $cond}&lt;/li&gt;
 * &lt;li&gt;Redundant null check: {@code $x != null &amp;&amp; $x.isEmpty()} → use Optional or guard&lt;/li&gt;
 * &lt;li&gt;Collection size check: {@code $list.size() == 0} → {@code $list.isEmpty()}&lt;/li&gt;
 * &lt;li&gt;Negated isEmpty: {@code !$str.isEmpty() == false} → {@code !$str.isEmpty()}&lt;/li&gt;
 * &lt;li&gt;StringBuilder single append: {@code new StringBuilder().append($x).toString()} → {@code String.valueOf($x)}&lt;/li&gt;
 * &lt;li&gt;Redundant String.format: {@code String.format(&quot;%s&quot;, $x)} → {@code String.valueOf($x)}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @since 1.2.2
 */
<span class="nc" id="L53">public class StringSimplificationHintProvider {</span>

	/**
	 * Suggests replacing {@code &quot;&quot; + $x} with {@code String.valueOf($x)}.
	 * 
	 * &lt;p&gt;Example: {@code &quot;&quot; + value} becomes {@code String.valueOf(value)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;\&quot;\&quot; + $x&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Replace with String.valueOf()&quot;, 
	      description = &quot;Replaces empty string concatenation with String.valueOf() for clarity&quot;)
	public static IJavaCompletionProposal replaceEmptyStringConcatenation(HintContext ctx) {
<span class="nc" id="L67">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L70">			return null;</span>
		}

<span class="nc" id="L73">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the bound variable from placeholders
<span class="nc" id="L76">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L77" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L78">			return null;</span>
		}

<span class="nc" id="L81">		Expression valueExpression = (Expression) xNode;</span>

		// Create the replacement: String.valueOf(valueExpression)
<span class="nc" id="L84">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L86">		MethodInvocation methodInvocation = ast.newMethodInvocation();</span>
<span class="nc" id="L87">		methodInvocation.setExpression(ast.newName(&quot;String&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L88">		methodInvocation.setName(ast.newSimpleName(&quot;valueOf&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L89">		methodInvocation.arguments().add(ASTNode.copySubtree(ast, valueExpression));</span>

		// Apply the rewrite
<span class="nc" id="L92">		ctx.getASTRewrite().replace(infixExpr, methodInvocation, null);</span>

		// Create the proposal
<span class="nc" id="L95">		String label = &quot;Replace '&quot; + infixExpr + &quot;' with 'String.valueOf(...)'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L96">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L97">			label,</span>
<span class="nc" id="L98">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L99">			ctx.getASTRewrite(),</span>
<span class="nc" id="L100">			10, // relevance</span>
<span class="nc" id="L101">			(Image) null</span>
		);

<span class="nc" id="L104">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $x + &quot;&quot;} with {@code String.valueOf($x)}.
	 * 
	 * &lt;p&gt;Example: {@code value + &quot;&quot;} becomes {@code String.valueOf(value)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$x + \&quot;\&quot;&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Replace with String.valueOf()&quot;, 
	      description = &quot;Replaces concatenation with empty string with String.valueOf() for clarity&quot;)
	public static IJavaCompletionProposal replaceTrailingEmptyString(HintContext ctx) {
<span class="nc" id="L119">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L122">			return null;</span>
		}

<span class="nc" id="L125">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the bound variable
<span class="nc" id="L128">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L130">			return null;</span>
		}

<span class="nc" id="L133">		Expression valueExpression = (Expression) xNode;</span>

		// Create the replacement: String.valueOf(valueExpression)
<span class="nc" id="L136">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L138">		MethodInvocation methodInvocation = ast.newMethodInvocation();</span>
<span class="nc" id="L139">		methodInvocation.setExpression(ast.newName(&quot;String&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L140">		methodInvocation.setName(ast.newSimpleName(&quot;valueOf&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L141">		methodInvocation.arguments().add(ASTNode.copySubtree(ast, valueExpression));</span>

		// Apply the rewrite
<span class="nc" id="L144">		ctx.getASTRewrite().replace(infixExpr, methodInvocation, null);</span>

		// Create the proposal
<span class="nc" id="L147">		String label = &quot;Replace '&quot; + infixExpr + &quot;' with 'String.valueOf(...)'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L148">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L149">			label,</span>
<span class="nc" id="L150">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L151">			ctx.getASTRewrite(),</span>
<span class="nc" id="L152">			10, // relevance</span>
<span class="nc" id="L153">			(Image) null</span>
		);

<span class="nc" id="L156">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $str.length() == 0} with {@code $str.isEmpty()}.
	 * 
	 * &lt;p&gt;Example: {@code str.length() == 0} becomes {@code str.isEmpty()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$str.length() == 0&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use isEmpty()&quot;, 
	      description = &quot;Replaces length() == 0 check with isEmpty() for better readability&quot;)
	public static IJavaCompletionProposal replaceStringLengthCheck(HintContext ctx) {
<span class="nc" id="L171">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L174">			return null;</span>
		}

<span class="nc" id="L177">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the string expression
<span class="nc" id="L180">		ASTNode strNode = ctx.getMatch().getBinding(&quot;$str&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">		if (strNode == null || !(strNode instanceof Expression)) {</span>
<span class="nc" id="L182">			return null;</span>
		}

<span class="nc" id="L185">		Expression strExpression = (Expression) strNode;</span>

		// Create the replacement: strExpression.isEmpty()
<span class="nc" id="L188">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L190">		MethodInvocation isEmptyCall = ast.newMethodInvocation();</span>
<span class="nc" id="L191">		isEmptyCall.setExpression((Expression) ASTNode.copySubtree(ast, strExpression));</span>
<span class="nc" id="L192">		isEmptyCall.setName(ast.newSimpleName(&quot;isEmpty&quot;)); //$NON-NLS-1$</span>

		// Apply the rewrite
<span class="nc" id="L195">		ctx.getASTRewrite().replace(infixExpr, isEmptyCall, null);</span>

		// Create the proposal
<span class="nc" id="L198">		String label = &quot;Replace '&quot; + infixExpr + &quot;' with 'isEmpty()'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L199">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L200">			label,</span>
<span class="nc" id="L201">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L202">			ctx.getASTRewrite(),</span>
<span class="nc" id="L203">			10, // relevance</span>
<span class="nc" id="L204">			(Image) null</span>
		);

<span class="nc" id="L207">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $str.equals(&quot;&quot;)} with {@code $str.isEmpty()}.
	 * 
	 * &lt;p&gt;Example: {@code str.equals(&quot;&quot;)} becomes {@code str.isEmpty()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$str.equals(\&quot;\&quot;)&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use isEmpty()&quot;, 
	      description = &quot;Replaces equals(\&quot;\&quot;) check with isEmpty() for better performance&quot;)
	public static IJavaCompletionProposal replaceEqualsEmptyString(HintContext ctx) {
<span class="nc" id="L222">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (!(matchedNode instanceof MethodInvocation)) {</span>
<span class="nc" id="L225">			return null;</span>
		}

<span class="nc" id="L228">		MethodInvocation methodInvocation = (MethodInvocation) matchedNode;</span>

		// Get the string expression
<span class="nc" id="L231">		ASTNode strNode = ctx.getMatch().getBinding(&quot;$str&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">		if (strNode == null || !(strNode instanceof Expression)) {</span>
<span class="nc" id="L233">			return null;</span>
		}

<span class="nc" id="L236">		Expression strExpression = (Expression) strNode;</span>

		// Create the replacement: strExpression.isEmpty()
<span class="nc" id="L239">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L241">		MethodInvocation isEmptyCall = ast.newMethodInvocation();</span>
<span class="nc" id="L242">		isEmptyCall.setExpression((Expression) ASTNode.copySubtree(ast, strExpression));</span>
<span class="nc" id="L243">		isEmptyCall.setName(ast.newSimpleName(&quot;isEmpty&quot;)); //$NON-NLS-1$</span>

		// Apply the rewrite
<span class="nc" id="L246">		ctx.getASTRewrite().replace(methodInvocation, isEmptyCall, null);</span>

		// Create the proposal
<span class="nc" id="L249">		String label = &quot;Replace '&quot; + methodInvocation + &quot;' with 'isEmpty()'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L250">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L251">			label,</span>
<span class="nc" id="L252">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L253">			ctx.getASTRewrite(),</span>
<span class="nc" id="L254">			10, // relevance</span>
<span class="nc" id="L255">			(Image) null</span>
		);

<span class="nc" id="L258">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $x == true} with {@code $x}.
	 * 
	 * &lt;p&gt;Example: {@code flag == true} becomes {@code flag}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$x == true&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify boolean comparison&quot;, 
	      description = &quot;Removes redundant comparison with true&quot;)
	public static IJavaCompletionProposal simplifyBooleanComparisonTrue(HintContext ctx) {
<span class="nc" id="L273">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L276">			return null;</span>
		}

<span class="nc" id="L279">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the boolean variable
<span class="nc" id="L282">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L283" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L284">			return null;</span>
		}

<span class="nc" id="L287">		Expression boolExpression = (Expression) xNode;</span>

		// Create the replacement: just the boolean expression
<span class="nc" id="L290">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L291">		Expression replacement = (Expression) ASTNode.copySubtree(ast, boolExpression);</span>

		// Apply the rewrite
<span class="nc" id="L294">		ctx.getASTRewrite().replace(infixExpr, replacement, null);</span>

		// Create the proposal
<span class="nc" id="L297">		String label = &quot;Simplify '&quot; + infixExpr + &quot;' to '&quot; + boolExpression + &quot;'&quot;; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</span>
<span class="nc" id="L298">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L299">			label,</span>
<span class="nc" id="L300">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L301">			ctx.getASTRewrite(),</span>
<span class="nc" id="L302">			10, // relevance</span>
<span class="nc" id="L303">			(Image) null</span>
		);

<span class="nc" id="L306">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $x == false} with {@code !$x}.
	 * 
	 * &lt;p&gt;Example: {@code flag == false} becomes {@code !flag}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$x == false&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify boolean comparison&quot;, 
	      description = &quot;Replaces comparison with false with negation operator&quot;)
	public static IJavaCompletionProposal simplifyBooleanComparisonFalse(HintContext ctx) {
<span class="nc" id="L321">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L324">			return null;</span>
		}

<span class="nc" id="L327">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the boolean variable
<span class="nc" id="L330">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L332">			return null;</span>
		}

<span class="nc" id="L335">		Expression boolExpression = (Expression) xNode;</span>

		// Create the replacement: !boolExpression
<span class="nc" id="L338">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L339">		PrefixExpression negation = ast.newPrefixExpression();</span>
<span class="nc" id="L340">		negation.setOperator(PrefixExpression.Operator.NOT);</span>
<span class="nc" id="L341">		negation.setOperand((Expression) ASTNode.copySubtree(ast, boolExpression));</span>

		// Apply the rewrite
<span class="nc" id="L344">		ctx.getASTRewrite().replace(infixExpr, negation, null);</span>

		// Create the proposal
<span class="nc" id="L347">		String label = &quot;Simplify '&quot; + infixExpr + &quot;' to '!&quot; + boolExpression + &quot;'&quot;; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</span>
<span class="nc" id="L348">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L349">			label,</span>
<span class="nc" id="L350">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L351">			ctx.getASTRewrite(),</span>
<span class="nc" id="L352">			10, // relevance</span>
<span class="nc" id="L353">			(Image) null</span>
		);

<span class="nc" id="L356">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $cond ? true : false} with {@code $cond}.
	 * 
	 * &lt;p&gt;Example: {@code isValid() ? true : false} becomes {@code isValid()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$cond ? true : false&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify ternary boolean&quot;, 
	      description = &quot;Replaces redundant ternary expression with condition itself&quot;)
	public static IJavaCompletionProposal simplifyTernaryBooleanTrueFalse(HintContext ctx) {
<span class="nc" id="L371">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L373" title="All 2 branches missed.">		if (!(matchedNode instanceof ConditionalExpression)) {</span>
<span class="nc" id="L374">			return null;</span>
		}

<span class="nc" id="L377">		ConditionalExpression ternary = (ConditionalExpression) matchedNode;</span>

		// Get the condition
<span class="nc" id="L380">		ASTNode condNode = ctx.getMatch().getBinding(&quot;$cond&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">		if (condNode == null || !(condNode instanceof Expression)) {</span>
<span class="nc" id="L382">			return null;</span>
		}

<span class="nc" id="L385">		Expression condition = (Expression) condNode;</span>

		// Create the replacement: just the condition
<span class="nc" id="L388">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L389">		Expression replacement = (Expression) ASTNode.copySubtree(ast, condition);</span>

		// Apply the rewrite
<span class="nc" id="L392">		ctx.getASTRewrite().replace(ternary, replacement, null);</span>

		// Create the proposal
<span class="nc" id="L395">		String label = &quot;Simplify '&quot; + ternary + &quot;' to '&quot; + condition + &quot;'&quot;; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</span>
<span class="nc" id="L396">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L397">			label,</span>
<span class="nc" id="L398">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L399">			ctx.getASTRewrite(),</span>
<span class="nc" id="L400">			10, // relevance</span>
<span class="nc" id="L401">			(Image) null</span>
		);

<span class="nc" id="L404">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $cond ? false : true} with {@code !$cond}.
	 * 
	 * &lt;p&gt;Example: {@code isValid() ? false : true} becomes {@code !isValid()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$cond ? false : true&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify ternary boolean&quot;, 
	      description = &quot;Replaces inverted ternary expression with negated condition&quot;)
	public static IJavaCompletionProposal simplifyTernaryBooleanFalseTrue(HintContext ctx) {
<span class="nc" id="L419">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (!(matchedNode instanceof ConditionalExpression)) {</span>
<span class="nc" id="L422">			return null;</span>
		}

<span class="nc" id="L425">		ConditionalExpression ternary = (ConditionalExpression) matchedNode;</span>

		// Get the condition
<span class="nc" id="L428">		ASTNode condNode = ctx.getMatch().getBinding(&quot;$cond&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">		if (condNode == null || !(condNode instanceof Expression)) {</span>
<span class="nc" id="L430">			return null;</span>
		}

<span class="nc" id="L433">		Expression condition = (Expression) condNode;</span>

		// Create the replacement: !condition
<span class="nc" id="L436">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L437">		PrefixExpression negation = ast.newPrefixExpression();</span>
<span class="nc" id="L438">		negation.setOperator(PrefixExpression.Operator.NOT);</span>
<span class="nc" id="L439">		negation.setOperand((Expression) ASTNode.copySubtree(ast, condition));</span>

		// Apply the rewrite
<span class="nc" id="L442">		ctx.getASTRewrite().replace(ternary, negation, null);</span>

		// Create the proposal
<span class="nc" id="L445">		String label = &quot;Simplify '&quot; + ternary + &quot;' to '!&quot; + condition + &quot;'&quot;; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$</span>
<span class="nc" id="L446">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L447">			label,</span>
<span class="nc" id="L448">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L449">			ctx.getASTRewrite(),</span>
<span class="nc" id="L450">			10, // relevance</span>
<span class="nc" id="L451">			(Image) null</span>
		);

<span class="nc" id="L454">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $list.size() == 0} with {@code $list.isEmpty()}.
	 * 
	 * &lt;p&gt;This pattern works for any Collection type (List, Set, Map, etc.)&lt;/p&gt;
	 * &lt;p&gt;Example: {@code myList.size() == 0} becomes {@code myList.isEmpty()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$list.size() == 0&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use isEmpty() for collections&quot;, 
	      description = &quot;Replaces size() == 0 with isEmpty() for better readability and performance&quot;)
	public static IJavaCompletionProposal replaceCollectionSizeCheck(HintContext ctx) {
<span class="nc" id="L470">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L472" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L473">			return null;</span>
		}

<span class="nc" id="L476">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the collection expression
<span class="nc" id="L479">		ASTNode listNode = ctx.getMatch().getBinding(&quot;$list&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">		if (listNode == null || !(listNode instanceof Expression)) {</span>
<span class="nc" id="L481">			return null;</span>
		}

<span class="nc" id="L484">		Expression listExpression = (Expression) listNode;</span>

		// Create the replacement: listExpression.isEmpty()
<span class="nc" id="L487">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L489">		MethodInvocation isEmptyCall = ast.newMethodInvocation();</span>
<span class="nc" id="L490">		isEmptyCall.setExpression((Expression) ASTNode.copySubtree(ast, listExpression));</span>
<span class="nc" id="L491">		isEmptyCall.setName(ast.newSimpleName(&quot;isEmpty&quot;)); //$NON-NLS-1$</span>

		// Apply the rewrite
<span class="nc" id="L494">		ctx.getASTRewrite().replace(infixExpr, isEmptyCall, null);</span>

		// Create the proposal
<span class="nc" id="L497">		String label = &quot;Replace '&quot; + infixExpr + &quot;' with 'isEmpty()'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L498">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L499">			label,</span>
<span class="nc" id="L500">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L501">			ctx.getASTRewrite(),</span>
<span class="nc" id="L502">			10, // relevance</span>
<span class="nc" id="L503">			(Image) null</span>
		);

<span class="nc" id="L506">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $list.size() &gt; 0} with {@code !$list.isEmpty()}.
	 * 
	 * &lt;p&gt;Example: {@code myList.size() &gt; 0} becomes {@code !myList.isEmpty()}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$list.size() &gt; 0&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use !isEmpty() for collections&quot;, 
	      description = &quot;Replaces size() &gt; 0 with !isEmpty() for better readability&quot;)
	public static IJavaCompletionProposal replaceCollectionSizeGreaterThanZero(HintContext ctx) {
<span class="nc" id="L521">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L523" title="All 2 branches missed.">		if (!(matchedNode instanceof InfixExpression)) {</span>
<span class="nc" id="L524">			return null;</span>
		}

<span class="nc" id="L527">		InfixExpression infixExpr = (InfixExpression) matchedNode;</span>

		// Get the collection expression
<span class="nc" id="L530">		ASTNode listNode = ctx.getMatch().getBinding(&quot;$list&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">		if (listNode == null || !(listNode instanceof Expression)) {</span>
<span class="nc" id="L532">			return null;</span>
		}

<span class="nc" id="L535">		Expression listExpression = (Expression) listNode;</span>

		// Create the replacement: !listExpression.isEmpty()
<span class="nc" id="L538">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L540">		MethodInvocation isEmptyCall = ast.newMethodInvocation();</span>
<span class="nc" id="L541">		isEmptyCall.setExpression((Expression) ASTNode.copySubtree(ast, listExpression));</span>
<span class="nc" id="L542">		isEmptyCall.setName(ast.newSimpleName(&quot;isEmpty&quot;)); //$NON-NLS-1$</span>
		
<span class="nc" id="L544">		PrefixExpression negation = ast.newPrefixExpression();</span>
<span class="nc" id="L545">		negation.setOperator(PrefixExpression.Operator.NOT);</span>
<span class="nc" id="L546">		negation.setOperand(isEmptyCall);</span>

		// Apply the rewrite
<span class="nc" id="L549">		ctx.getASTRewrite().replace(infixExpr, negation, null);</span>

		// Create the proposal
<span class="nc" id="L552">		String label = &quot;Replace '&quot; + infixExpr + &quot;' with '!isEmpty()'&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L553">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L554">			label,</span>
<span class="nc" id="L555">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L556">			ctx.getASTRewrite(),</span>
<span class="nc" id="L557">			10, // relevance</span>
<span class="nc" id="L558">			(Image) null</span>
		);

<span class="nc" id="L561">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code new StringBuilder().append($x).toString()} with {@code String.valueOf($x)}.
	 * 
	 * &lt;p&gt;This is a more complex pattern that demonstrates TriggerPattern's ability to match
	 * chained method calls. The pattern identifies an anti-pattern where StringBuilder is
	 * unnecessarily used for a single value conversion.&lt;/p&gt;
	 * 
	 * &lt;p&gt;Example: {@code new StringBuilder().append(value).toString()} becomes {@code String.valueOf(value)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;new StringBuilder().append($x).toString()&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify StringBuilder single append&quot;, 
	      description = &quot;Replaces unnecessary StringBuilder with single append with String.valueOf()&quot;)
	public static IJavaCompletionProposal simplifyStringBuilderSingleAppend(HintContext ctx) {
<span class="nc" id="L580">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L582" title="All 2 branches missed.">		if (!(matchedNode instanceof MethodInvocation)) {</span>
<span class="nc" id="L583">			return null;</span>
		}

<span class="nc" id="L586">		MethodInvocation methodInvocation = (MethodInvocation) matchedNode;</span>

		// Get the appended value
<span class="nc" id="L589">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L590" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L591">			return null;</span>
		}

<span class="nc" id="L594">		Expression valueExpression = (Expression) xNode;</span>

		// Create the replacement: String.valueOf(valueExpression)
<span class="nc" id="L597">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L599">		MethodInvocation valueOfCall = ast.newMethodInvocation();</span>
<span class="nc" id="L600">		valueOfCall.setExpression(ast.newName(&quot;String&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L601">		valueOfCall.setName(ast.newSimpleName(&quot;valueOf&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L602">		valueOfCall.arguments().add(ASTNode.copySubtree(ast, valueExpression));</span>

		// Apply the rewrite
<span class="nc" id="L605">		ctx.getASTRewrite().replace(methodInvocation, valueOfCall, null);</span>

		// Create the proposal
<span class="nc" id="L608">		String label = &quot;Replace StringBuilder single append with 'String.valueOf(...)'&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L609">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L610">			label,</span>
<span class="nc" id="L611">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L612">			ctx.getASTRewrite(),</span>
<span class="nc" id="L613">			10, // relevance</span>
<span class="nc" id="L614">			(Image) null</span>
		);

<span class="nc" id="L617">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code String.format(&quot;%s&quot;, $x)} with {@code String.valueOf($x)}.
	 * 
	 * &lt;p&gt;This pattern identifies cases where String.format is used with a simple &quot;%s&quot; format
	 * string, which is unnecessarily complex compared to String.valueOf().&lt;/p&gt;
	 * 
	 * &lt;p&gt;Example: {@code String.format(&quot;%s&quot;, obj)} becomes {@code String.valueOf(obj)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;String.format(\&quot;%s\&quot;, $x)&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Simplify String.format&quot;, 
	      description = &quot;Replaces String.format with simple %s with String.valueOf() for better performance&quot;)
	public static IJavaCompletionProposal simplifyStringFormat(HintContext ctx) {
<span class="nc" id="L635">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">		if (!(matchedNode instanceof MethodInvocation)) {</span>
<span class="nc" id="L638">			return null;</span>
		}

<span class="nc" id="L641">		MethodInvocation methodInvocation = (MethodInvocation) matchedNode;</span>

		// Get the formatted value
<span class="nc" id="L644">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L645" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression)) {</span>
<span class="nc" id="L646">			return null;</span>
		}

<span class="nc" id="L649">		Expression valueExpression = (Expression) xNode;</span>

		// Create the replacement: String.valueOf(valueExpression)
<span class="nc" id="L652">		AST ast = ctx.getASTRewrite().getAST();</span>
		
<span class="nc" id="L654">		MethodInvocation valueOfCall = ast.newMethodInvocation();</span>
<span class="nc" id="L655">		valueOfCall.setExpression(ast.newName(&quot;String&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L656">		valueOfCall.setName(ast.newSimpleName(&quot;valueOf&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L657">		valueOfCall.arguments().add(ASTNode.copySubtree(ast, valueExpression));</span>

		// Apply the rewrite
<span class="nc" id="L660">		ctx.getASTRewrite().replace(methodInvocation, valueOfCall, null);</span>

		// Create the proposal
<span class="nc" id="L663">		String label = &quot;Replace 'String.format(\&quot;%s\&quot;, ...)' with 'String.valueOf(...)'&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L664">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L665">			label,</span>
<span class="nc" id="L666">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L667">			ctx.getASTRewrite(),</span>
<span class="nc" id="L668">			10, // relevance</span>
<span class="nc" id="L669">			(Image) null</span>
		);

<span class="nc" id="L672">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $x.toString().equals($y)} with {@code Objects.equals($x.toString(), $y)}.
	 * 
	 * &lt;p&gt;This is a complex pattern demonstrating null-safety improvements. The original code
	 * will throw NPE if $x is null, while the suggested replacement handles null safely.&lt;/p&gt;
	 * 
	 * &lt;p&gt;Example: {@code obj.toString().equals(str)} becomes {@code Objects.equals(obj.toString(), str)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$x.toString().equals($y)&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use Objects.equals for null safety&quot;, 
	      description = &quot;Replaces potential NPE-prone equals() with null-safe Objects.equals()&quot;)
	public static IJavaCompletionProposal useObjectsEquals(HintContext ctx) {
<span class="nc" id="L690">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L692" title="All 2 branches missed.">		if (!(matchedNode instanceof MethodInvocation)) {</span>
<span class="nc" id="L693">			return null;</span>
		}

<span class="nc" id="L696">		MethodInvocation methodInvocation = (MethodInvocation) matchedNode;</span>

		// Get both expressions
<span class="nc" id="L699">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L700">		ASTNode yNode = ctx.getMatch().getBinding(&quot;$y&quot;); //$NON-NLS-1$</span>
		
<span class="nc bnc" id="L702" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression) ||</span>
<span class="nc bnc" id="L703" title="All 4 branches missed.">		    yNode == null || !(yNode instanceof Expression)) {</span>
<span class="nc" id="L704">			return null;</span>
		}

<span class="nc" id="L707">		Expression xExpression = (Expression) xNode;</span>
<span class="nc" id="L708">		Expression yExpression = (Expression) yNode;</span>

		// Create the replacement: Objects.equals(x.toString(), y)
<span class="nc" id="L711">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L712">		ImportRewrite importRewrite = ctx.getImportRewrite();</span>
		
		// Add import for Objects if needed
<span class="nc" id="L715">		String objectsType = importRewrite.addImport(&quot;java.util.Objects&quot;); //$NON-NLS-1$</span>
		
<span class="nc" id="L717">		MethodInvocation equalsCall = ast.newMethodInvocation();</span>
<span class="nc" id="L718">		equalsCall.setExpression(ast.newName(objectsType));</span>
<span class="nc" id="L719">		equalsCall.setName(ast.newSimpleName(&quot;equals&quot;)); //$NON-NLS-1$</span>
		
		// Create x.toString()
<span class="nc" id="L722">		MethodInvocation toStringCall = ast.newMethodInvocation();</span>
<span class="nc" id="L723">		toStringCall.setExpression((Expression) ASTNode.copySubtree(ast, xExpression));</span>
<span class="nc" id="L724">		toStringCall.setName(ast.newSimpleName(&quot;toString&quot;)); //$NON-NLS-1$</span>
		
<span class="nc" id="L726">		equalsCall.arguments().add(toStringCall);</span>
<span class="nc" id="L727">		equalsCall.arguments().add(ASTNode.copySubtree(ast, yExpression));</span>

		// Apply the rewrite
<span class="nc" id="L730">		ctx.getASTRewrite().replace(methodInvocation, equalsCall, null);</span>

		// Create the proposal
<span class="nc" id="L733">		String label = &quot;Replace with null-safe 'Objects.equals(...)'&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L734">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L735">			label,</span>
<span class="nc" id="L736">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L737">			ctx.getASTRewrite(),</span>
<span class="nc" id="L738">			10, // relevance</span>
<span class="nc" id="L739">			(Image) null</span>
		);

<span class="nc" id="L742">		return proposal;</span>
	}

	/**
	 * Suggests replacing {@code $x != null ? $x : $default} with {@code Objects.requireNonNullElse($x, $default)}.
	 * 
	 * &lt;p&gt;This is a complex pattern that demonstrates modern Java API usage (Java 9+).
	 * It shows how TriggerPattern can suggest more idiomatic code that leverages newer APIs.&lt;/p&gt;
	 * 
	 * &lt;p&gt;Example: {@code obj != null ? obj : &quot;default&quot;} becomes {@code Objects.requireNonNullElse(obj, &quot;default&quot;)}&lt;/p&gt;
	 * 
	 * @param ctx the hint context containing the match and AST information
	 * @return a completion proposal, or null if the pattern doesn't match
	 */
	@TriggerPattern(value = &quot;$x != null ? $x : $default&quot;, kind = PatternKind.EXPRESSION)
	@Hint(displayName = &quot;Use Objects.requireNonNullElse&quot;, 
	      description = &quot;Replaces null-check ternary with Objects.requireNonNullElse() (Java 9+)&quot;)
	public static IJavaCompletionProposal useRequireNonNullElse(HintContext ctx) {
<span class="nc" id="L760">		ASTNode matchedNode = ctx.getMatch().getMatchedNode();</span>

<span class="nc bnc" id="L762" title="All 2 branches missed.">		if (!(matchedNode instanceof ConditionalExpression)) {</span>
<span class="nc" id="L763">			return null;</span>
		}

<span class="nc" id="L766">		ConditionalExpression ternary = (ConditionalExpression) matchedNode;</span>

		// Get the expressions
<span class="nc" id="L769">		ASTNode xNode = ctx.getMatch().getBinding(&quot;$x&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L770">		ASTNode defaultNode = ctx.getMatch().getBinding(&quot;$default&quot;); //$NON-NLS-1$</span>
		
<span class="nc bnc" id="L772" title="All 4 branches missed.">		if (xNode == null || !(xNode instanceof Expression) ||</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">		    defaultNode == null || !(defaultNode instanceof Expression)) {</span>
<span class="nc" id="L774">			return null;</span>
		}

<span class="nc" id="L777">		Expression xExpression = (Expression) xNode;</span>
<span class="nc" id="L778">		Expression defaultExpression = (Expression) defaultNode;</span>

		// Create the replacement: Objects.requireNonNullElse(x, default)
<span class="nc" id="L781">		AST ast = ctx.getASTRewrite().getAST();</span>
<span class="nc" id="L782">		ImportRewrite importRewrite = ctx.getImportRewrite();</span>
		
		// Add import for Objects if needed
<span class="nc" id="L785">		String objectsType = importRewrite.addImport(&quot;java.util.Objects&quot;); //$NON-NLS-1$</span>
		
<span class="nc" id="L787">		MethodInvocation requireNonNullElseCall = ast.newMethodInvocation();</span>
<span class="nc" id="L788">		requireNonNullElseCall.setExpression(ast.newName(objectsType));</span>
<span class="nc" id="L789">		requireNonNullElseCall.setName(ast.newSimpleName(&quot;requireNonNullElse&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L790">		requireNonNullElseCall.arguments().add(ASTNode.copySubtree(ast, xExpression));</span>
<span class="nc" id="L791">		requireNonNullElseCall.arguments().add(ASTNode.copySubtree(ast, defaultExpression));</span>

		// Apply the rewrite
<span class="nc" id="L794">		ctx.getASTRewrite().replace(ternary, requireNonNullElseCall, null);</span>

		// Create the proposal
<span class="nc" id="L797">		String label = &quot;Replace with 'Objects.requireNonNullElse(...)'&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L798">		ASTRewriteCorrectionProposal proposal = new ASTRewriteCorrectionProposal(</span>
<span class="nc" id="L799">			label,</span>
<span class="nc" id="L800">			ctx.getICompilationUnit(),</span>
<span class="nc" id="L801">			ctx.getASTRewrite(),</span>
<span class="nc" id="L802">			10, // relevance</span>
<span class="nc" id="L803">			(Image) null</span>
		);

<span class="nc" id="L806">		return proposal;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>