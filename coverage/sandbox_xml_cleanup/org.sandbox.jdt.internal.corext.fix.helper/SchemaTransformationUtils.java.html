<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SchemaTransformationUtils.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_xml_cleanup</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">SchemaTransformationUtils.java</span></div><h1>SchemaTransformationUtils.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

/**
 * Utilities for transforming XML/XSD/EXSD files using XSLT and post-processing.
 */
<span class="nc" id="L33">public class SchemaTransformationUtils {</span>
	
	/**
	 * Transform an XML file with default settings (no indentation).
	 * 
	 * @param schemaPath path to the XML file
	 * @return transformed content
	 * @throws Exception if transformation fails
	 */
	public static String transform(Path schemaPath) throws Exception {
<span class="nc" id="L43">		return transform(schemaPath, false);</span>
	}
	
	/**
	 * Transform an XML file with configurable indentation.
	 * 
	 * @param schemaPath path to the XML file
	 * @param enableIndent whether to enable indentation (default is false for size reduction)
	 * @return transformed content
	 * @throws Exception if transformation fails
	 */
	public static String transform(Path schemaPath, boolean enableIndent) throws Exception {
		// Load the formatter.xsl file from classpath
<span class="fc" id="L56">		try (InputStream xslStream = SchemaTransformationUtils.class.getClassLoader().getResourceAsStream(&quot;resources/formatter.xsl&quot;)) {</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">			if (xslStream == null) {</span>
<span class="nc" id="L58">				throw new IllegalArgumentException(&quot;Unable to find formatter.xsl in resources.&quot;);</span>
			}

			// Initialize transformer with secure settings
<span class="fc" id="L62">			TransformerFactory factory = TransformerFactory.newInstance();</span>
<span class="fc" id="L63">			factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="fc" id="L64">			factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L65">			factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);</span>
			
			// Additional security features
//			factory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
//			factory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
//			factory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
			
<span class="fc" id="L72">			Transformer transformer = factory.newTransformer(new StreamSource(xslStream));</span>
			
			// Set indentation to &quot;yes&quot; to get proper formatting that can be converted to tabs
			// The enableIndent parameter controls whether the final output has tabs or spaces
<span class="fc" id="L76">			transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>

			// Perform transformation
<span class="fc" id="L79">			StreamSource source = new StreamSource(schemaPath.toFile());</span>
<span class="fc" id="L80">			Path tempOutput = Files.createTempFile(&quot;formatted-schema&quot;, &quot;.xml&quot;);</span>
			
			try {
<span class="fc" id="L83">				StreamResult result = new StreamResult(tempOutput.toFile());</span>
<span class="fc" id="L84">				transformer.transform(source, result);</span>

				// Read transformed content
<span class="fc" id="L87">				String transformed = Files.readString(tempOutput, StandardCharsets.UTF_8);</span>
				
				// Post-processing for size reduction:
				
				// 1. Collapse empty elements to self-closing tags
<span class="fc" id="L92">				transformed = collapseEmptyElements(transformed);</span>
				
				// 2. Remove trailing whitespace from all lines
<span class="fc" id="L95">				transformed = removeTrailingWhitespace(transformed);</span>
				
				// 3. Normalize whitespace (convert leading spaces to tabs, reduce empty lines)
<span class="fc" id="L98">				transformed = normalizeWhitespace(transformed);</span>
				
<span class="fc" id="L100">				return transformed;</span>
			} finally {
				// Ensure temp file is always deleted
<span class="fc" id="L103">				Files.deleteIfExists(tempOutput);</span>
			}
		}
	}
	
	/**
	 * Collapse empty XML elements to self-closing tags.
	 * Converts: &lt;element&gt;&lt;/element&gt; or &lt;element&gt;   &lt;/element&gt;
	 * To: &lt;element/&gt;
	 * 
	 * @param content the XML content
	 * @return content with empty elements collapsed
	 */
	private static String collapseEmptyElements(String content) {
		// Pattern matches: &lt;tagname attributes&gt;&lt;/tagname&gt; or &lt;tagname attributes&gt;   &lt;/tagname&gt;
		// Captures the opening tag (without &gt;) and ensures matching closing tag
		// Supports namespaces (e.g., ns:element)
<span class="fc" id="L120">		Pattern emptyElementPattern = Pattern.compile(</span>
<span class="fc" id="L121">			&quot;&lt;([\\w:]+)((?:\\s+[^&gt;]*?)?)&gt;\\s*&lt;/\\1&gt;&quot;,</span>
<span class="fc" id="L122">			Pattern.MULTILINE</span>
		);
		
<span class="fc" id="L125">		Matcher matcher = emptyElementPattern.matcher(content);</span>
<span class="fc" id="L126">		StringBuffer sb = new StringBuffer();</span>
		
<span class="fc bfc" id="L128" title="All 2 branches covered.">		while (matcher.find()) {</span>
<span class="fc" id="L129">			String tagName = matcher.group(1);</span>
<span class="fc" id="L130">			String attributes = matcher.group(2);</span>
			// Replace with self-closing tag
<span class="fc" id="L132">			String replacement = &quot;&lt;&quot; + tagName + attributes + &quot;/&gt;&quot;;</span>
<span class="fc" id="L133">			matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));</span>
		}
<span class="fc" id="L135">		matcher.appendTail(sb);</span>
		
<span class="fc" id="L137">		return sb.toString();</span>
	}
	
	/**
	 * Remove trailing whitespace from all lines.
	 * Only removes spaces and tabs at the end of lines, not other whitespace.
	 * 
	 * @param content the XML content
	 * @return content with trailing whitespace removed from each line
	 */
	private static String removeTrailingWhitespace(String content) {
		// Remove trailing spaces/tabs from each line
		// Pattern matches spaces or tabs at the end of lines (before newline or end of string)
		// Using (?m) for MULTILINE mode to match end-of-line, not just end-of-string
<span class="fc" id="L151">		return content.replaceAll(&quot;(?m)[ \\t]+$&quot;, &quot;&quot;);</span>
	}
	
	/**
	 * Normalize whitespace in the transformed XML:
	 * - Reduce excessive empty lines (max 2 consecutive empty lines)
	 * - Convert leading 4-space indentation to tabs (not inside text nodes)
	 * - Preserve comments and content
	 * - Preserve original line ending style (CRLF vs LF)
	 * 
	 * @param content the XML content to normalize
	 * @return normalized content
	 */
	private static String normalizeWhitespace(String content) {
		// Reduce excessive empty lines - keep max 2 consecutive empty lines,
		// preserving the original line ending style (LF vs CRLF)
<span class="fc" id="L167">		content = content.replaceAll(&quot;(\\r?\\n){3,}&quot;, &quot;$1$1&quot;);</span>
		
		// Convert leading 4 spaces to tabs (only at line start, not in text content)
		// This pattern matches lines that start with spaces (after optional newline)
<span class="fc" id="L171">		Pattern leadingSpaces = Pattern.compile(&quot;^( {4})+&quot;, Pattern.MULTILINE);</span>
<span class="fc" id="L172">		Matcher matcher = leadingSpaces.matcher(content);</span>
<span class="fc" id="L173">		StringBuilder sb = new StringBuilder();</span>
		
<span class="fc bfc" id="L175" title="All 2 branches covered.">		while (matcher.find()) {</span>
<span class="fc" id="L176">			String spaces = matcher.group();</span>
<span class="fc" id="L177">			int numSpaces = spaces.length();</span>
<span class="fc" id="L178">			int numTabs = numSpaces / 4;</span>
<span class="fc" id="L179">			matcher.appendReplacement(sb, &quot;\t&quot;.repeat(numTabs));</span>
		}
<span class="fc" id="L181">		matcher.appendTail(sb);</span>
		
<span class="fc" id="L183">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>