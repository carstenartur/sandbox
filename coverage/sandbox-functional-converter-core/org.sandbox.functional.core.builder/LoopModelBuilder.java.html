<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LoopModelBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox-functional-converter-core</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.functional.core.builder</a> &gt; <span class="el_source">LoopModelBuilder.java</span></div><h1>LoopModelBuilder.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.functional.core.builder;

import java.util.ArrayList;
import java.util.List;
import org.sandbox.functional.core.model.*;
import org.sandbox.functional.core.operation.*;
import org.sandbox.functional.core.terminal.*;

/**
 * Fluent builder for constructing LoopModel instances.
 * 
 * &lt;p&gt;This builder is AST-independent and works with abstract data.
 * JDT-specific extraction is handled by JdtLoopExtractor in the
 * sandbox_functional_converter module.&lt;/p&gt;
 * 
 * &lt;p&gt;Example usage:&lt;/p&gt;
 * &lt;pre&gt;
 * LoopModel model = new LoopModelBuilder()
 *     .source(SourceType.COLLECTION, &quot;list&quot;, &quot;String&quot;)
 *     .element(&quot;item&quot;, &quot;String&quot;, false)
 *     .metadata(false, false, false, false, true)
 *     .filter(&quot;item != null&quot;)
 *     .map(&quot;item.toUpperCase()&quot;, &quot;String&quot;)
 *     .forEach(List.of(&quot;System.out.println(item)&quot;), false)
 *     .build();
 * &lt;/pre&gt;
 */
public class LoopModelBuilder {
    
    private SourceDescriptor source;
    private ElementDescriptor element;
    private LoopMetadata metadata;
<span class="fc" id="L46">    private final List&lt;Operation&gt; operations = new ArrayList&lt;&gt;();</span>
    private TerminalOperation terminal;
    
<span class="fc" id="L49">    public LoopModelBuilder() {}</span>
    
    // Source configuration
    public LoopModelBuilder source(SourceDescriptor.SourceType type, 
                                   String expression, 
                                   String elementTypeName) {
<span class="fc" id="L55">        this.source = new SourceDescriptor(type, expression, elementTypeName);</span>
<span class="fc" id="L56">        return this;</span>
    }
    
    public LoopModelBuilder source(SourceDescriptor source) {
<span class="fc" id="L60">        this.source = source;</span>
<span class="fc" id="L61">        return this;</span>
    }
    
    // Element configuration
    public LoopModelBuilder element(String variableName, 
                                    String typeName, 
                                    boolean isFinal) {
<span class="fc" id="L68">        this.element = new ElementDescriptor(variableName, typeName, isFinal);</span>
<span class="fc" id="L69">        return this;</span>
    }
    
    public LoopModelBuilder element(ElementDescriptor element) {
<span class="fc" id="L73">        this.element = element;</span>
<span class="fc" id="L74">        return this;</span>
    }
    
    // Metadata configuration
    public LoopModelBuilder metadata(boolean hasBreak, 
                                     boolean hasContinue, 
                                     boolean hasReturn,
                                     boolean modifiesCollection, 
                                     boolean requiresOrdering) {
<span class="fc" id="L83">        this.metadata = new LoopMetadata(hasBreak, hasContinue, hasReturn, </span>
                                         modifiesCollection, requiresOrdering, false, false);
<span class="fc" id="L85">        return this;</span>
    }
    
    /**
     * Configures loop metadata with all safety flags.
     * 
     * @param hasBreak whether the loop contains break statements
     * @param hasContinue whether the loop contains continue statements
     * @param hasReturn whether the loop contains return statements
     * @param modifiesCollection whether the loop modifies the collection being iterated
     * @param requiresOrdering whether the loop requires ordering to be preserved
     * @param hasIteratorRemove whether the loop calls iterator.remove()
     * @param usesIndexBeyondGet whether the index variable is used beyond simple element access
     * @return this builder
     * @see &lt;a href=&quot;https://github.com/carstenartur/sandbox/issues/670&quot;&gt;Issue #670&lt;/a&gt;
     */
    public LoopModelBuilder metadata(boolean hasBreak,
                                     boolean hasContinue,
                                     boolean hasReturn,
                                     boolean modifiesCollection,
                                     boolean requiresOrdering,
                                     boolean hasIteratorRemove,
                                     boolean usesIndexBeyondGet) {
<span class="nc" id="L108">        this.metadata = new LoopMetadata(hasBreak, hasContinue, hasReturn,</span>
                                         modifiesCollection, requiresOrdering,
                                         hasIteratorRemove, usesIndexBeyondGet);
<span class="nc" id="L111">        return this;</span>
    }
    
    public LoopModelBuilder metadata(LoopMetadata metadata) {
<span class="nc" id="L115">        this.metadata = metadata;</span>
<span class="nc" id="L116">        return this;</span>
    }
    
    // Operation shortcuts
    public LoopModelBuilder filter(String expression) {
<span class="fc" id="L121">        this.operations.add(new FilterOp(expression));</span>
<span class="fc" id="L122">        return this;</span>
    }
    
    public LoopModelBuilder map(String expression, String targetType) {
<span class="fc" id="L126">        this.operations.add(new MapOp(expression, targetType));</span>
<span class="fc" id="L127">        return this;</span>
    }
    
    public LoopModelBuilder map(String expression, String targetType, String outputVariableName) {
<span class="fc" id="L131">        this.operations.add(new MapOp(expression, targetType, outputVariableName));</span>
<span class="fc" id="L132">        return this;</span>
    }
    
    public LoopModelBuilder map(String expression) {
<span class="fc" id="L136">        this.operations.add(new MapOp(expression, null));</span>
<span class="fc" id="L137">        return this;</span>
    }
    
    /**
     * Adds a side-effect MAP operation that wraps a statement block and returns the current variable.
     * Renders as: {@code .map(var -&gt; { statements; return var; })}
     * @param statementsBlock the side-effect statements
     * @param outputVariableName the variable to return from the map
     */
    public LoopModelBuilder sideEffectMap(String statementsBlock, String outputVariableName) {
<span class="fc" id="L147">        this.operations.add(new MapOp(statementsBlock, null, outputVariableName, true));</span>
<span class="fc" id="L148">        return this;</span>
    }
    
    public LoopModelBuilder flatMap(String expression) {
<span class="fc" id="L152">        this.operations.add(new FlatMapOp(expression));</span>
<span class="fc" id="L153">        return this;</span>
    }
    
    public LoopModelBuilder peek(String expression) {
<span class="fc" id="L157">        this.operations.add(new PeekOp(expression));</span>
<span class="fc" id="L158">        return this;</span>
    }
    
    public LoopModelBuilder distinct() {
<span class="fc" id="L162">        this.operations.add(new DistinctOp());</span>
<span class="fc" id="L163">        return this;</span>
    }
    
    public LoopModelBuilder sorted() {
<span class="fc" id="L167">        this.operations.add(new SortOp(null));</span>
<span class="fc" id="L168">        return this;</span>
    }
    
    public LoopModelBuilder sorted(String comparatorExpression) {
<span class="fc" id="L172">        this.operations.add(new SortOp(comparatorExpression));</span>
<span class="fc" id="L173">        return this;</span>
    }
    
    public LoopModelBuilder limit(long maxSize) {
<span class="fc" id="L177">        this.operations.add(new LimitOp(maxSize));</span>
<span class="fc" id="L178">        return this;</span>
    }
    
    public LoopModelBuilder skip(long count) {
<span class="fc" id="L182">        this.operations.add(new SkipOp(count));</span>
<span class="fc" id="L183">        return this;</span>
    }
    
    public LoopModelBuilder operation(Operation op) {
<span class="fc" id="L187">        this.operations.add(op);</span>
<span class="fc" id="L188">        return this;</span>
    }
    
    /**
     * Returns the last added operation, or null if no operations have been added.
     * Useful for attaching comments to the most recently created operation.
     * @return the last added Operation, or null
     */
    public Operation getLastOperation() {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (this.operations.isEmpty()) {</span>
<span class="nc" id="L198">            return null;</span>
        }
<span class="fc" id="L200">        return this.operations.get(this.operations.size() - 1);</span>
    }
    
    /**
     * Returns whether any intermediate operations (filter, map, etc.) have been added.
     * @return true if operations exist
     */
    public boolean hasOperations() {
<span class="fc bfc" id="L208" title="All 2 branches covered.">        return !this.operations.isEmpty();</span>
    }
    
    // Terminal shortcuts
    public LoopModelBuilder forEach(List&lt;String&gt; bodyStatements, boolean ordered) {
<span class="fc" id="L213">        this.terminal = new ForEachTerminal(bodyStatements, ordered);</span>
<span class="fc" id="L214">        return this;</span>
    }
    
    public LoopModelBuilder forEach(List&lt;String&gt; bodyStatements) {
<span class="fc" id="L218">        return forEach(bodyStatements, false);</span>
    }
    
    public LoopModelBuilder collect(CollectTerminal.CollectorType type, 
                                    String targetVariable) {
<span class="fc" id="L223">        this.terminal = new CollectTerminal(type, targetVariable);</span>
<span class="fc" id="L224">        return this;</span>
    }
    
    public LoopModelBuilder reduce(String identity, 
                                   String accumulator, 
                                   String combiner,
                                   ReduceTerminal.ReduceType type) {
<span class="fc" id="L231">        this.terminal = new ReduceTerminal(identity, accumulator, combiner, type);</span>
<span class="fc" id="L232">        return this;</span>
    }
    
    public LoopModelBuilder count() {
<span class="fc" id="L236">        this.terminal = new CountTerminal();</span>
<span class="fc" id="L237">        return this;</span>
    }
    
    public LoopModelBuilder findFirst() {
<span class="fc" id="L241">        this.terminal = new FindTerminal(true);</span>
<span class="fc" id="L242">        return this;</span>
    }
    
    public LoopModelBuilder findAny() {
<span class="fc" id="L246">        this.terminal = new FindTerminal(false);</span>
<span class="fc" id="L247">        return this;</span>
    }
    
    public LoopModelBuilder anyMatch(String predicate) {
<span class="fc" id="L251">        this.terminal = new MatchTerminal(MatchTerminal.MatchType.ANY_MATCH, predicate);</span>
<span class="fc" id="L252">        return this;</span>
    }
    
    public LoopModelBuilder allMatch(String predicate) {
<span class="fc" id="L256">        this.terminal = new MatchTerminal(MatchTerminal.MatchType.ALL_MATCH, predicate);</span>
<span class="fc" id="L257">        return this;</span>
    }
    
    public LoopModelBuilder noneMatch(String predicate) {
<span class="fc" id="L261">        this.terminal = new MatchTerminal(MatchTerminal.MatchType.NONE_MATCH, predicate);</span>
<span class="fc" id="L262">        return this;</span>
    }
    
    public LoopModelBuilder terminal(TerminalOperation terminal) {
<span class="fc" id="L266">        this.terminal = terminal;</span>
<span class="fc" id="L267">        return this;</span>
    }
    
    // Build
    public LoopModel build() {
<span class="fc" id="L272">        LoopModel model = new LoopModel(source, element, metadata);</span>
<span class="fc" id="L273">        operations.forEach(model::addOperation);</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (terminal != null) {</span>
<span class="fc" id="L275">            model.withTerminal(terminal);</span>
        }
<span class="fc" id="L277">        return model;</span>
    }
    
    // Validation
    public boolean isValid() {
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">        return source != null &amp;&amp; element != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>