<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ParameterizedTestJUnitPlugin.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_junit_cleanup</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">ParameterizedTestJUnitPlugin.java</span></div><h1>ParameterizedTestJUnitPlugin.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import static org.sandbox.jdt.internal.corext.fix.helper.lib.JUnitConstants.*;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Annotation;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperationWithSourceRange;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.corext.util.AnnotationUtils;
import org.sandbox.jdt.internal.common.HelperVisitor;
import org.sandbox.jdt.internal.common.HelperVisitorFactory;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.JUnitCleanUpFixCore;
import org.sandbox.jdt.internal.corext.fix.helper.lib.AbstractTool;
import org.sandbox.jdt.internal.corext.fix.helper.lib.JunitHolder;

/**
 * Plugin to migrate JUnit 4 @RunWith(Parameterized.class) to JUnit 5 @ParameterizedTest.
 * 
 * This transformation handles:
 * - Removing @RunWith(Parameterized.class) annotation
 * - Converting @Parameters method to return Stream&lt;Arguments&gt;
 * - Removing constructor and parameter fields
 * - Adding @ParameterizedTest and @MethodSource to test methods
 * - Adding method parameters to test methods
 */
<span class="fc" id="L69">public class ParameterizedTestJUnitPlugin extends AbstractTool&lt;ReferenceHolder&lt;Integer, JunitHolder&gt;&gt; {</span>

	@Override
	public void find(JUnitCleanUpFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {
<span class="fc" id="L74">		ReferenceHolder&lt;Integer, JunitHolder&gt; dataHolder = ReferenceHolder.createIndexed();</span>
		
		// Find @RunWith(Parameterized.class) annotations
<span class="fc" id="L77">		HelperVisitorFactory.forAnnotation(ORG_JUNIT_RUNWITH)</span>
<span class="fc" id="L78">			.in(compilationUnit)</span>
<span class="fc" id="L79">			.excluding(nodesprocessed)</span>
<span class="fc" id="L80">			.processEach(dataHolder, (visited, aholder) -&gt; {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">				if (visited instanceof Annotation) {</span>
<span class="fc" id="L82">					return processFoundNode(fixcore, operations, (Annotation) visited, aholder);</span>
				}
<span class="nc" id="L84">				return true;</span>
			});
<span class="fc" id="L86">	}</span>

	private boolean processFoundNode(JUnitCleanUpFixCore fixcore,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Annotation node,
			ReferenceHolder&lt;Integer, JunitHolder&gt; dataHolder) {
		
		// Check if this is @RunWith(Parameterized.class)
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">		if (node instanceof SingleMemberAnnotation mynode) {</span>
<span class="fc" id="L94">			Expression value = mynode.getValue();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">			if (value instanceof TypeLiteral myvalue) {</span>
<span class="fc" id="L96">				Type type = myvalue.getType();</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">				if (type != null) {</span>
<span class="fc" id="L98">					ITypeBinding typeBinding = type.resolveBinding();</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">					if (typeBinding != null) {</span>
<span class="fc" id="L100">						String runnerQualifiedName = typeBinding.getQualifiedName();</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">						if (ORG_JUNIT_RUNNERS_PARAMETERIZED.equals(runnerQualifiedName)) {</span>
							// Found a parameterized test class
<span class="fc" id="L103">							JunitHolder mh = new JunitHolder();</span>
<span class="fc" id="L104">							mh.setMinv(node);</span>
<span class="fc" id="L105">							mh.setMinvname(node.getTypeName().getFullyQualifiedName());</span>
<span class="fc" id="L106">							mh.setValue(ORG_JUNIT_RUNNERS_PARAMETERIZED);</span>
							
							// Get the containing type declaration to store for processing
<span class="fc" id="L109">							ASTNode parent = node.getParent();</span>
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">							while (parent != null &amp;&amp; !(parent instanceof TypeDeclaration)) {</span>
<span class="nc" id="L111">								parent = parent.getParent();</span>
							}
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">							if (parent != null) {</span>
<span class="fc" id="L114">								mh.setAdditionalInfo(parent);</span>
							}
							
<span class="fc" id="L117">							dataHolder.put(dataHolder.size(), mh);</span>
<span class="fc" id="L118">							operations.add(fixcore.rewrite(dataHolder));</span>
							// Return true to continue processing (there could be nested classes)
<span class="fc" id="L120">							return true;</span>
						}
					}
				}
			}
		}
		// Return true to continue processing other annotations
<span class="fc" id="L127">		return true;</span>
	}

	@Override
	protected void process2Rewrite(TextEditGroup group, ASTRewrite rewriter, AST ast, ImportRewrite importRewriter,
			JunitHolder junitHolder) {
		
<span class="fc" id="L134">		Annotation runWithAnnotation = junitHolder.getAnnotation();</span>
<span class="fc" id="L135">		TypeDeclaration typeDecl = (TypeDeclaration) junitHolder.getAdditionalInfo();</span>
		
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">		if (typeDecl == null) {</span>
<span class="nc" id="L138">			return; // Cannot proceed without type declaration</span>
		}
		
		// Step 1: Remove @RunWith annotation
<span class="fc" id="L142">		rewriter.remove(runWithAnnotation, group);</span>
		
		// Step 2: Find @Parameters method and constructor to extract parameter info
<span class="fc" id="L145">		MethodDeclaration parametersMethod = null;</span>
<span class="fc" id="L146">		MethodDeclaration constructor = null;</span>
<span class="fc" id="L147">		List&lt;SingleVariableDeclaration&gt; constructorParams = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L148">		Set&lt;String&gt; paramFieldNames = new HashSet&lt;&gt;();</span>
		
<span class="fc bfc" id="L150" title="All 2 branches covered.">		for (MethodDeclaration method : typeDecl.getMethods()) {</span>
			// Find @Parameters method
<span class="fc bfc" id="L152" title="All 2 branches covered.">			for (Object modifier : method.modifiers()) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				if (modifier instanceof Annotation) {</span>
<span class="fc" id="L154">					Annotation annot = (Annotation) modifier;</span>
<span class="fc" id="L155">					String annotName = annot.getTypeName().getFullyQualifiedName();</span>
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">					if (&quot;Parameters&quot;.equals(annotName) || ORG_JUNIT_RUNNERS_PARAMETERIZED_PARAMETERS.equals(annotName)) {</span>
<span class="fc" id="L157">						parametersMethod = method;</span>
<span class="fc" id="L158">						break;</span>
					}
				}
			}
			
			// Find constructor
			// Note: If multiple constructors exist, this uses the last one found.
			// Typically, parameterized tests have only one constructor that accepts the test parameters.
<span class="fc bfc" id="L166" title="All 2 branches covered.">			if (method.isConstructor()) {</span>
<span class="fc" id="L167">				constructor = method;</span>
<span class="fc" id="L168">				List&lt;SingleVariableDeclaration&gt; params = method.parameters();</span>
<span class="fc" id="L169">				constructorParams.addAll(params);</span>
				
				// Extract field names from constructor body (fields being assigned from parameters)
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">				if (method.getBody() != null) {</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">					for (Object stmt : method.getBody().statements()) {</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">						if (stmt instanceof ExpressionStatement) {</span>
<span class="fc" id="L175">							Expression expr = ((ExpressionStatement) stmt).getExpression();</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">							if (expr instanceof Assignment) {</span>
<span class="fc" id="L177">								Assignment assign = (Assignment) expr;</span>
<span class="fc" id="L178">								Expression lhs = assign.getLeftHandSide();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">								if (lhs instanceof SimpleName) {</span>
<span class="nc" id="L180">									paramFieldNames.add(((SimpleName) lhs).getIdentifier());</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">								} else if (lhs instanceof org.eclipse.jdt.core.dom.FieldAccess) {</span>
<span class="fc" id="L182">									org.eclipse.jdt.core.dom.FieldAccess fa = (org.eclipse.jdt.core.dom.FieldAccess) lhs;</span>
<span class="fc" id="L183">									paramFieldNames.add(fa.getName().getIdentifier());</span>
								}
							}
						}
					}
				}
			}
		}
		
		// Step 3: Create new transformed @Parameters method and add it at the end
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">		if (parametersMethod != null) {</span>
			// Create a completely new method with transformations applied
			// This avoids AST rewrite conflicts from modifying and moving the same node
<span class="fc" id="L196">			MethodDeclaration newMethod = createTransformedParametersMethod(parametersMethod, ast, rewriter, importRewriter);</span>
			
			// Remove the original method
<span class="fc" id="L199">			ListRewrite bodyRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);</span>
<span class="fc" id="L200">			bodyRewrite.remove(parametersMethod, group);</span>
			
			// Insert the new transformed method at the end of the class
			// This ensures test methods appear before the data provider in the output
<span class="fc" id="L204">			bodyRewrite.insertLast(newMethod, group);</span>
		}
		
		// Step 4: Remove constructor
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">		if (constructor != null) {</span>
<span class="fc" id="L209">			rewriter.remove(constructor, group);</span>
		}
		
		// Step 5: Remove parameter fields
<span class="fc" id="L213">		ListRewrite fieldListRewrite = rewriter.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">		for (Object bodyDecl : typeDecl.bodyDeclarations()) {</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">			if (bodyDecl instanceof FieldDeclaration) {</span>
<span class="fc" id="L216">				FieldDeclaration field = (FieldDeclaration) bodyDecl;</span>
<span class="fc" id="L217">				List&lt;VariableDeclarationFragment&gt; fragmentsToRemove = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">				for (Object frag : field.fragments()) {</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">					if (frag instanceof VariableDeclarationFragment) {</span>
<span class="fc" id="L220">						VariableDeclarationFragment fragment = (VariableDeclarationFragment) frag;</span>
<span class="fc" id="L221">						String fieldName = fragment.getName().getIdentifier();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">						if (paramFieldNames.contains(fieldName)) {</span>
<span class="fc" id="L223">							fragmentsToRemove.add(fragment);</span>
						}
					}
				}
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">				if (!fragmentsToRemove.isEmpty()) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">					if (fragmentsToRemove.size() == field.fragments().size()) {</span>
						// All fragments are parameter fields: remove entire declaration
<span class="fc" id="L230">						fieldListRewrite.remove(field, group);</span>
<span class="fc" id="L231">					} else {</span>
						// Only some fragments are parameter fields: remove them individually
<span class="nc" id="L233">						ListRewrite fragmentRewrite = rewriter.getListRewrite(field, FieldDeclaration.FRAGMENTS_PROPERTY);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">						for (VariableDeclarationFragment fragment : fragmentsToRemove) {</span>
<span class="nc" id="L235">							fragmentRewrite.remove(fragment, group);</span>
						}
					}
				}
			}
		}
		
		// Step 6: Transform @Test methods to @ParameterizedTest
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">		String parametersMethodName = parametersMethod != null ? parametersMethod.getName().getIdentifier() : &quot;data&quot;;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">		for (MethodDeclaration method : typeDecl.getMethods()) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			if (isTestMethod(method)) {</span>
<span class="fc" id="L246">				transformTestMethod(method, constructorParams, parametersMethodName, rewriter, ast, group, importRewriter);</span>
			}
		}
		
		// Step 7: Update imports
<span class="fc" id="L251">		importRewriter.removeImport(ORG_JUNIT_RUNWITH);</span>
<span class="fc" id="L252">		importRewriter.removeImport(ORG_JUNIT_RUNNERS_PARAMETERIZED);</span>
<span class="fc" id="L253">		importRewriter.removeImport(ORG_JUNIT_RUNNERS_PARAMETERIZED_PARAMETERS);</span>
<span class="fc" id="L254">		importRewriter.removeImport(&quot;java.util.Arrays&quot;);</span>
<span class="fc" id="L255">		importRewriter.removeImport(&quot;java.util.Collection&quot;);</span>
		// Add imports for JUnit 5 parameterized tests
<span class="fc" id="L257">		importRewriter.addImport(&quot;java.util.stream.Stream&quot;);</span>
<span class="fc" id="L258">		importRewriter.addImport(ORG_JUNIT_JUPITER_PARAMS_PROVIDER_ARGUMENTS);</span>
<span class="fc" id="L259">		importRewriter.addImport(ORG_JUNIT_JUPITER_PARAMS_PROVIDER_METHOD_SOURCE);</span>
<span class="fc" id="L260">		importRewriter.addImport(ORG_JUNIT_JUPITER_PARAMS_PARAMETERIZED_TEST);</span>
<span class="fc" id="L261">	}</span>
	
	/**
	 * Create a new transformed @Parameters method that returns Stream&lt;Arguments&gt;.
	 * This creates a completely new MethodDeclaration instead of modifying the existing one,
	 * avoiding AST rewrite conflicts when the method needs to be moved.
	 * 
	 * @param originalMethod The original @Parameters method from JUnit 4
	 * @param ast The AST for creating new nodes
	 * @param rewriter The AST rewriter (used for copying expressions from original method)
	 * @param importRewriter The import rewriter
	 * @return A new MethodDeclaration with JUnit 5 signature and body
	 */
	private MethodDeclaration createTransformedParametersMethod(MethodDeclaration originalMethod, 
			AST ast, ASTRewrite rewriter, ImportRewrite importRewriter) {
		
		// Create new method declaration
<span class="fc" id="L278">		MethodDeclaration newMethod = ast.newMethodDeclaration();</span>
		
		// Set method name (same as original)
<span class="fc" id="L281">		newMethod.setName(ast.newSimpleName(originalMethod.getName().getIdentifier()));</span>
		
		// Add 'static' modifier (remove public, keep static)
<span class="fc bfc" id="L284" title="All 2 branches covered.">		for (Object modifier : originalMethod.modifiers()) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">			if (modifier instanceof Modifier) {</span>
<span class="fc" id="L286">				Modifier mod = (Modifier) modifier;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">				if (mod.isStatic()) {</span>
<span class="fc" id="L288">					newMethod.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));</span>
				}
			}
		}
		
		// Set return type to Stream&lt;Arguments&gt;
<span class="fc" id="L294">		Type streamType = ast.newSimpleType(ast.newSimpleName(&quot;Stream&quot;));</span>
<span class="fc" id="L295">		Type argumentsType = ast.newSimpleType(ast.newSimpleName(&quot;Arguments&quot;));</span>
<span class="fc" id="L296">		Type newReturnType = ast.newParameterizedType(streamType);</span>
<span class="fc" id="L297">		((org.eclipse.jdt.core.dom.ParameterizedType) newReturnType).typeArguments().add(argumentsType);</span>
<span class="fc" id="L298">		newMethod.setReturnType2(newReturnType);</span>
		
		// Transform method body: Arrays.asList(new Object[][]...) -&gt; Stream.of(Arguments.of(...), ...)
<span class="pc bpc" id="L301" title="2 of 4 branches missed.">		if (originalMethod.getBody() != null &amp;&amp; !originalMethod.getBody().statements().isEmpty()) {</span>
<span class="fc" id="L302">			Statement returnStmt = (Statement) originalMethod.getBody().statements().get(0);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">			if (returnStmt instanceof org.eclipse.jdt.core.dom.ReturnStatement) {</span>
<span class="fc" id="L304">				org.eclipse.jdt.core.dom.ReturnStatement retStmt = (org.eclipse.jdt.core.dom.ReturnStatement) returnStmt;</span>
<span class="fc" id="L305">				Expression returnExpr = retStmt.getExpression();</span>
				
				// Try to extract the array data
<span class="fc" id="L308">				List&lt;Expression&gt; dataRows = extractDataRows(returnExpr);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">				if (!dataRows.isEmpty()) {</span>
					// Create Stream.of(Arguments.of(...), Arguments.of(...), ...)
<span class="fc" id="L311">					MethodInvocation streamOf = ast.newMethodInvocation();</span>
<span class="fc" id="L312">					streamOf.setExpression(ast.newSimpleName(&quot;Stream&quot;));</span>
<span class="fc" id="L313">					streamOf.setName(ast.newSimpleName(&quot;of&quot;));</span>
					
<span class="fc bfc" id="L315" title="All 2 branches covered.">					for (Expression row : dataRows) {</span>
						// Create Arguments.of(...) for each row using short name
<span class="fc" id="L317">						MethodInvocation argumentsOf = ast.newMethodInvocation();</span>
<span class="fc" id="L318">						argumentsOf.setExpression(ast.newSimpleName(&quot;Arguments&quot;));</span>
<span class="fc" id="L319">						argumentsOf.setName(ast.newSimpleName(&quot;of&quot;));</span>
						
						// Extract values from the row
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">						if (row instanceof ArrayInitializer) {</span>
<span class="fc" id="L323">							ArrayInitializer arrayInit = (ArrayInitializer) row;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">							for (Object expr : arrayInit.expressions()) {</span>
								// Copy expression from original method to new method
<span class="fc" id="L326">								argumentsOf.arguments().add(ASTNode.copySubtree(ast, (Expression) expr));</span>
							}
<span class="pc bnc" id="L328" title="All 2 branches missed.">						} else if (row instanceof ArrayCreation) {</span>
<span class="nc" id="L329">							org.eclipse.jdt.core.dom.ArrayCreation arrayCreate = (org.eclipse.jdt.core.dom.ArrayCreation) row;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">							if (arrayCreate.getInitializer() != null) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">								for (Object expr : arrayCreate.getInitializer().expressions()) {</span>
									// Copy expression from original method to new method
<span class="nc" id="L333">									argumentsOf.arguments().add(ASTNode.copySubtree(ast, (Expression) expr));</span>
								}
							}
						}
						
<span class="fc" id="L338">						streamOf.arguments().add(argumentsOf);</span>
					}
					
					// Create new return statement
<span class="fc" id="L342">					org.eclipse.jdt.core.dom.ReturnStatement newReturnStmt = ast.newReturnStatement();</span>
<span class="fc" id="L343">					newReturnStmt.setExpression(streamOf);</span>
					
					// Create new method body with the return statement
<span class="fc" id="L346">					org.eclipse.jdt.core.dom.Block newBody = ast.newBlock();</span>
<span class="fc" id="L347">					newBody.statements().add(newReturnStmt);</span>
<span class="fc" id="L348">					newMethod.setBody(newBody);</span>
				}
			}
		}
		
		// If we couldn't transform the body, just copy the original body
<span class="pc bpc" id="L354" title="3 of 4 branches missed.">		if (newMethod.getBody() == null &amp;&amp; originalMethod.getBody() != null) {</span>
<span class="nc" id="L355">			newMethod.setBody((org.eclipse.jdt.core.dom.Block) ASTNode.copySubtree(ast, originalMethod.getBody()));</span>
		}
		
<span class="fc" id="L358">		return newMethod;</span>
	}
	
	/**
	 * Extract data rows from Arrays.asList(new Object[][]{{...}, {...}})
	 * 
	 * Note: Currently only handles the specific pattern Arrays.asList(new Object[][] {...}).
	 * Other JUnit 4 Parameterized data formats are not yet supported:
	 * - Directly returning Object[][]
	 * - Collection.singletonList()
	 * - Other Collection implementations
	 * 
	 * @param expr The expression from @Parameters method return statement
	 * @return List of array expressions representing test data rows
	 */
	private List&lt;Expression&gt; extractDataRows(Expression expr) {
<span class="fc" id="L374">		List&lt;Expression&gt; rows = new ArrayList&lt;&gt;();</span>
		
		// Handle Arrays.asList(new Object[][] {...})
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">		if (expr instanceof MethodInvocation) {</span>
<span class="fc" id="L378">			MethodInvocation methodInv = (MethodInvocation) expr;</span>
<span class="pc bpc" id="L379" title="2 of 4 branches missed.">			if (&quot;asList&quot;.equals(methodInv.getName().getIdentifier()) &amp;&amp; !methodInv.arguments().isEmpty()) {</span>
<span class="fc" id="L380">				Expression arg = (Expression) methodInv.arguments().get(0);</span>
				
				// Check for new Object[][] {...}
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">				if (arg instanceof org.eclipse.jdt.core.dom.ArrayCreation) {</span>
<span class="fc" id="L384">					org.eclipse.jdt.core.dom.ArrayCreation arrayCreate = (org.eclipse.jdt.core.dom.ArrayCreation) arg;</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">					if (arrayCreate.getInitializer() != null) {</span>
<span class="fc" id="L386">						rows.addAll(arrayCreate.getInitializer().expressions());</span>
					}
				}
			}
		}
		
<span class="fc" id="L392">		return rows;</span>
	}
	
	/**
	 * Check if a method is a @Test method
	 */
	private boolean isTestMethod(MethodDeclaration method) {
<span class="fc bfc" id="L399" title="All 2 branches covered.">		for (Object modifier : method.modifiers()) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">			if (modifier instanceof Annotation) {</span>
<span class="fc" id="L401">				Annotation annot = (Annotation) modifier;</span>
<span class="fc" id="L402">				String annotName = annot.getTypeName().getFullyQualifiedName();</span>
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">				if (&quot;Test&quot;.equals(annotName) || ORG_JUNIT_TEST.equals(annotName)) {</span>
<span class="fc" id="L404">					return true;</span>
				}
			}
		}
<span class="fc" id="L408">		return false;</span>
	}
	
	/**
	 * Transform @Test method to @ParameterizedTest with @MethodSource
	 */
	private void transformTestMethod(MethodDeclaration method, List&lt;SingleVariableDeclaration&gt; constructorParams,
			String parametersMethodName, ASTRewrite rewriter, AST ast, TextEditGroup group, ImportRewrite importRewriter) {
		
		// Replace @Test with @ParameterizedTest
<span class="fc" id="L418">		ListRewrite modifiersRewrite = rewriter.getListRewrite(method, MethodDeclaration.MODIFIERS2_PROPERTY);</span>
<span class="fc" id="L419">		Annotation testAnnotation = null;</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">		for (Object modifier : method.modifiers()) {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">			if (modifier instanceof Annotation) {</span>
<span class="fc" id="L422">				Annotation annot = (Annotation) modifier;</span>
<span class="fc" id="L423">				String annotName = annot.getTypeName().getFullyQualifiedName();</span>
<span class="pc bpc" id="L424" title="3 of 4 branches missed.">				if (&quot;Test&quot;.equals(annotName) || ORG_JUNIT_TEST.equals(annotName)) {</span>
<span class="fc" id="L425">					testAnnotation = annot;</span>
<span class="fc" id="L426">					break;</span>
				}
			}
		}
		
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">		if (testAnnotation != null) {</span>
			// Create @ParameterizedTest
<span class="fc" id="L433">			MarkerAnnotation parameterizedTest= AnnotationUtils.createMarkerAnnotation(ast, ANNOTATION_PARAMETERIZED_TEST);</span>
			
			// Create @MethodSource(&quot;methodName&quot;)
<span class="fc" id="L436">			SingleMemberAnnotation methodSource = ast.newSingleMemberAnnotation();</span>
<span class="fc" id="L437">			methodSource.setTypeName(ast.newSimpleName(ANNOTATION_METHOD_SOURCE));</span>
<span class="fc" id="L438">			org.eclipse.jdt.core.dom.StringLiteral stringLiteral = ast.newStringLiteral();</span>
<span class="fc" id="L439">			stringLiteral.setLiteralValue(parametersMethodName);</span>
<span class="fc" id="L440">			methodSource.setValue(stringLiteral);</span>
			
			// Replace @Test with @ParameterizedTest and add @MethodSource
<span class="fc" id="L443">			modifiersRewrite.replace(testAnnotation, parameterizedTest, group);</span>
<span class="fc" id="L444">			modifiersRewrite.insertAfter(methodSource, parameterizedTest, group);</span>
		}
		
		// Add parameters to method
<span class="fc" id="L448">		ListRewrite paramsRewrite = rewriter.getListRewrite(method, MethodDeclaration.PARAMETERS_PROPERTY);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">		for (SingleVariableDeclaration param : constructorParams) {</span>
<span class="fc" id="L450">			SingleVariableDeclaration newParam = ast.newSingleVariableDeclaration();</span>
<span class="fc" id="L451">			newParam.setType((Type) rewriter.createCopyTarget(param.getType()));</span>
<span class="fc" id="L452">			newParam.setName((SimpleName) rewriter.createCopyTarget(param.getName()));</span>
<span class="fc" id="L453">			paramsRewrite.insertLast(newParam, group);</span>
		}
		
		// Update imports
<span class="fc" id="L457">		importRewriter.removeImport(ORG_JUNIT_TEST);</span>
<span class="fc" id="L458">	}</span>

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">		if (afterRefactoring) {</span>
<span class="nc" id="L463">			return &quot;&quot;&quot;</span>
					@ParameterizedTest
					@MethodSource(&quot;data&quot;)
					void testMultiply(int input, int expected) {
						assertEquals(expected, input * 2);
					}
					
					static Stream&lt;Arguments&gt; data() {
						return Stream.of(
							Arguments.of(1, 2),
							Arguments.of(2, 4),
							Arguments.of(3, 6)
						);
					}
					&quot;&quot;&quot;; //$NON-NLS-1$
		}
<span class="nc" id="L479">		return &quot;&quot;&quot;</span>
				@RunWith(Parameterized.class)
				public class MyParameterizedTest {
					private int input;
					private int expected;
					
					public MyParameterizedTest(int input, int expected) {
						this.input = input;
						this.expected = expected;
					}
					
					@Parameters
					public static Collection&lt;Object[]&gt; data() {
						return Arrays.asList(new Object[][] {
							{1, 2}, {2, 4}, {3, 6}
						});
					}
					
					@Test
					public void testMultiply() {
						assertEquals(expected, input * 2);
					}
				}
				&quot;&quot;&quot;; //$NON-NLS-1$
	}

	@Override
	public String toString() {
<span class="fc" id="L507">		return &quot;ParameterizedTest&quot;; //$NON-NLS-1$</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>