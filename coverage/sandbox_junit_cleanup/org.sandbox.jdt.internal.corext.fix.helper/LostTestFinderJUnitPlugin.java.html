<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LostTestFinderJUnitPlugin.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_junit_cleanup</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">LostTestFinderJUnitPlugin.java</span></div><h1>LostTestFinderJUnitPlugin.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import static org.sandbox.jdt.internal.corext.fix.helper.lib.JUnitConstants.ANNOTATION_TEST;
import static org.sandbox.jdt.internal.corext.fix.helper.lib.JUnitConstants.ORG_JUNIT_JUPITER_TEST;
import static org.sandbox.jdt.internal.corext.fix.helper.lib.JUnitConstants.ORG_JUNIT_TEST;

import java.util.List;
import java.util.Set;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.Annotation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperationWithSourceRange;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.corext.util.AnnotationUtils;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.JUnitCleanUpFixCore;
import org.sandbox.jdt.internal.corext.fix.helper.lib.AbstractTool;
import org.sandbox.jdt.internal.corext.fix.helper.lib.JunitHolder;

/**
 * Plugin to detect and fix &quot;lost&quot; JUnit 3 tests that were not properly migrated.
 * A method is considered a lost test when:
 * - The class (or its superclasses) contains @Test annotated methods
 * - Method name starts with &quot;test&quot;
 * - No @Test annotation present
 * - Public void signature with no parameters
 * - Not annotated with lifecycle annotations
 */
<span class="fc" id="L55">public class LostTestFinderJUnitPlugin extends AbstractTool&lt;ReferenceHolder&lt;Integer, JunitHolder&gt;&gt; {</span>

<span class="fc" id="L57">	private static final Set&lt;String&gt; LIFECYCLE_ANNOTATIONS = Set.of(</span>
<span class="fc" id="L58">			&quot;Before&quot;, &quot;After&quot;, &quot;BeforeClass&quot;, &quot;AfterClass&quot;,  // JUnit 4</span>
<span class="fc" id="L59">			&quot;BeforeEach&quot;, &quot;AfterEach&quot;, &quot;BeforeAll&quot;, &quot;AfterAll&quot;,  // JUnit 5</span>
<span class="fc" id="L60">			&quot;Ignore&quot;, &quot;Disabled&quot;  // Skip annotations</span>
<span class="fc" id="L61">	);</span>

	@Override
	public void find(JUnitCleanUpFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {
		
		// Visit all type declarations to find classes that have @Test methods
<span class="fc" id="L68">		compilationUnit.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(TypeDeclaration node) {
				// Check if this class has any @Test methods (including inherited)
<span class="fc bfc" id="L72" title="All 2 branches covered.">				if (classHasTestMethods(node)) {</span>
					// Find lost test methods in this class
<span class="fc" id="L74">					findLostTestMethods(fixcore, node, operations, nodesprocessed);</span>
				}
<span class="fc" id="L76">				return true;</span>
			}
		});
<span class="fc" id="L79">	}</span>

	/**
	 * Checks if the class or any of its superclasses contains @Test annotated methods
	 */
	private boolean classHasTestMethods(TypeDeclaration typeDecl) {
		// Check current class methods
<span class="fc bfc" id="L86" title="All 2 branches covered.">		for (MethodDeclaration method : typeDecl.getMethods()) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">			if (hasTestAnnotation(method)) {</span>
<span class="fc" id="L88">				return true;</span>
			}
		}
		
		// Check superclass hierarchy using ITypeBinding
<span class="fc" id="L93">		ITypeBinding binding = typeDecl.resolveBinding();</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">		if (binding != null) {</span>
<span class="fc" id="L95">			ITypeBinding superclass = binding.getSuperclass();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">			while (superclass != null) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">				for (IMethodBinding method : superclass.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">					if (hasTestAnnotationOnBinding(method)) {</span>
<span class="fc" id="L99">						return true;</span>
					}
				}
<span class="fc" id="L102">				superclass = superclass.getSuperclass();</span>
			}
		}
		
<span class="fc" id="L106">		return false;</span>
	}

	/**
	 * Checks if a method has a @Test annotation
	 */
	private boolean hasTestAnnotation(MethodDeclaration method) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">		for (Object modifier : method.modifiers()) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">			if (modifier instanceof Annotation) {</span>
<span class="fc" id="L115">				Annotation ann = (Annotation) modifier;</span>
<span class="fc" id="L116">				String name = ann.getTypeName().getFullyQualifiedName();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">				if (name.equals(&quot;Test&quot;) || </span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">					name.equals(&quot;org.junit.Test&quot;) || </span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">					name.equals(&quot;org.junit.jupiter.api.Test&quot;)) {</span>
<span class="fc" id="L120">					return true;</span>
				}
			}
		}
<span class="fc" id="L124">		return false;</span>
	}

	/**
	 * Checks if a method binding has a @Test annotation
	 */
	private boolean hasTestAnnotationOnBinding(IMethodBinding methodBinding) {
<span class="fc bfc" id="L131" title="All 2 branches covered.">		for (org.eclipse.jdt.core.dom.IAnnotationBinding annotation : methodBinding.getAnnotations()) {</span>
<span class="fc" id="L132">			String annotationName = annotation.getAnnotationType().getQualifiedName();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">			if (annotationName.equals(&quot;org.junit.Test&quot;) || </span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">				annotationName.equals(&quot;org.junit.jupiter.api.Test&quot;)) {</span>
<span class="fc" id="L135">				return true;</span>
			}
		}
<span class="fc" id="L138">		return false;</span>
	}

	/**
	 * Find methods that look like lost tests in the given type
	 */
	private void findLostTestMethods(JUnitCleanUpFixCore fixcore, TypeDeclaration typeDecl,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {
		
<span class="fc bfc" id="L147" title="All 2 branches covered.">		for (MethodDeclaration method : typeDecl.getMethods()) {</span>
<span class="pc bpc" id="L148" title="1 of 4 branches missed.">			if (isLostTestMethod(method) &amp;&amp; !nodesprocessed.contains(method)) {</span>
<span class="fc" id="L149">				nodesprocessed.add(method);</span>
				
<span class="fc" id="L151">				ReferenceHolder&lt;Integer, JunitHolder&gt; dataHolder = ReferenceHolder.createIndexed();</span>
<span class="fc" id="L152">				JunitHolder mh = new JunitHolder();</span>
<span class="fc" id="L153">				mh.setMinv(method);</span>
<span class="fc" id="L154">				dataHolder.put(0, mh);</span>
<span class="fc" id="L155">				operations.add(fixcore.rewrite(dataHolder));</span>
			}
		}
<span class="fc" id="L158">	}</span>

	/**
	 * Determines if a method is a lost test method
	 */
	private boolean isLostTestMethod(MethodDeclaration method) {
		// Must start with &quot;test&quot;
<span class="fc" id="L165">		String methodName = method.getName().getIdentifier();</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">		if (!methodName.startsWith(&quot;test&quot;)) {</span>
<span class="fc" id="L167">			return false;</span>
		}
		
		// Must not already have @Test annotation
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (hasTestAnnotation(method)) {</span>
<span class="fc" id="L172">			return false;</span>
		}
		
		// Must be public void with no parameters
<span class="fc bfc" id="L176" title="All 2 branches covered.">		if (!Modifier.isPublic(method.getModifiers())) {</span>
<span class="fc" id="L177">			return false;</span>
		}
		
		// Check for void return type using bindings when available, with a safe AST fallback
<span class="fc" id="L181">		org.eclipse.jdt.core.dom.ITypeBinding returnBinding = null;</span>
<span class="fc" id="L182">		org.eclipse.jdt.core.dom.IMethodBinding methodBinding = method.resolveBinding();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (methodBinding != null) {</span>
<span class="fc" id="L184">			returnBinding = methodBinding.getReturnType();</span>
		}

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">		if (returnBinding != null) {</span>
			// Binding-based check: require primitive void
<span class="fc bfc" id="L189" title="All 4 branches covered.">			if (!returnBinding.isPrimitive() || !&quot;void&quot;.equals(returnBinding.getName())) {</span>
<span class="fc" id="L190">				return false;</span>
			}
		} else {
			// Fallback: inspect the AST return type node defensively
<span class="nc" id="L194">			org.eclipse.jdt.core.dom.Type astReturnType = method.getReturnType2();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if (astReturnType == null) {</span>
<span class="nc" id="L196">				return false;</span>
			}
<span class="nc bnc" id="L198" title="All 2 branches missed.">			if (astReturnType.isPrimitiveType()) {</span>
<span class="nc" id="L199">				org.eclipse.jdt.core.dom.PrimitiveType primitiveType = (org.eclipse.jdt.core.dom.PrimitiveType) astReturnType;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">				if (primitiveType.getPrimitiveTypeCode() != org.eclipse.jdt.core.dom.PrimitiveType.VOID) {</span>
<span class="nc" id="L201">					return false;</span>
				}
			} else {
				// Only PrimitiveType with VOID is valid - any other return type is not a lost test
<span class="nc" id="L205">				return false;</span>
			}
		}
		
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (!method.parameters().isEmpty()) {</span>
<span class="fc" id="L210">			return false;</span>
		}
		
		// Must not have lifecycle annotations
<span class="fc bfc" id="L214" title="All 2 branches covered.">		if (hasLifecycleAnnotation(method)) {</span>
<span class="fc" id="L215">			return false;</span>
		}
		
<span class="fc" id="L218">		return true;</span>
	}

	/**
	 * Checks if a method has a lifecycle annotation that would prevent it from being a test
	 */
	private boolean hasLifecycleAnnotation(MethodDeclaration method) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">		for (Object modifier : method.modifiers()) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">			if (modifier instanceof Annotation) {</span>
<span class="fc" id="L227">				Annotation ann = (Annotation) modifier;</span>
<span class="fc" id="L228">				String name = ann.getTypeName().getFullyQualifiedName();</span>
<span class="fc" id="L229">				int lastDot = name.lastIndexOf('.');</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">				String simpleName = lastDot == -1 ? name : name.substring(lastDot + 1);</span>
				// Check simple name and fully qualified JUnit names
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">				if (LIFECYCLE_ANNOTATIONS.contains(name)</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">						|| ((name.startsWith(&quot;org.junit.&quot;) || name.startsWith(&quot;org.junit.jupiter.api.&quot;))</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">								&amp;&amp; LIFECYCLE_ANNOTATIONS.contains(simpleName))) {</span>
<span class="fc" id="L235">					return true;</span>
				}
			}
		}
<span class="fc" id="L239">		return false;</span>
	}

	/**
	 * Determines which @Test annotation to add based on imports in the compilation unit
	 */
	private boolean shouldUseJUnit5(CompilationUnit compilationUnit) {
<span class="fc" id="L246">		final boolean[] hasJUnit5Import = {false};</span>
<span class="fc" id="L247">		final boolean[] hasJUnit4Import = {false};</span>
		
		// Check imports
<span class="fc" id="L250">		List&lt;?&gt; imports = compilationUnit.imports();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">		for (Object obj : imports) {</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">			if (obj instanceof ImportDeclaration) {</span>
<span class="fc" id="L253">				ImportDeclaration imp = (ImportDeclaration) obj;</span>
<span class="fc" id="L254">				String importName = imp.getName().getFullyQualifiedName();</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">				if (importName.startsWith(&quot;org.junit.jupiter.api&quot;)) {</span>
<span class="fc" id="L256">					hasJUnit5Import[0] = true;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">				} else if (importName.equals(&quot;org.junit.Test&quot;)</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">						|| (importName.equals(&quot;org.junit&quot;) &amp;&amp; imp.isOnDemand())) {</span>
<span class="fc" id="L259">					hasJUnit4Import[0] = true;</span>
				}
			}
		}
		
		// Prefer JUnit 5 if both are imported or neither
<span class="fc bfc" id="L265" title="All 4 branches covered.">		return hasJUnit5Import[0] || !hasJUnit4Import[0];</span>
	}

	@Override
	protected void process2Rewrite(TextEditGroup group, ASTRewrite rewriter, AST ast, ImportRewrite importRewriter,
			JunitHolder junitHolder) {
<span class="fc" id="L271">		MethodDeclaration method = (MethodDeclaration) junitHolder.getMinv();</span>
<span class="fc" id="L272">		CompilationUnit cu = (CompilationUnit) method.getRoot();</span>
		
		// Determine which @Test to use
<span class="fc" id="L275">		boolean useJUnit5 = shouldUseJUnit5(cu);</span>
		
		// Add @Test annotation
<span class="fc" id="L278">		ListRewrite modifiers = rewriter.getListRewrite(method, MethodDeclaration.MODIFIERS2_PROPERTY);</span>
<span class="fc" id="L279">		MarkerAnnotation testAnnotation= AnnotationUtils.createMarkerAnnotation(ast, ANNOTATION_TEST);</span>
<span class="fc" id="L280">		modifiers.insertFirst(testAnnotation, group);</span>
		
		// Add import
<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (useJUnit5) {</span>
<span class="fc" id="L284">			importRewriter.addImport(ORG_JUNIT_JUPITER_TEST);</span>
<span class="fc" id="L285">		} else {</span>
<span class="fc" id="L286">			importRewriter.addImport(ORG_JUNIT_TEST);</span>
		}
<span class="fc" id="L288">	}</span>

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">		if (afterRefactoring) {</span>
<span class="nc" id="L293">			return &quot;&quot;&quot;</span>
					@Test
					public void testEdgeCase() {
						assertEquals(0, calc.divide(0, 1));
					}
					&quot;&quot;&quot;; //$NON-NLS-1$
		}
<span class="nc" id="L300">		return &quot;&quot;&quot;</span>
				public void testEdgeCase() {
					assertEquals(0, calc.divide(0, 1));
				}
				&quot;&quot;&quot;; //$NON-NLS-1$
	}

	@Override
	public String toString() {
<span class="fc" id="L309">		return &quot;LostTests&quot;; //$NON-NLS-1$</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>