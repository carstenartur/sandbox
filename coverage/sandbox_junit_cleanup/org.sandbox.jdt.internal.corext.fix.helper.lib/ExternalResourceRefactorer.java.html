<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExternalResourceRefactorer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_junit_cleanup</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper.lib</a> &gt; <span class="el_source">ExternalResourceRefactorer.java</span></div><h1>ExternalResourceRefactorer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper.lib;

import static org.sandbox.jdt.internal.corext.fix.helper.lib.JUnitConstants.*;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Annotation;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.BodyDeclaration;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.corext.util.AnnotationUtils;
import org.sandbox.jdt.internal.corext.util.ASTNavigationUtils;
import org.sandbox.jdt.internal.corext.util.NamingUtils;

/**
 * Helper class for refactoring JUnit 4 ExternalResource to JUnit 5 lifecycle callbacks.
 * Handles transformation of ExternalResource classes and anonymous instances.
 */
public final class ExternalResourceRefactorer {

	// Private constructor to prevent instantiation
<span class="nc" id="L50">	private ExternalResourceRefactorer() {</span>
<span class="nc" id="L51">		throw new UnsupportedOperationException(&quot;Utility class&quot;);</span>
	}

	/**
	 * Finds the type definition (TypeDeclaration or AnonymousClassDeclaration) for a field.
	 * Checks the field's initializer and type binding to locate the definition.
	 * 
	 * @param fieldDeclaration the field declaration to analyze
	 * @param cu the compilation unit containing the field
	 * @return the type definition node, or null if not found
	 */
	public static ASTNode getTypeDefinitionForField(FieldDeclaration fieldDeclaration, org.eclipse.jdt.core.dom.CompilationUnit cu) {
<span class="fc" id="L63">		return (ASTNode) fieldDeclaration.fragments().stream()</span>
<span class="fc" id="L64">				.filter(VariableDeclarationFragment.class::isInstance)</span>
<span class="fc" id="L65">				.map(VariableDeclarationFragment.class::cast)</span>
<span class="fc" id="L66">				.map(fragment -&gt; getTypeDefinitionFromFragment((VariableDeclarationFragment) fragment, cu))</span>
<span class="fc" id="L67">				.filter(java.util.Objects::nonNull)</span>
<span class="fc" id="L68">				.findFirst()</span>
<span class="fc" id="L69">				.orElse(null);</span>
	}

	/**
	 * Helper method to extract type definition from a variable declaration fragment.
	 * 
	 * @param fragment the variable declaration fragment to analyze
	 * @param cu the compilation unit containing the fragment
	 * @return the type definition node, or null if not found
	 */
	private static ASTNode getTypeDefinitionFromFragment(VariableDeclarationFragment fragment, org.eclipse.jdt.core.dom.CompilationUnit cu) {
		// Check initializer
<span class="fc" id="L81">		org.eclipse.jdt.core.dom.Expression initializer = fragment.getInitializer();</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">		if (initializer instanceof org.eclipse.jdt.core.dom.ClassInstanceCreation) {</span>
<span class="fc" id="L83">			org.eclipse.jdt.core.dom.ClassInstanceCreation classInstanceCreation = (org.eclipse.jdt.core.dom.ClassInstanceCreation) initializer;</span>

			// Check for anonymous class
<span class="fc" id="L86">			AnonymousClassDeclaration anonymousClass = classInstanceCreation.getAnonymousClassDeclaration();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">			if (anonymousClass != null) {</span>
<span class="fc" id="L88">				return anonymousClass;</span>
			}

			// Check type binding
<span class="fc" id="L92">			ITypeBinding typeBinding = classInstanceCreation.resolveTypeBinding();</span>
<span class="fc" id="L93">			return ASTNavigationUtils.findTypeDeclarationForBinding(typeBinding, cu);</span>
		}

		// Check field type if no initialization is present
<span class="nc" id="L97">		org.eclipse.jdt.core.dom.IVariableBinding fieldBinding = fragment.resolveBinding();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		if (fieldBinding != null) {</span>
<span class="nc" id="L99">			ITypeBinding fieldTypeBinding = fieldBinding.getType();</span>
<span class="nc" id="L100">			return ASTNavigationUtils.findTypeDeclarationForBinding(fieldTypeBinding, cu);</span>
		}

<span class="nc" id="L103">		return null;</span>
	}

	/**
	 * Checks if a class has either a default constructor or no constructors at all.
	 * Used to determine if ExternalResource subclasses can be easily migrated.
	 * 
	 * @param classNode the class to check
	 * @return true if the class has a default constructor or no constructors
	 */
	public static boolean hasDefaultConstructorOrNoConstructor(TypeDeclaration classNode) {
<span class="nc" id="L114">		boolean hasConstructor = false;</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">		for (Object bodyDecl : classNode.bodyDeclarations()) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if (bodyDecl instanceof org.eclipse.jdt.core.dom.MethodDeclaration) {</span>
<span class="nc" id="L118">				org.eclipse.jdt.core.dom.MethodDeclaration method = (org.eclipse.jdt.core.dom.MethodDeclaration) bodyDecl;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				if (method.isConstructor()) {</span>
<span class="nc" id="L120">					hasConstructor = true;</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">					if (method.parameters().isEmpty() &amp;&amp; method.getBody() != null</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">							&amp;&amp; method.getBody().statements().isEmpty()) {</span>
<span class="nc" id="L123">						return true;</span>
					}
				}
			}
		}
<span class="nc bnc" id="L128" title="All 2 branches missed.">		return !hasConstructor;</span>
	}

	/**
	 * Checks if a variable declaration fragment represents an anonymous class.
	 * 
	 * @param fragment the variable declaration fragment to check
	 * @return true if the fragment's initializer is an anonymous class
	 */
	public static boolean isAnonymousClass(VariableDeclarationFragment fragment) {
<span class="nc" id="L138">		org.eclipse.jdt.core.dom.Expression initializer = fragment.getInitializer();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">		return initializer instanceof org.eclipse.jdt.core.dom.ClassInstanceCreation</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">				&amp;&amp; ((org.eclipse.jdt.core.dom.ClassInstanceCreation) initializer).getAnonymousClassDeclaration() != null;</span>
	}

	/**
	 * Checks if the given type binding directly extends ExternalResource.
	 * 
	 * @param binding the type binding to check
	 * @return true if the type's superclass is ExternalResource
	 */
	public static boolean isDirectlyExtendingExternalResource(ITypeBinding binding) {
<span class="fc" id="L150">		ITypeBinding superclass = binding.getSuperclass();</span>
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">		return superclass != null &amp;&amp; ORG_JUNIT_RULES_EXTERNAL_RESOURCE.equals(superclass.getQualifiedName());</span>
	}

	/**
	 * Modifies a class that extends ExternalResource to use JUnit 5 extensions instead.
	 * 
	 * @param node the type declaration to modify
	 * @param field the field declaration with ExternalResource
	 * @param fieldStatic whether the field is static (affects callback type)
	 * @param rewriter the AST rewriter
	 * @param ast the AST instance
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 */
	public static void modifyExternalResourceClass(TypeDeclaration node, FieldDeclaration field, boolean fieldStatic,
			ASTRewrite rewriter, AST ast, TextEditGroup group, ImportRewrite importRewriter) {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">		if (!shouldProcessNode(node)) {</span>
<span class="nc" id="L168">			return;</span>
		}

<span class="fc" id="L171">		CallbackConfig callbackConfig = determineCallbackConfig(fieldStatic);</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (field != null) {</span>
<span class="fc" id="L174">			processExternalResourceField(field, rewriter, ast, group, importRewriter);</span>
		}

<span class="fc bfc" id="L177" title="All 2 branches covered.">		if (isDirectlyExtendingExternalResource(node.resolveBinding())) {</span>
<span class="fc" id="L178">			refactorToImplementCallbacks(node, rewriter, ast, group, importRewriter, callbackConfig.beforeCallback,</span>
<span class="fc" id="L179">					callbackConfig.afterCallback, callbackConfig.importBeforeCallback,</span>
<span class="fc" id="L180">					callbackConfig.importAfterCallback);</span>
		}

<span class="fc" id="L183">		LifecycleMethodAdapter.updateLifecycleMethodsInClass(node, rewriter, ast, group, importRewriter, METHOD_BEFORE,</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">				METHOD_AFTER, fieldStatic ? METHOD_BEFORE_ALL : METHOD_BEFORE_EACH,</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">				fieldStatic ? METHOD_AFTER_ALL : METHOD_AFTER_EACH);</span>
<span class="fc" id="L186">	}</span>

	/**
	 * Processes an ExternalResource field by removing JUnit 4 annotations and adding JUnit 5 equivalents.
	 * 
	 * @param field the field to process
	 * @param rewriter the AST rewriter
	 * @param ast the AST instance
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 */
	public static void processExternalResourceField(FieldDeclaration field, ASTRewrite rewriter, AST ast,
			TextEditGroup group, ImportRewrite importRewriter) {
<span class="fc" id="L199">		String ruleAnnotation = null;</span>

<span class="fc bfc" id="L201" title="All 2 branches covered.">		if (AnnotationUtils.isAnnotatedWith(field, ORG_JUNIT_RULE)</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">				&amp;&amp; isExternalResource(field, ORG_JUNIT_RULES_EXTERNAL_RESOURCE)) {</span>
<span class="fc" id="L203">			ruleAnnotation = ORG_JUNIT_RULE;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		} else if (AnnotationUtils.isAnnotatedWith(field, ORG_JUNIT_CLASS_RULE)</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">				&amp;&amp; isExternalResource(field, ORG_JUNIT_RULES_EXTERNAL_RESOURCE)) {</span>
<span class="fc" id="L206">			ruleAnnotation = ORG_JUNIT_CLASS_RULE;</span>
		}

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (ruleAnnotation != null) {</span>
<span class="fc" id="L210">			removeRuleAnnotation(field, rewriter, group, importRewriter, ruleAnnotation);</span>
<span class="fc" id="L211">			addRegisterExtensionAnnotation(field, rewriter, ast, importRewriter, group);</span>
<span class="fc" id="L212">			ITypeBinding fieldType = ((VariableDeclarationFragment) field.fragments().get(0)).resolveBinding()</span>
<span class="fc" id="L213">					.getType();</span>
<span class="fc" id="L214">			adaptExternalResourceHierarchy(fieldType, rewriter, ast, importRewriter, group);</span>
		}
<span class="fc" id="L216">	}</span>

	/**
	 * Adapts the superclass hierarchy for types extending ExternalResource.
	 * Walks up the inheritance chain, transforming each type to use JUnit 5 extensions
	 * until reaching ExternalResource itself.
	 * 
	 * @param typeBinding the type binding to start from
	 * @param rewrite the AST rewriter
	 * @param ast the AST instance
	 * @param importRewrite the import rewriter
	 * @param group the text edit group
	 */
	public static void adaptExternalResourceHierarchy(ITypeBinding typeBinding, ASTRewrite rewrite, AST ast,
			ImportRewrite importRewrite, TextEditGroup group) {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		while (typeBinding != null) {</span>
			// Stop when we reach ExternalResource itself
<span class="fc bfc" id="L233" title="All 2 branches covered.">			if (ORG_JUNIT_RULES_EXTERNAL_RESOURCE.equals(typeBinding.getQualifiedName())) {</span>
<span class="fc" id="L234">				break;</span>
			}

			// Process types that extend ExternalResource
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">			if (isExternalResource(typeBinding, ORG_JUNIT_RULES_EXTERNAL_RESOURCE)) {</span>
<span class="fc" id="L239">				TypeDeclaration typeDecl = ASTNavigationUtils.findTypeDeclarationInProject(typeBinding);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">				if (typeDecl != null) {</span>
<span class="fc" id="L241">					adaptTypeDeclaration(typeDecl, rewrite, ast, importRewrite, group);</span>
				}
			}

<span class="fc" id="L245">			typeBinding = typeBinding.getSuperclass();</span>
		}
<span class="fc" id="L247">	}</span>

	/**
	 * Adapts a type declaration that extends ExternalResource to use JUnit 5 lifecycle callbacks.
	 * Removes the ExternalResource superclass and updates lifecycle methods (before/after).
	 * 
	 * @param typeDecl the type declaration to adapt
	 * @param globalRewrite the global AST rewriter (may be different from typeDecl's AST)
	 * @param ast the AST instance
	 * @param importRewrite the import rewriter
	 * @param group the text edit group
	 */
	public static void adaptTypeDeclaration(TypeDeclaration typeDecl, ASTRewrite globalRewrite, AST ast,
			ImportRewrite importRewrite, TextEditGroup group) {
		// Create separate rewriters if the type declaration is in a different compilation unit
<span class="fc" id="L262">		ASTRewrite rewriteToUse = getASTRewrite(typeDecl, ast, globalRewrite);</span>
<span class="fc" id="L263">		ImportRewrite importRewriteToUse = getImportRewrite(typeDecl, ast, importRewrite);</span>

		// Remove ExternalResource superclass
<span class="fc" id="L266">		removeSuperclassType(typeDecl, rewriteToUse, group);</span>

		// Update lifecycle methods: before() -&gt; beforeEach(), after() -&gt; afterEach()
<span class="fc" id="L269">		LifecycleMethodAdapter.updateLifecycleMethodsInClass(typeDecl, rewriteToUse, ast, group, importRewriteToUse,</span>
<span class="fc" id="L270">				METHOD_BEFORE, METHOD_AFTER, METHOD_BEFORE_EACH, METHOD_AFTER_EACH);</span>

		// Add required JUnit 5 callback imports
<span class="fc" id="L273">		importRewriteToUse.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_EACH_CALLBACK);</span>
<span class="fc" id="L274">		importRewriteToUse.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_EACH_CALLBACK);</span>

		// If we created a separate rewriter, commit the change
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">		if (rewriteToUse != globalRewrite) {</span>
<span class="fc" id="L278">			DocumentHelper.createChangeForRewrite(ASTNavigationUtils.findCompilationUnit(typeDecl), rewriteToUse);</span>
		}
<span class="fc" id="L280">	}</span>

	/**
	 * Refactors an anonymous ExternalResource class to implement JUnit 5 callback interfaces.
	 * Converts the anonymous class to a named nested class with before/after callback methods.
	 * 
	 * @param anonymousClass the anonymous class declaration to refactor
	 * @param fieldDeclaration the field containing the anonymous class
	 * @param fieldStatic whether the field is static
	 * @param rewriter the AST rewriter
	 * @param ast the AST instance
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 */
	public static void refactorAnonymousClassToImplementCallbacks(AnonymousClassDeclaration anonymousClass,
			FieldDeclaration fieldDeclaration, boolean fieldStatic, ASTRewrite rewriter, AST ast, TextEditGroup group,
			ImportRewrite importRewriter) {

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">		if (anonymousClass == null) {</span>
<span class="nc" id="L299">			return;</span>
		}

		// Access the surrounding ClassInstanceCreation
<span class="fc" id="L303">		ASTNode parent = anonymousClass.getParent();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if (parent instanceof ClassInstanceCreation) {</span>
<span class="fc" id="L305">			ClassInstanceCreation classInstanceCreation = (ClassInstanceCreation) parent;</span>
<span class="fc" id="L306">			ensureClassInstanceRewrite(classInstanceCreation, rewriter, importRewriter, group, fieldStatic);</span>

<span class="fc" id="L308">			String fieldName = NamingUtils.extractFieldName(fieldDeclaration);</span>
<span class="fc" id="L309">			String nestedClassName = NamingUtils.generateUniqueNestedClassName(anonymousClass, fieldName);</span>
<span class="fc" id="L310">			createNestedClassFromAnonymous(anonymousClass, nestedClassName, fieldStatic,</span>
<span class="fc" id="L311">					rewriter, ast, importRewriter, group);</span>

<span class="fc" id="L313">			replaceFieldWithExtensionDeclaration(classInstanceCreation, nestedClassName, fieldStatic, rewriter, ast,</span>
<span class="fc" id="L314">					group, importRewriter);</span>
		}
<span class="fc" id="L316">	}</span>

	/**
	 * Creates a nested class from an anonymous ExternalResource declaration.
	 * Converts anonymous class lifecycle methods (before/after) to JUnit 5 callback methods
	 * (beforeEach/afterEach) and implements the appropriate callback interfaces.
	 * 
	 * @param anonymousClass the anonymous class to convert
	 * @param className the name for the new nested class
	 * @param fieldStatic whether the field is static (affects which callbacks to implement)
	 * @param rewriter the AST rewriter
	 * @param ast the AST instance
	 * @param importRewriter the import rewriter
	 * @param group the text edit group
	 * @return the newly created nested class declaration
	 */
	public static TypeDeclaration createNestedClassFromAnonymous(AnonymousClassDeclaration anonymousClass,
			String className, boolean fieldStatic, ASTRewrite rewriter, AST ast, ImportRewrite importRewriter,
			TextEditGroup group) {

		// Create the new TypeDeclaration
<span class="fc" id="L337">		TypeDeclaration nestedClass = ast.newTypeDeclaration();</span>
<span class="fc" id="L338">		nestedClass.setName(ast.newSimpleName(className));</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">		if (fieldStatic) {</span>
<span class="nc" id="L340">			nestedClass.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));</span>
		}

		// Add JUnit 5 callback interfaces (before/after each or all depending on static)
		// Use addImport to get the appropriate name (simple or qualified based on conflicts)
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">		if (fieldStatic) {</span>
<span class="nc" id="L346">			String beforeAllName = importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_ALL_CALLBACK);</span>
<span class="nc" id="L347">			String afterAllName = importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_ALL_CALLBACK);</span>
<span class="nc" id="L348">			nestedClass.superInterfaceTypes()</span>
<span class="nc" id="L349">					.add(ast.newSimpleType(ast.newName(beforeAllName)));</span>
<span class="nc" id="L350">			nestedClass.superInterfaceTypes()</span>
<span class="nc" id="L351">					.add(ast.newSimpleType(ast.newName(afterAllName)));</span>
<span class="nc" id="L352">		} else {</span>
<span class="fc" id="L353">			String beforeEachName = importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_EACH_CALLBACK);</span>
<span class="fc" id="L354">			String afterEachName = importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_EACH_CALLBACK);</span>
<span class="fc" id="L355">			nestedClass.superInterfaceTypes()</span>
<span class="fc" id="L356">					.add(ast.newSimpleType(ast.newName(beforeEachName)));</span>
<span class="fc" id="L357">			nestedClass.superInterfaceTypes()</span>
<span class="fc" id="L358">					.add(ast.newSimpleType(ast.newName(afterEachName)));</span>
		}

		// Transfer lifecycle methods from anonymous class to new class
<span class="fc" id="L362">		ListRewrite bodyRewrite = rewriter.getListRewrite(nestedClass, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">		for (Object decl : anonymousClass.bodyDeclarations()) {</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">			if (decl instanceof MethodDeclaration) {</span>
<span class="fc" id="L365">				MethodDeclaration method = (MethodDeclaration) decl;</span>

				// Convert before() -&gt; beforeEach/beforeAll(ExtensionContext) and after() -&gt; afterEach/afterAll(ExtensionContext)
<span class="fc bfc" id="L368" title="All 2 branches covered.">				if (isLifecycleMethod(method, METHOD_BEFORE)) {</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">					String beforeMethodName = fieldStatic ? METHOD_BEFORE_ALL : METHOD_BEFORE_EACH;</span>
<span class="fc" id="L370">					MethodDeclaration beforeCallbackMethod = LifecycleMethodAdapter.createLifecycleCallbackMethod(ast,</span>
<span class="fc" id="L371">							beforeMethodName, EXTENSION_CONTEXT, method.getBody(), group);</span>
<span class="fc" id="L372">					bodyRewrite.insertLast(beforeCallbackMethod, group);</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">				} else if (isLifecycleMethod(method, METHOD_AFTER)) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">					String afterMethodName = fieldStatic ? METHOD_AFTER_ALL : METHOD_AFTER_EACH;</span>
<span class="fc" id="L375">					MethodDeclaration afterCallbackMethod = LifecycleMethodAdapter.createLifecycleCallbackMethod(ast,</span>
<span class="fc" id="L376">							afterMethodName, EXTENSION_CONTEXT, method.getBody(), group);</span>
<span class="fc" id="L377">					bodyRewrite.insertLast(afterCallbackMethod, group);</span>
				}
			}
		}

		// Add the new class to the enclosing type
<span class="fc" id="L383">		TypeDeclaration parentType = ASTNavigationUtils.findEnclosingTypeDeclaration(anonymousClass);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">		if (parentType != null) {</span>
<span class="fc" id="L385">			ListRewrite enclosingBodyRewrite = rewriter.getListRewrite(parentType,</span>
<span class="fc" id="L386">					TypeDeclaration.BODY_DECLARATIONS_PROPERTY);</span>
<span class="fc" id="L387">			enclosingBodyRewrite.insertLast(nestedClass, group);</span>
		}

<span class="fc" id="L390">		return nestedClass;</span>
	}

	/**
	 * Ensures that an anonymous ExternalResource class is properly rewritten for JUnit 5.
	 * Removes the ExternalResource superclass and adds necessary JUnit 5 callback imports.
	 * 
	 * @param classInstanceCreation the class instance creation containing the anonymous class
	 * @param rewriter the AST rewriter
	 * @param importRewriter the import rewriter
	 * @param group the text edit group
	 * @param fieldStatic true if the field is static (use BeforeAll/AfterAll), false for instance (use BeforeEach/AfterEach)
	 */
	public static void ensureClassInstanceRewrite(ClassInstanceCreation classInstanceCreation, ASTRewrite rewriter,
			ImportRewrite importRewriter, TextEditGroup group, boolean fieldStatic) {
<span class="fc" id="L405">		removeExternalResourceSuperclass(classInstanceCreation, rewriter, importRewriter, group);</span>

		// Add required JUnit 5 callback imports
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">		if (fieldStatic) {</span>
<span class="nc" id="L409">			importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_ALL_CALLBACK);</span>
<span class="nc" id="L410">			importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_ALL_CALLBACK);</span>
<span class="nc" id="L411">		} else {</span>
<span class="fc" id="L412">			importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_EACH_CALLBACK);</span>
<span class="fc" id="L413">			importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_EACH_CALLBACK);</span>
		}
<span class="fc" id="L415">		importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_EXTENSION_CONTEXT);</span>
<span class="fc" id="L416">	}</span>

	/**
	 * Removes the ExternalResource superclass from an anonymous class.
	 * 
	 * @param anonymousClass the class instance creation
	 * @param rewrite the AST rewriter
	 * @param importRewriter the import rewriter
	 * @param group the text edit group
	 */
	private static void removeExternalResourceSuperclass(ClassInstanceCreation anonymousClass, ASTRewrite rewrite,
			ImportRewrite importRewriter, TextEditGroup group) {
		// Check if the anonymous class inherits from ExternalResource
<span class="fc" id="L429">		ITypeBinding typeBinding = anonymousClass.resolveTypeBinding();</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">		if (typeBinding.getSuperclass() != null</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">				&amp;&amp; ORG_JUNIT_RULES_EXTERNAL_RESOURCE.equals(typeBinding.getSuperclass().getQualifiedName())) {</span>

			// Remove the superclass by replacing the type in the ClassInstanceCreation
<span class="fc" id="L434">			Type type = anonymousClass.getType();</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">			if (type != null) {</span>
<span class="fc" id="L436">				rewrite.replace(type, anonymousClass.getAST().newSimpleType(anonymousClass.getAST().newSimpleName(&quot;Object&quot;)),</span>
<span class="fc" id="L437">						group);</span>
			}

			// Remove the import of the superclass
<span class="fc" id="L441">			importRewriter.removeImport(ORG_JUNIT_RULES_EXTERNAL_RESOURCE);</span>
		}
<span class="fc" id="L443">	}</span>

	/**
	 * Refactors a type to implement JUnit 5 callback interfaces instead of extending ExternalResource.
	 * 
	 * @param node the type declaration
	 * @param rewriter the AST rewriter
	 * @param ast the AST instance
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 * @param beforeCallback the before callback simple name
	 * @param afterCallback the after callback simple name
	 * @param importBeforeCallback the before callback fully qualified name
	 * @param importAfterCallback the after callback fully qualified name
	 */
	private static void refactorToImplementCallbacks(TypeDeclaration node, ASTRewrite rewriter, AST ast,
			TextEditGroup group, ImportRewrite importRewriter, String beforeCallback, String afterCallback,
			String importBeforeCallback, String importAfterCallback) {

<span class="pc bpc" id="L462" title="4 of 8 branches missed.">		if (node == null || rewriter == null || ast == null || importRewriter == null) {</span>
<span class="nc" id="L463">			return;</span>
		}

<span class="fc" id="L466">		ASTRewrite rewriteToUse = getASTRewrite(node, ast, rewriter);</span>
<span class="fc" id="L467">		ImportRewrite importRewriteToUse = getImportRewrite(node, ast, importRewriter);</span>

<span class="fc" id="L469">		rewriteToUse.remove(node.getSuperclassType(), group);</span>
<span class="fc" id="L470">		importRewriteToUse.removeImport(ORG_JUNIT_RULES_EXTERNAL_RESOURCE);</span>

<span class="fc" id="L472">		ListRewrite listRewrite = rewriteToUse.getListRewrite(node, TypeDeclaration.SUPER_INTERFACE_TYPES_PROPERTY);</span>
<span class="fc" id="L473">		ImportHelper.addInterfaceCallback(listRewrite, ast, beforeCallback, group, importRewriteToUse,</span>
<span class="fc" id="L474">				importBeforeCallback);</span>
<span class="fc" id="L475">		ImportHelper.addInterfaceCallback(listRewrite, ast, afterCallback, group, importRewriteToUse,</span>
<span class="fc" id="L476">				importAfterCallback);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">		if (rewriteToUse != rewriter) {</span>
<span class="fc" id="L479">			DocumentHelper.createChangeForRewrite(ASTNavigationUtils.findCompilationUnit(node), rewriteToUse);</span>
		}
<span class="fc" id="L481">	}</span>

	/**
	 * Removes the superclass type from a type declaration.
	 * Used when converting ExternalResource subclasses to implement callback interfaces.
	 * 
	 * @param typeDecl the type declaration to modify
	 * @param rewrite the AST rewriter
	 * @param group the text edit group
	 */
	private static void removeSuperclassType(TypeDeclaration typeDecl, ASTRewrite rewrite, TextEditGroup group) {
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">		if (typeDecl.getSuperclassType() != null) {</span>
<span class="fc" id="L493">			rewrite.remove(typeDecl.getSuperclassType(), group);</span>
		}
<span class="fc" id="L495">	}</span>

	/**
	 * Adds the @RegisterExtension annotation to a field.
	 * Resolves the field declaration from the given node and delegates to addRegisterExtensionToField.
	 * 
	 * @param node the AST node (either a FieldDeclaration or a ClassInstanceCreation)
	 * @param rewrite the AST rewriter
	 * @param ast the AST instance
	 * @param importRewrite the import rewriter
	 * @param group the text edit group
	 */
	private static void addRegisterExtensionAnnotation(ASTNode node, ASTRewrite rewrite, AST ast,
			ImportRewrite importRewrite, TextEditGroup group) {
<span class="fc" id="L509">		FieldDeclaration field = resolveFieldDeclaration(node);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">		if (field != null) {</span>
<span class="fc" id="L511">			addRegisterExtensionToField(field, rewrite, ast, importRewrite, group);</span>
		}
<span class="fc" id="L513">	}</span>

	/**
	 * Resolves the {@link FieldDeclaration} from the given AST node.
	 * 
	 * @param node an AST node that is either a {@link FieldDeclaration} or a
	 *             {@link ClassInstanceCreation} within a field initializer
	 * @return the resolved {@link FieldDeclaration}, or {@code null} if not found
	 */
	private static FieldDeclaration resolveFieldDeclaration(ASTNode node) {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">		if (node instanceof FieldDeclaration) {</span>
<span class="fc" id="L524">			return (FieldDeclaration) node;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">		} else if (node instanceof ClassInstanceCreation) {</span>
<span class="nc" id="L526">			return ASTNodes.getParent(node, FieldDeclaration.class);</span>
		}
<span class="nc" id="L528">		return null;</span>
	}

	/**
	 * Adds the {@code @RegisterExtension} annotation to the given field if not already present.
	 */
	private static void addRegisterExtensionToField(FieldDeclaration field, ASTRewrite rewrite, AST ast,
			ImportRewrite importRewrite, TextEditGroup group) {
<span class="fc" id="L536">		boolean hasRegisterExtension = AnnotationUtils.hasAnnotationBySimpleName(field.modifiers(),</span>
<span class="fc" id="L537">				ANNOTATION_REGISTER_EXTENSION);</span>

<span class="fc" id="L539">		ListRewrite listRewrite = rewrite.getListRewrite(field, FieldDeclaration.MODIFIERS2_PROPERTY);</span>
<span class="fc" id="L540">		boolean hasPendingRegisterExtension = listRewrite.getRewrittenList().stream()</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">				.anyMatch(rewritten -&gt; rewritten instanceof MarkerAnnotation &amp;&amp; ((MarkerAnnotation) rewritten)</span>
<span class="pc bnc" id="L542" title="All 2 branches missed.">						.getTypeName().getFullyQualifiedName().equals(ANNOTATION_REGISTER_EXTENSION));</span>

<span class="pc bpc" id="L544" title="2 of 4 branches missed.">		if (!hasRegisterExtension &amp;&amp; !hasPendingRegisterExtension) {</span>
<span class="fc" id="L545">			MarkerAnnotation registerExtensionAnnotation = ast.newMarkerAnnotation();</span>
<span class="fc" id="L546">			registerExtensionAnnotation.setTypeName(ast.newName(ANNOTATION_REGISTER_EXTENSION));</span>
<span class="fc" id="L547">			listRewrite.insertFirst(registerExtensionAnnotation, group);</span>
<span class="fc" id="L548">			importRewrite.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_REGISTER_EXTENSION);</span>
		}
<span class="fc" id="L550">	}</span>

	/**
	 * Adds the @ExtendWith annotation to a class for JUnit 5 extension integration.
	 * Used when migrating JUnit 4 @Rule fields to JUnit 5 @RegisterExtension.
	 * 
	 * @param rewrite the AST rewriter
	 * @param ast the AST instance
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 * @param className the simple name of the extension class
	 * @param field the field that triggered the need for this annotation
	 */
	public static void addExtendWithAnnotation(ASTRewrite rewrite, AST ast, TextEditGroup group,
			ImportRewrite importRewriter, String className, FieldDeclaration field) {
<span class="nc" id="L565">		TypeDeclaration parentClass = getParentTypeDeclaration(field);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">		if (parentClass == null) {</span>
<span class="nc" id="L567">			return;</span>
		}

		// Create @ExtendWith(ClassName.class) annotation
<span class="nc" id="L571">		SingleMemberAnnotation newAnnotation = ast.newSingleMemberAnnotation();</span>
<span class="nc" id="L572">		newAnnotation.setTypeName(ast.newName(ANNOTATION_EXTEND_WITH));</span>
<span class="nc" id="L573">		TypeLiteral newTypeLiteral = ast.newTypeLiteral();</span>
<span class="nc" id="L574">		newTypeLiteral.setType(ast.newSimpleType(ast.newSimpleName(className)));</span>
<span class="nc" id="L575">		newAnnotation.setValue(newTypeLiteral);</span>

		// Add annotation to class
<span class="nc" id="L578">		ListRewrite modifierListRewrite = rewrite.getListRewrite(parentClass, TypeDeclaration.MODIFIERS2_PROPERTY);</span>
<span class="nc" id="L579">		modifierListRewrite.insertFirst(newAnnotation, group);</span>

		// Add import for @ExtendWith
<span class="nc" id="L582">		importRewriter.addImport(ORG_JUNIT_JUPITER_API_EXTENSION_EXTEND_WITH);</span>
<span class="nc" id="L583">	}</span>

	/**
	 * Removes a @Rule or @ClassRule annotation from a body declaration.
	 * Also removes the corresponding import statement.
	 * 
	 * @param declaration the body declaration to remove the annotation from
	 * @param rewriter the AST rewriter
	 * @param group the text edit group
	 * @param importRewriter the import rewriter
	 * @param annotationclass the fully qualified annotation class name to remove
	 */
	private static void removeRuleAnnotation(BodyDeclaration declaration, ASTRewrite rewriter, TextEditGroup group,
			ImportRewrite importRewriter, String annotationclass) {
<span class="fc" id="L597">		java.util.List&lt;?&gt; modifiers = declaration.modifiers();</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">		for (Object modifier : modifiers) {</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">			if (modifier instanceof Annotation) {</span>
<span class="fc" id="L600">				Annotation annotation = (Annotation) modifier;</span>
<span class="fc" id="L601">				ITypeBinding binding = annotation.resolveTypeBinding();</span>
<span class="pc bpc" id="L602" title="2 of 4 branches missed.">				if (binding != null &amp;&amp; binding.getQualifiedName().equals(annotationclass)) {</span>
<span class="fc" id="L603">					rewriter.remove(annotation, group);</span>
<span class="fc" id="L604">					importRewriter.removeImport(annotationclass);</span>
<span class="fc" id="L605">					break;</span>
				}
			}
		}
<span class="fc" id="L609">	}</span>

	private static void replaceFieldWithExtensionDeclaration(ClassInstanceCreation classInstanceCreation,
			String nestedClassName, boolean fieldStatic, ASTRewrite rewriter, AST ast, TextEditGroup group,
			ImportRewrite importRewriter) {

<span class="fc" id="L615">		FieldDeclaration fieldDecl = ASTNodes.getParent(classInstanceCreation, FieldDeclaration.class);</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">		if (fieldDecl != null) {</span>
			// Remove the @Rule annotation
<span class="fc" id="L618">			removeRuleAnnotation(fieldDecl, rewriter, group, importRewriter, ORG_JUNIT_RULE);</span>

			// Add the @RegisterExtension annotation
<span class="fc" id="L621">			addRegisterExtensionAnnotation(fieldDecl, rewriter, ast, importRewriter, group);</span>

			// Change the type of the FieldDeclaration
<span class="fc" id="L624">			Type newType = ast.newSimpleType(ast.newName(nestedClassName));</span>
<span class="fc" id="L625">			rewriter.replace(fieldDecl.getType(), newType, group);</span>

			// Add the initialization
<span class="fc bfc" id="L628" title="All 2 branches covered.">			for (Object fragment : fieldDecl.fragments()) {</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">				if (fragment instanceof VariableDeclarationFragment) {</span>
<span class="fc" id="L630">					VariableDeclarationFragment fragmentNode = (VariableDeclarationFragment) fragment;</span>
<span class="fc" id="L631">					ClassInstanceCreation newInstance = ast.newClassInstanceCreation();</span>
<span class="fc" id="L632">					newInstance.setType(ast.newSimpleType(ast.newName(nestedClassName)));</span>
<span class="fc" id="L633">					rewriter.replace(fragmentNode.getInitializer(), newInstance, group);</span>
				}
			}
		}
<span class="fc" id="L637">	}</span>

	/**
	 * Determines the appropriate callback configuration based on whether the field is static.
	 * 
	 * @param fieldStatic whether the field is static
	 * @return the callback configuration with callback names and import paths
	 */
	private static CallbackConfig determineCallbackConfig(boolean fieldStatic) {
<span class="fc bfc" id="L646" title="All 2 branches covered.">		if (fieldStatic) {</span>
<span class="fc" id="L647">			return new CallbackConfig(BEFORE_ALL_CALLBACK, AFTER_ALL_CALLBACK,</span>
<span class="fc" id="L648">					ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_ALL_CALLBACK,</span>
<span class="fc" id="L649">					ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_ALL_CALLBACK);</span>
		} else {
<span class="fc" id="L651">			return new CallbackConfig(BEFORE_EACH_CALLBACK, AFTER_EACH_CALLBACK,</span>
<span class="fc" id="L652">					ORG_JUNIT_JUPITER_API_EXTENSION_BEFORE_EACH_CALLBACK,</span>
<span class="fc" id="L653">					ORG_JUNIT_JUPITER_API_EXTENSION_AFTER_EACH_CALLBACK);</span>
		}
	}

	/**
	 * Configuration holder for callback names and import paths.
	 */
	private static class CallbackConfig {
		final String beforeCallback;
		final String afterCallback;
		final String importBeforeCallback;
		final String importAfterCallback;

<span class="fc" id="L666">		CallbackConfig(String beforeCallback, String afterCallback, String importBeforeCallback,</span>
				String importAfterCallback) {
<span class="fc" id="L668">			this.beforeCallback = beforeCallback;</span>
<span class="fc" id="L669">			this.afterCallback = afterCallback;</span>
<span class="fc" id="L670">			this.importBeforeCallback = importBeforeCallback;</span>
<span class="fc" id="L671">			this.importAfterCallback = importAfterCallback;</span>
<span class="fc" id="L672">		}</span>
	}

	private static boolean shouldProcessNode(TypeDeclaration node) {
<span class="fc" id="L676">		ITypeBinding binding = node.resolveBinding();</span>
<span class="pc bpc" id="L677" title="2 of 4 branches missed.">		return binding != null &amp;&amp; isExternalResource(binding, ORG_JUNIT_RULES_EXTERNAL_RESOURCE);</span>
	}

	private static boolean isExternalResource(FieldDeclaration field, String typeToLookup) {
<span class="fc" id="L681">		ITypeBinding binding = ((VariableDeclarationFragment) field.fragments().get(0)).resolveBinding().getType();</span>
<span class="fc" id="L682">		return org.sandbox.jdt.internal.corext.util.TypeCheckingUtils.isTypeOrSubtype(binding, typeToLookup);</span>
	}

	private static boolean isExternalResource(ITypeBinding typeBinding, String typeToLookup) {
<span class="fc" id="L686">		return org.sandbox.jdt.internal.corext.util.TypeCheckingUtils.isTypeOrSubtype(typeBinding, typeToLookup);</span>
	}



	private static boolean isLifecycleMethod(MethodDeclaration method, String methodName) {
<span class="fc" id="L692">		return methodName.equals(method.getName().getIdentifier());</span>
	}

	private static TypeDeclaration getParentTypeDeclaration(ASTNode node) {
<span class="nc" id="L696">		return ASTNavigationUtils.getParentTypeDeclaration(node);</span>
	}

	private static ASTRewrite getASTRewrite(ASTNode node, AST globalAST, ASTRewrite globalRewrite) {
<span class="fc bfc" id="L700" title="All 2 branches covered.">		return (node.getAST() == globalAST) ? globalRewrite : ASTRewrite.create(node.getAST());</span>
	}

	private static ImportRewrite getImportRewrite(ASTNode node, AST globalAST, ImportRewrite globalImportRewrite) {
<span class="fc" id="L704">		org.eclipse.jdt.core.dom.CompilationUnit compilationUnit = ASTNavigationUtils.findCompilationUnit(node);</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">		return (node.getAST() == globalAST) ? globalImportRewrite : ImportRewrite.create(compilationUnit, true);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>