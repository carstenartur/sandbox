<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>JFacePlugin.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_jface_cleanup</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">JFacePlugin.java</span></div><h1>JFacePlugin.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import org.eclipse.core.runtime.ILog;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.internal.corext.dom.ASTNodeFactory;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperationWithSourceRange;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.osgi.framework.Bundle;
import org.sandbox.jdt.internal.common.AstProcessorBuilder;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.JfaceCleanUpFixCore;

/**
 * Cleanup transformation for migrating from deprecated {@link SubProgressMonitor} to {@link SubMonitor}.
 * 
 * &lt;p&gt;This helper transforms progress monitor usage patterns in Eclipse JDT code:&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Converts {@code IProgressMonitor.beginTask()} to {@code SubMonitor.convert()}&lt;/li&gt;
 * &lt;li&gt;Replaces {@code new SubProgressMonitor(monitor, work)} with {@code subMonitor.split(work)}&lt;/li&gt;
 * &lt;li&gt;Handles both 2-argument and 3-argument SubProgressMonitor constructors&lt;/li&gt;
 * &lt;li&gt;Generates unique variable names to avoid collisions in scope&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Migration Pattern:&lt;/b&gt;&lt;/p&gt;
 * &lt;pre&gt;
 * // Before:
 * monitor.beginTask(&quot;Main Task&quot;, 100);
 * IProgressMonitor subMon = new SubProgressMonitor(monitor, 60);
 * 
 * // After:
 * SubMonitor subMonitor = SubMonitor.convert(monitor, &quot;Main Task&quot;, 100);
 * IProgressMonitor subMon = subMonitor.split(60);
 * &lt;/pre&gt;
 * 
 * @see SubProgressMonitor
 * @see SubMonitor
 */
<span class="fc" id="L77">public class JFacePlugin extends</span>
AbstractTool&lt;ReferenceHolder&lt;Integer, JFacePlugin.MonitorHolder&gt;&gt; {

	public static final String CLASS_INSTANCE_CREATION = &quot;ClassInstanceCreation&quot;; //$NON-NLS-1$
	public static final String METHODINVOCATION = &quot;MethodInvocation&quot;; //$NON-NLS-1$

	/** Debug option key for enabling JFace plugin transformation logging */
	private static final String DEBUG_OPTION = &quot;sandbox_jface_cleanup/debug/jfaceplugin&quot;; //$NON-NLS-1$
	
	/** Bundle symbolic name for logging */
	private static final String BUNDLE_ID = &quot;sandbox_jface_cleanup&quot;; //$NON-NLS-1$

	/**
	 * Holder for monitor-related transformation data.
	 * Tracks beginTask invocations and associated SubProgressMonitor instances.
	 */
<span class="fc" id="L93">	public static class MonitorHolder {</span>
		/** The beginTask method invocation to be converted */
		public MethodInvocation minv;
		/** The monitor variable name from beginTask expression */
		public String minvname;
		/** Set of SubProgressMonitor constructions to be converted to split() calls */
<span class="fc" id="L99">		public Set&lt;ClassInstanceCreation&gt; setofcic = new HashSet&lt;&gt;();</span>
		/** Nodes that have been processed to avoid duplicate transformations */
		public Set&lt;ASTNode&gt; nodesprocessed;
	}

	/**
	 * Checks if debug logging is enabled for JFace plugin transformations.
	 * 
	 * @return {@code true} if debug logging is enabled, {@code false} otherwise
	 */
	private static boolean isDebugEnabled() {
<span class="pc bpc" id="L110" title="3 of 4 branches missed.">		return Platform.inDebugMode() &amp;&amp; &quot;true&quot;.equalsIgnoreCase(Platform.getDebugOption(DEBUG_OPTION)); //$NON-NLS-1$</span>
	}

	/**
	 * Logs a debug message if debug mode is enabled.
	 * 
	 * @param message the message to log
	 */
	private static void logDebug(String message) {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		if (isDebugEnabled()) {</span>
			try {
<span class="nc" id="L121">				Bundle bundle = Platform.getBundle(BUNDLE_ID);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				if (bundle != null) {</span>
<span class="nc" id="L123">					ILog log = Platform.getLog(bundle);</span>
<span class="nc" id="L124">					log.log(new Status(IStatus.INFO, BUNDLE_ID, &quot;JFacePlugin: &quot; + message)); //$NON-NLS-1$</span>
				}
<span class="nc" id="L126">			} catch (Exception e) {</span>
<span class="nc" id="L127">				System.err.println(&quot;Failed to log debug message: &quot; + e.getMessage());</span>
<span class="nc" id="L128">				e.printStackTrace(System.err);</span>
			}
		}
<span class="fc" id="L131">	}</span>

	/**
	 * Finds and identifies SubProgressMonitor usage patterns to be transformed.
	 * 
	 * &lt;p&gt;This method scans the compilation unit for:&lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;{@code beginTask} method invocations on IProgressMonitor instances&lt;/li&gt;
	 * &lt;li&gt;{@code SubProgressMonitor} constructor invocations that reference the same monitor&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;When both patterns are found in the same scope, a cleanup operation is registered
	 * to transform them to the SubMonitor pattern.&lt;/p&gt;
	 * 
	 * @param fixcore the cleanup fix core instance
	 * @param compilationUnit the compilation unit to analyze
	 * @param operations set to collect identified cleanup operations
	 * @param nodesprocessed set of nodes already processed to avoid duplicates
	 * @param createForOnlyIfVarUsed flag to control when operations are created (unused in this implementation)
	 */
	@Override
	public void find(JfaceCleanUpFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed,
			boolean createForOnlyIfVarUsed) {
<span class="fc" id="L155">		ReferenceHolder&lt;Integer, MonitorHolder&gt; dataholder = new ReferenceHolder&lt;&gt;();</span>
		
<span class="fc" id="L157">		AstProcessorBuilder.with(dataholder, nodesprocessed)</span>
<span class="fc" id="L158">			.processor()</span>
<span class="fc" id="L159">			.callMethodInvocationVisitor(IProgressMonitor.class, &quot;beginTask&quot;, (node, holder) -&gt; { //$NON-NLS-1$</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">				if (node.arguments().size() != 2) {</span>
<span class="nc" id="L161">					return true;</span>
				}
<span class="fc" id="L163">				logDebug(&quot;Found beginTask at position &quot; + node.getStartPosition() + &quot; (type: &quot; + node.getClass().getSimpleName() + &quot;)&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
				
				// Check if parent is ExpressionStatement, otherwise skip
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">				if (!(node.getParent() instanceof ExpressionStatement)) {</span>
<span class="nc" id="L167">					return true;</span>
				}
				
<span class="fc" id="L170">				Expression expr = node.getExpression();</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">				if (expr == null) {</span>
<span class="nc" id="L172">					return true;</span>
				}
<span class="fc" id="L174">				SimpleName sn = ASTNodes.as(expr, SimpleName.class);</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">				if (sn != null) {</span>
<span class="fc" id="L176">					IBinding ibinding = sn.resolveBinding();</span>
					// Add null-check for binding
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">					if (ibinding == null) {</span>
<span class="nc" id="L179">						return true;</span>
					}
<span class="fc" id="L181">					String name = ibinding.getName();</span>
<span class="fc" id="L182">					MonitorHolder mh = new MonitorHolder();</span>
<span class="fc" id="L183">					mh.minv = node;</span>
<span class="fc" id="L184">					mh.minvname = name;</span>
<span class="fc" id="L185">					mh.nodesprocessed = nodesprocessed;</span>
<span class="fc" id="L186">					holder.put(holder.size(), mh);</span>
				}
<span class="fc" id="L188">				return true;</span>
<span class="fc" id="L189">			}, s -&gt; ASTNodes.getTypedAncestor(s, Block.class))</span>
<span class="fc" id="L190">			.callClassInstanceCreationVisitor(SubProgressMonitor.class, (node, holder) -&gt; {</span>
				// Guard against empty holder
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">				if (holder.isEmpty()) {</span>
<span class="nc" id="L193">					return true;</span>
				}
<span class="fc" id="L195">				MonitorHolder mh = holder.get(holder.size() - 1);</span>
<span class="fc" id="L196">				List&lt;?&gt; arguments = node.arguments();</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">				if (arguments.isEmpty()) {</span>
<span class="nc" id="L198">					return true;</span>
				}
				
				// Safe handling of first argument - extract identifier from expression
<span class="fc" id="L202">				Expression firstArg = (Expression) arguments.get(0);</span>
<span class="fc" id="L203">				String firstArgName = null;</span>
				
				// Try to extract SimpleName from the expression
<span class="fc" id="L206">				SimpleName sn = ASTNodes.as(firstArg, SimpleName.class);</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">				if (sn != null) {</span>
<span class="fc" id="L208">					firstArgName = sn.getIdentifier();</span>
				}
				
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">				if (firstArgName == null || !mh.minvname.equals(firstArgName)) {</span>
<span class="nc" id="L212">					return true;</span>
				}
<span class="fc" id="L214">				logDebug(&quot;Found SubProgressMonitor construction at position &quot; + node.getStartPosition() + &quot; for variable '&quot; + firstArgName + &quot;'&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L215">				mh.setofcic.add(node);</span>
<span class="fc" id="L216">				operations.add(fixcore.rewrite(holder));</span>
<span class="fc" id="L217">				return true;</span>
			})
<span class="fc" id="L219">			.build(compilationUnit);</span>
<span class="fc" id="L220">	}</span>

	/**
	 * Rewrites AST nodes to transform SubProgressMonitor patterns to SubMonitor.
	 * 
	 * &lt;p&gt;Performs two main transformations:&lt;/p&gt;
	 * &lt;ol&gt;
	 * &lt;li&gt;&lt;b&gt;beginTask → convert:&lt;/b&gt; Transforms {@code monitor.beginTask(msg, work)} 
	 *     to {@code SubMonitor subMonitor = SubMonitor.convert(monitor, msg, work)}&lt;/li&gt;
	 * &lt;li&gt;&lt;b&gt;SubProgressMonitor → split:&lt;/b&gt; Transforms constructor calls:
	 *     &lt;ul&gt;
	 *     &lt;li&gt;2-arg: {@code new SubProgressMonitor(monitor, work)} → {@code subMonitor.split(work)}&lt;/li&gt;
	 *     &lt;li&gt;3-arg: {@code new SubProgressMonitor(monitor, work, flags)} → {@code subMonitor.split(work, flags)}&lt;/li&gt;
	 *     &lt;/ul&gt;
	 * &lt;/li&gt;
	 * &lt;/ol&gt;
	 * 
	 * &lt;p&gt;The transformation ensures:&lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Unique variable names for SubMonitor to avoid collisions&lt;/li&gt;
	 * &lt;li&gt;Preservation of flags parameter in 3-arg constructors&lt;/li&gt;
	 * &lt;li&gt;Removal of SubProgressMonitor import&lt;/li&gt;
	 * &lt;li&gt;Addition of SubMonitor import&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @param upp the cleanup fix core instance
	 * @param hit the holder containing identified monitor patterns to transform
	 * @param cuRewrite the compilation unit rewrite context
	 * @param group the text edit group for tracking changes
	 */
	@Override
	public void rewrite(JfaceCleanUpFixCore upp, final ReferenceHolder&lt;Integer, MonitorHolder&gt; hit,
			final CompilationUnitRewrite cuRewrite, TextEditGroup group) {
<span class="fc" id="L253">		ASTRewrite rewrite = cuRewrite.getASTRewrite();</span>
<span class="fc" id="L254">		AST ast = cuRewrite.getRoot().getAST();</span>
<span class="fc" id="L255">		ImportRewrite importRemover = cuRewrite.getImportRewrite();</span>
		
		// Guard against empty holder
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">		if (hit.isEmpty()) {</span>
<span class="nc" id="L259">			return;</span>
		}
		
<span class="fc" id="L262">		Set&lt;ASTNode&gt; nodesprocessed = hit.get(hit.size() - 1).nodesprocessed;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">		for (Entry&lt;Integer, MonitorHolder&gt; entry : hit.entrySet()) {</span>

<span class="fc" id="L265">			MonitorHolder mh = entry.getValue();</span>
<span class="fc" id="L266">			MethodInvocation minv = mh.minv;</span>
			
			// Generate unique identifier name for SubMonitor variable
<span class="fc" id="L269">			String identifier = generateUniqueVariableName(minv, &quot;subMonitor&quot;); //$NON-NLS-1$</span>
			
<span class="fc bfc" id="L271" title="All 2 branches covered.">			if (!nodesprocessed.contains(minv)) {</span>
<span class="fc" id="L272">				nodesprocessed.add(minv);</span>
<span class="fc" id="L273">				logDebug(&quot;Rewriting beginTask at position &quot; + minv.getStartPosition() + &quot; (method: &quot; + minv.getName() + &quot;)&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
				
				// Ensure parent is ExpressionStatement
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">				if (!(minv.getParent() instanceof ExpressionStatement)) {</span>
<span class="nc" id="L277">					continue;</span>
				}
				
<span class="fc" id="L280">				List&lt;ASTNode&gt; arguments = minv.arguments();</span>

				/**
				 * Here we process the &quot;beginTask&quot; and change it to &quot;SubMonitor.convert&quot;
				 *
				 * monitor.beginTask(NewWizardMessages.NewSourceFolderWizardPage_operation, 3);
				 * SubMonitor subMonitor =
				 * SubMonitor.convert(monitor,NewWizardMessages.NewSourceFolderWizardPage_operation,
				 * 3);
				 *
				 */

<span class="fc" id="L292">				SingleVariableDeclaration newVariableDeclarationStatement = ast.newSingleVariableDeclaration();</span>

<span class="fc" id="L294">				newVariableDeclarationStatement.setName(ast.newSimpleName(identifier));</span>
<span class="fc" id="L295">				newVariableDeclarationStatement</span>
<span class="fc" id="L296">				.setType(ast.newSimpleType(addImport(SubMonitor.class.getCanonicalName(), cuRewrite, ast)));</span>

<span class="fc" id="L298">				MethodInvocation staticCall = ast.newMethodInvocation();</span>
<span class="fc" id="L299">				staticCall.setExpression(ASTNodeFactory.newName(ast, SubMonitor.class.getSimpleName()));</span>
<span class="fc" id="L300">				staticCall.setName(ast.newSimpleName(&quot;convert&quot;)); //$NON-NLS-1$</span>
<span class="fc" id="L301">				List&lt;ASTNode&gt; staticCallArguments = staticCall.arguments();</span>
<span class="fc" id="L302">				staticCallArguments.add(</span>
<span class="fc" id="L303">						ASTNodes.createMoveTarget(rewrite, ASTNodes.getUnparenthesedExpression(minv.getExpression())));</span>
<span class="fc" id="L304">				staticCallArguments</span>
<span class="fc" id="L305">				.add(ASTNodes.createMoveTarget(rewrite, ASTNodes.getUnparenthesedExpression(arguments.get(0))));</span>
<span class="fc" id="L306">				staticCallArguments</span>
<span class="fc" id="L307">				.add(ASTNodes.createMoveTarget(rewrite, ASTNodes.getUnparenthesedExpression(arguments.get(1))));</span>
<span class="fc" id="L308">				newVariableDeclarationStatement.setInitializer(staticCall);</span>

<span class="fc" id="L310">				ASTNodes.replaceButKeepComment(rewrite, minv, newVariableDeclarationStatement, group);</span>
<span class="fc" id="L311">				logDebug(&quot;Created SubMonitor.convert call: &quot; + staticCall); //$NON-NLS-1$</span>
			}
			
<span class="fc bfc" id="L314" title="All 2 branches covered.">			for (ClassInstanceCreation submon : mh.setofcic) {</span>
<span class="fc" id="L315">				List&lt;?&gt; arguments = submon.arguments();</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">				if (arguments.size() &lt; 2) {</span>
<span class="nc" id="L317">					continue;</span>
				}
				
<span class="fc" id="L320">				ASTNode origarg = (ASTNode) arguments.get(1);</span>
<span class="fc" id="L321">				logDebug(&quot;Rewriting SubProgressMonitor at position &quot; + submon.getStartPosition() + &quot; (ClassInstanceCreation)&quot;); //$NON-NLS-1$ //$NON-NLS-2$</span>
				
				/**
				 * Handle both 2-arg and 3-arg SubProgressMonitor constructors:
				 * 
				 * 2-arg: new SubProgressMonitor(monitor, work)
				 *   -&gt; subMonitor.split(work)
				 *   
				 * 3-arg: new SubProgressMonitor(monitor, work, flags)
				 *   -&gt; subMonitor.split(work, flags)
				 */
<span class="fc" id="L332">				MethodInvocation newMethodInvocation2 = ast.newMethodInvocation();</span>
<span class="fc" id="L333">				newMethodInvocation2.setName(ast.newSimpleName(&quot;split&quot;)); //$NON-NLS-1$</span>
<span class="fc" id="L334">				newMethodInvocation2.setExpression(ASTNodeFactory.newName(ast, identifier));</span>
<span class="fc" id="L335">				List&lt;ASTNode&gt; splitCallArguments = newMethodInvocation2.arguments();</span>

				// Add the work amount (second argument)
<span class="fc" id="L338">				splitCallArguments</span>
<span class="fc" id="L339">				.add(ASTNodes.createMoveTarget(rewrite, ASTNodes.getUnparenthesedExpression(origarg)));</span>
				
				// Check for 3-arg constructor (with flags)
<span class="fc bfc" id="L342" title="All 2 branches covered.">				if (arguments.size() &gt;= 3) {</span>
<span class="fc" id="L343">					ASTNode flagsArg = (ASTNode) arguments.get(2);</span>
<span class="fc" id="L344">					splitCallArguments.add(ASTNodes.createMoveTarget(rewrite, ASTNodes.getUnparenthesedExpression(flagsArg)));</span>
				}
				
<span class="fc" id="L347">				ASTNodes.replaceButKeepComment(rewrite, submon, newMethodInvocation2, group);</span>
<span class="fc" id="L348">				importRemover.removeImport(SubProgressMonitor.class.getCanonicalName());</span>
			}
		}
<span class="fc" id="L351">	}</span>
	
	/**
	 * Generates a unique variable name that doesn't collide with existing variables in scope.
	 * 
	 * &lt;p&gt;This method ensures the SubMonitor variable name doesn't conflict with other
	 * variables visible at the transformation point. If the base name is already in use,
	 * a numeric suffix is appended (e.g., &quot;subMonitor2&quot;, &quot;subMonitor3&quot;, etc.).&lt;/p&gt;
	 * 
	 * @param node the AST node context for scope analysis
	 * @param baseName the base name to use (e.g., &quot;subMonitor&quot;)
	 * @return a unique variable name that doesn't exist in the current scope
	 */
	private String generateUniqueVariableName(ASTNode node, String baseName) {
<span class="fc" id="L365">		Collection&lt;String&gt; usedNames = getUsedVariableNames(node);</span>
		
		// If base name is not used, return it
<span class="fc bfc" id="L368" title="All 2 branches covered.">		if (!usedNames.contains(baseName)) {</span>
<span class="fc" id="L369">			return baseName;</span>
		}
		
		// Otherwise, append a number until we find an unused name
<span class="fc" id="L373">		int counter = 2;</span>
<span class="fc" id="L374">		String candidate = baseName + counter;</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">		while (usedNames.contains(candidate)) {</span>
<span class="nc" id="L376">			counter++;</span>
<span class="nc" id="L377">			candidate = baseName + counter;</span>
		}
<span class="fc" id="L379">		return candidate;</span>
	}

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (!afterRefactoring) {</span>
<span class="nc" id="L385">			return &quot;&quot;&quot;</span>
					monitor.beginTask(NewWizardMessages.NewSourceFolderWizardPage_operation, 3);
						IProgressMonitor subProgressMonitor= new SubProgressMonitor(monitor, 1);
						IProgressMonitor subProgressMonitor2= new SubProgressMonitor(monitor, 2);
				&quot;&quot;&quot;; //$NON-NLS-1$
		}
<span class="nc" id="L391">		return &quot;&quot;&quot;</span>
				SubMonitor subMonitor=SubMonitor.convert(monitor,NewWizardMessages.NewSourceFolderWizardPage_operation,3);
					IProgressMonitor subProgressMonitor= subMonitor.split(1);
					IProgressMonitor subProgressMonitor2= subMonitor.split(2);
			&quot;&quot;&quot;; //$NON-NLS-1$
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>