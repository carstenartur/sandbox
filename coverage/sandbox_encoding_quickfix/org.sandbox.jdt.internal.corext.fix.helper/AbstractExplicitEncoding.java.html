<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractExplicitEncoding.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_encoding_quickfix</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">AbstractExplicitEncoding.java</span></div><h1>AbstractExplicitEncoding.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*******************************************************************************</span>
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperation;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.UseExplicitEncodingFixCore;
import org.sandbox.jdt.internal.corext.util.ImportUtils;


/**
 * Abstract base class for encoding-related quick fixes. Provides common functionality
 * for finding and rewriting code patterns that use implicit or string-based encoding
 * specifications.
 *
 * &lt;p&gt;Subclasses must implement:
 * &lt;ul&gt;
 *   &lt;li&gt;{@link #find} - to locate code patterns that need to be fixed&lt;/li&gt;
 *   &lt;li&gt;{@link #rewrite} - to apply the encoding-related transformation&lt;/li&gt;
 *   &lt;li&gt;{@link #getPreview} - to generate preview text for the fix&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @param &lt;T&gt; The type of AST node that this encoding handler processes
 */
<span class="fc" id="L69">public abstract class AbstractExplicitEncoding&lt;T extends ASTNode&gt; {</span>

	/** Fully qualified name of java.io.UnsupportedEncodingException. */
	private static final String JAVA_IO_UNSUPPORTED_ENCODING_EXCEPTION = &quot;java.io.UnsupportedEncodingException&quot;; //$NON-NLS-1$

	/** Simple name of UnsupportedEncodingException for matching in exception types. */
	private static final String UNSUPPORTED_ENCODING_EXCEPTION = &quot;UnsupportedEncodingException&quot;; //$NON-NLS-1$

	/**
	 * Immutable map of standard charset names (e.g., &quot;UTF-8&quot;) to their corresponding
	 * StandardCharsets constant names (e.g., &quot;UTF_8&quot;).
	 * &lt;p&gt;
	 * This mapping covers the six charsets guaranteed to be available on every Java platform.
	 * &lt;/p&gt;
	 * @since 1.3
	 */
<span class="fc" id="L85">	public static final Map&lt;String, String&gt; ENCODING_MAP = Map.of(</span>
<span class="fc" id="L86">			&quot;UTF-8&quot;, &quot;UTF_8&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L87">			&quot;UTF-16&quot;, &quot;UTF_16&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L88">			&quot;UTF-16BE&quot;, &quot;UTF_16BE&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L89">			&quot;UTF-16LE&quot;, &quot;UTF_16LE&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L90">			&quot;ISO-8859-1&quot;, &quot;ISO_8859_1&quot;, //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L91">			&quot;US-ASCII&quot;, &quot;US_ASCII&quot; //$NON-NLS-1$ //$NON-NLS-2$</span>
	);

	/**
	 * Immutable set of supported encoding names that can be converted to StandardCharsets constants.
	 * @since 1.3
	 */
<span class="fc" id="L98">	public static final Set&lt;String&gt; ENCODINGS = ENCODING_MAP.keySet();</span>

	/**
	 * Maps standard charset names (e.g., &quot;UTF-8&quot;) to their corresponding
	 * StandardCharsets constant names (e.g., &quot;UTF_8&quot;).
	 * @deprecated Use {@link #ENCODING_MAP} instead. This field is maintained for backward
	 *             compatibility but is immutable and will throw UnsupportedOperationException
	 *             if modification is attempted.
	 */
	@Deprecated
<span class="fc" id="L108">	static final Map&lt;String, String&gt; encodingmap = ENCODING_MAP;</span>

	/**
	 * Set of supported encoding names that can be converted to StandardCharsets constants.
	 * @deprecated Use {@link #ENCODINGS} instead. This field is maintained for backward
	 *             compatibility but is immutable and will throw UnsupportedOperationException
	 *             if modification is attempted.
	 */
	@Deprecated
<span class="fc" id="L117">	static final Set&lt;String&gt; encodings = ENCODINGS;</span>

	/**
	 * Immutable record to hold node data for encoding transformations.
	 * Replaces the mutable Nodedata class for better thread safety and immutability.
	 * 
	 * @param replace Whether to replace an existing encoding parameter (true) or appended (false)
	 * @param visited The AST node that was visited and needs modification
	 * @param encoding The encoding constant name (e.g., &quot;UTF_8&quot;), or null for default charset
	 */
	protected static record NodeData(boolean replace, ASTNode visited, String encoding) {
	}

	/**
	 * Thread-safe map to cache charset constant references during aggregation.
	 * Used to avoid creating duplicate QualifiedName instances.
	 */
<span class="fc" id="L134">	private static final Map&lt;String, QualifiedName&gt; CHARSET_CONSTANTS = new ConcurrentHashMap&lt;&gt;();</span>

	/**
	 * Returns the charset constants map for use in encoding transformations.
	 * 
	 * @return thread-safe map of charset constants
	 */
	protected static Map&lt;String, QualifiedName&gt; getCharsetConstants() {
<span class="fc" id="L142">		return CHARSET_CONSTANTS;</span>
	}

	/** Key used for storing encoding information in data holders. */
	protected static final String KEY_ENCODING = &quot;encoding&quot;; //$NON-NLS-1$

	/** Key used for storing replace flag in data holders. */
	protected static final String KEY_REPLACE = &quot;replace&quot;; //$NON-NLS-1$

	/**
	 * @deprecated Use {@link #KEY_ENCODING} instead. This field will be removed in a future version.
	 */
	@Deprecated(forRemoval = true)
	protected static final String ENCODING = KEY_ENCODING;

	/**
	 * @deprecated Use {@link #KEY_REPLACE} instead. This field will be removed in a future version.
	 */
	@Deprecated(forRemoval = true)
<span class="fc" id="L161">	protected static final String REPLACE = KEY_REPLACE;</span>

	/**
	 * Finds all occurrences of the encoding pattern that this handler processes
	 * and adds corresponding rewrite operations.
	 *
	 * @param fixcore the fix core instance, must not be null
	 * @param compilationUnit the compilation unit to search in, must not be null
	 * @param operations the set to add rewrite operations to, must not be null
	 * @param nodesprocessed the set of already processed nodes (to avoid duplicates), must not be null
	 * @param cb the change behavior configuration, must not be null
	 */
	public abstract void find(UseExplicitEncodingFixCore fixcore, CompilationUnit compilationUnit, Set&lt;CompilationUnitRewriteOperation&gt; operations, Set&lt;ASTNode&gt; nodesprocessed, ChangeBehavior cb);

	/**
	 * Rewrites the visited AST node to use explicit encoding.
	 *
	 * @param useExplicitEncodingFixCore the fix core instance, must not be null
	 * @param visited the AST node to rewrite, must not be null
	 * @param cuRewrite the compilation unit rewrite context, must not be null
	 * @param group the text edit group for grouping changes, must not be null
	 * @param cb the change behavior configuration, must not be null
	 * @param data the reference holder containing node-specific data, must not be null
	 */
	public abstract void rewrite(UseExplicitEncodingFixCore useExplicitEncodingFixCore, T visited, CompilationUnitRewrite cuRewrite,
			TextEditGroup group, ChangeBehavior cb, ReferenceHolder&lt;ASTNode, Object&gt; data);

	/**
	 * Adds an import to the class. This method should be used for every class reference added to
	 * the generated code.
	 *
	 * @param typeName a fully qualified name of a type, must not be null
	 * @param cuRewrite CompilationUnitRewrite, must not be null
	 * @param ast AST, must not be null
	 * @return simple name of a class if the import was added and fully qualified name if there was
	 *         a conflict; never null
	 */
	protected static Name addImport(String typeName, final CompilationUnitRewrite cuRewrite, AST ast) {
<span class="fc" id="L199">		return ImportUtils.addImport(typeName, cuRewrite.getImportRewrite(), ast);</span>
	}

	/**
	 * Checks if a string literal contains a known encoding that can be converted
	 * to a StandardCharsets constant.
	 *
	 * @param literal the string literal to check, may be null
	 * @return true if the literal contains a known encoding, false otherwise
	 */
	protected static boolean isKnownEncoding(StringLiteral literal) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (literal == null) {</span>
<span class="nc" id="L211">			return false;</span>
		}
<span class="nc" id="L213">		return ENCODINGS.contains(literal.getLiteralValue().toUpperCase(Locale.ROOT));</span>
	}

	/**
	 * Gets the StandardCharsets constant name for a given encoding string literal.
	 *
	 * @param literal the string literal containing the encoding name, may be null
	 * @return the StandardCharsets constant name (e.g., &quot;UTF_8&quot;), or null if the literal
	 *         is null or contains an unknown encoding
	 */
	protected static String getEncodingConstantName(StringLiteral literal) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (literal == null) {</span>
<span class="nc" id="L225">			return null;</span>
		}
<span class="nc" id="L227">		return ENCODING_MAP.get(literal.getLiteralValue().toUpperCase(Locale.ROOT));</span>
	}

	/**
	 * Resolves the encoding value from various AST node types representing a charset argument.
	 * Handles string literals, variable references, qualified names (e.g., StandardCharsets.UTF_8),
	 * and field access expressions.
	 *
	 * @param encodingArg the AST node representing the charset argument
	 * @param context the method invocation context for variable resolution
	 * @return the uppercase encoding string (e.g., &quot;UTF-8&quot;), or null if not determinable
	 */
	protected static String getEncodingValue(ASTNode encodingArg, MethodInvocation context) {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">		if (encodingArg instanceof StringLiteral literal) {</span>
<span class="nc" id="L241">			return literal.getLiteralValue().toUpperCase(Locale.ROOT);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		} else if (encodingArg instanceof SimpleName simpleName) {</span>
<span class="nc" id="L243">			return findVariableValue(simpleName, context);</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">		} else if (encodingArg instanceof QualifiedName qualifiedName) {</span>
<span class="fc" id="L245">			return extractStandardCharsetName(qualifiedName);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">		} else if (encodingArg instanceof FieldAccess fieldAccess) {</span>
<span class="nc" id="L247">			return extractStandardCharsetName(fieldAccess);</span>
		}
<span class="nc" id="L249">		return null;</span>
	}

	/**
	 * Extracts charset name from QualifiedName like StandardCharsets.UTF_8.
	 *
	 * @param qualifiedName the qualified name to extract from
	 * @return the charset name (e.g., &quot;UTF-8&quot;), or null if not a StandardCharsets reference
	 */
	protected static String extractStandardCharsetName(QualifiedName qualifiedName) {
<span class="fc" id="L259">		String qualifier = qualifiedName.getQualifier().toString();</span>
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">		if (&quot;StandardCharsets&quot;.equals(qualifier) || qualifier.endsWith(&quot;.StandardCharsets&quot;)) { //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="fc" id="L261">			String fieldName = qualifiedName.getName().getIdentifier();</span>
<span class="fc" id="L262">			return fieldName.replace('_', '-');</span>
		}
<span class="nc" id="L264">		return null;</span>
	}

	/**
	 * Extracts charset name from FieldAccess like StandardCharsets.UTF_8.
	 *
	 * @param fieldAccess the field access to extract from
	 * @return the charset name (e.g., &quot;UTF-8&quot;), or null if not a StandardCharsets reference
	 */
	protected static String extractStandardCharsetName(FieldAccess fieldAccess) {
<span class="nc" id="L274">		String expression = fieldAccess.getExpression().toString();</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">		if (&quot;StandardCharsets&quot;.equals(expression) || expression.endsWith(&quot;.StandardCharsets&quot;)) { //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L276">			String fieldName = fieldAccess.getName().getIdentifier();</span>
<span class="nc" id="L277">			return fieldName.replace('_', '-');</span>
		}
<span class="nc" id="L279">		return null;</span>
	}

	/**
	 * Finds the enclosing MethodDeclaration or TypeDeclaration for a given AST node.
	 *
	 * @param node the starting node for the search, may be null
	 * @return the enclosing MethodDeclaration or TypeDeclaration, or null if not found
	 */
	private static ASTNode findEnclosingMethodOrType(ASTNode node) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if (node == null) {</span>
<span class="nc" id="L290">			return null;</span>
		}
<span class="fc" id="L292">		ASTNode methodDecl = ASTNodes.getFirstAncestorOrNull(node, MethodDeclaration.class);</span>
<span class="fc" id="L293">		ASTNode typeDecl = ASTNodes.getFirstAncestorOrNull(node, TypeDeclaration.class);</span>
		
		// Return the closest ancestor. In Java, methods are always declared inside types,
		// so if a MethodDeclaration exists, it is guaranteed to be closer than any TypeDeclaration.
		// getFirstAncestorOrNull returns the nearest ancestor of each type, so we just need to
		// prefer the more specific (nested) one.
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (methodDecl != null) {</span>
<span class="fc" id="L300">			return methodDecl;</span>
		}
<span class="nc" id="L302">		return typeDecl;</span>
	}

	/**
	 * Extracts the string literal value from a variable declaration fragment if its initializer
	 * is a string literal.
	 *
	 * @param fragment the variable declaration fragment to check, must not be null
	 * @param variableIdentifier the identifier of the variable to match, must not be null
	 * @return the uppercase string literal value if found, null otherwise
	 */
	private static String extractStringLiteralValue(VariableDeclarationFragment fragment, String variableIdentifier) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">		if (!fragment.getName().getIdentifier().equals(variableIdentifier)) {</span>
<span class="fc" id="L315">			return null;</span>
		}
<span class="fc" id="L317">		Expression initializer = fragment.getInitializer();</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">		if (initializer instanceof StringLiteral) {</span>
<span class="fc" id="L319">			return ((StringLiteral) initializer).getLiteralValue().toUpperCase(Locale.ROOT);</span>
		}
<span class="nc" id="L321">		return null;</span>
	}

	/**
	 * Searches for a variable's string literal value within a list of variable declaration fragments.
	 *
	 * @param fragments the list of fragments to search in, must not be null
	 * @param variableIdentifier the identifier of the variable to find, must not be null
	 * @return the uppercase string literal value if found, null otherwise
	 */
	private static String findValueInFragments(List&lt;?&gt; fragments, String variableIdentifier) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">		for (Object frag : fragments) {</span>
<span class="fc" id="L333">			VariableDeclarationFragment fragment = (VariableDeclarationFragment) frag;</span>
<span class="fc" id="L334">			String value = extractStringLiteralValue(fragment, variableIdentifier);</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">			if (value != null) {</span>
<span class="fc" id="L336">				return value;</span>
			}
		}
<span class="fc" id="L339">		return null;</span>
	}

	/**
	 * Searches for a variable's string literal value within method body statements.
	 *
	 * @param method the method declaration to search in, must not be null
	 * @param variableIdentifier the identifier of the variable to find, must not be null
	 * @return the uppercase string literal value if found, null otherwise
	 */
	private static String findVariableValueInMethod(MethodDeclaration method, String variableIdentifier) {
<span class="fc" id="L350">		Block body = method.getBody();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (body == null) {</span>
<span class="nc" id="L352">			return null;</span>
		}
<span class="fc" id="L354">		List&lt;?&gt; statements = body.statements();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (Object stmt : statements) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">			if (stmt instanceof VariableDeclarationStatement) {</span>
<span class="fc" id="L357">				VariableDeclarationStatement varDeclStmt = (VariableDeclarationStatement) stmt;</span>
<span class="fc" id="L358">				String value = findValueInFragments(varDeclStmt.fragments(), variableIdentifier);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">				if (value != null) {</span>
<span class="fc" id="L360">					return value;</span>
				}
			}
		}
<span class="fc" id="L364">		return null;</span>
	}

	/**
	 * Searches for a variable's string literal value within type field declarations.
	 *
	 * @param type the type declaration to search in, must not be null
	 * @param variableIdentifier the identifier of the variable to find, must not be null
	 * @return the uppercase string literal value if found, null otherwise
	 */
	private static String findVariableValueInType(TypeDeclaration type, String variableIdentifier) {
<span class="nc" id="L375">		FieldDeclaration[] fields = type.getFields();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">		for (FieldDeclaration field : fields) {</span>
<span class="nc" id="L377">			String value = findValueInFragments(field.fragments(), variableIdentifier);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			if (value != null) {</span>
<span class="nc" id="L379">				return value;</span>
			}
		}
<span class="nc" id="L382">		return null;</span>
	}

	/**
	 * Finds the value of a variable by searching for its declaration in the enclosing
	 * method or type. This is used to resolve variable references to their string literal
	 * initializer values.
	 *
	 * @param variable the SimpleName representing the variable reference, may be null
	 * @param context the AST node providing context for the search, may be null
	 * @return the uppercase string literal value of the variable's initializer,
	 *         or null if the variable is null, context is null, or the value cannot be found
	 */
	protected static String findVariableValue(SimpleName variable, ASTNode context) {
<span class="pc bpc" id="L396" title="2 of 4 branches missed.">		if (variable == null || context == null) {</span>
<span class="nc" id="L397">			return null;</span>
		}

<span class="fc" id="L400">		ASTNode enclosing = findEnclosingMethodOrType(context);</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">		if (enclosing == null) {</span>
<span class="nc" id="L402">			return null;</span>
		}

<span class="fc" id="L405">		String variableIdentifier = variable.getIdentifier();</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">		if (enclosing instanceof MethodDeclaration) {</span>
<span class="fc" id="L407">			return findVariableValueInMethod((MethodDeclaration) enclosing, variableIdentifier);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		} else if (enclosing instanceof TypeDeclaration) {</span>
<span class="nc" id="L409">			return findVariableValueInType((TypeDeclaration) enclosing, variableIdentifier);</span>
		}
<span class="nc" id="L411">		return null;</span>
	}

	/**
	 * Generates a preview string showing the code before or after the refactoring.
	 *
	 * @param afterRefactoring true to show the code after refactoring, false for before
	 * @param cb the change behavior configuration
	 * @return the preview string, never null
	 */
	public abstract String getPreview(boolean afterRefactoring, ChangeBehavior cb);

	/**
	 * Finds the enclosing MethodDeclaration or TryStatement for exception handling removal.
	 *
	 * @param node the starting node for the search
	 * @return the enclosing MethodDeclaration or TryStatement, or null if not found
	 */
	private static ASTNode findEnclosingMethodOrTry(ASTNode node) {
<span class="fc" id="L430">		ASTNode tryStmt = ASTNodes.getFirstAncestorOrNull(node, TryStatement.class);</span>
<span class="fc" id="L431">		ASTNode methodDecl = ASTNodes.getFirstAncestorOrNull(node, MethodDeclaration.class);</span>
		
		// Return the closest ancestor. In Java, try statements are always inside method bodies,
		// so if a TryStatement exists, it is guaranteed to be closer than any MethodDeclaration.
		// getFirstAncestorOrNull returns the nearest ancestor of each type, so we just need to
		// prefer the more specific (nested) one.
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (tryStmt != null) {</span>
<span class="fc" id="L438">			return tryStmt;</span>
		}
<span class="fc" id="L440">		return methodDecl;</span>
	}

	/**
	 * Checks if a type represents UnsupportedEncodingException.
	 *
	 * @param type the type to check
	 * @return true if the type is UnsupportedEncodingException
	 */
	private static boolean isUnsupportedEncodingException(Type type) {
<span class="fc" id="L450">		return type.toString().equals(UNSUPPORTED_ENCODING_EXCEPTION);</span>
	}

	/**
	 * Removes UnsupportedEncodingException from method's throws clause.
	 *
	 * @param method the method declaration to modify
	 * @param rewrite the AST rewrite to use
	 * @param group the text edit group
	 * @param importRewriter the import rewrite to use
	 */
	private static void removeExceptionFromMethodThrows(MethodDeclaration method, ASTRewrite rewrite, TextEditGroup group, ImportRewrite importRewriter) {
<span class="fc" id="L462">		ListRewrite throwsRewrite = rewrite.getListRewrite(method, MethodDeclaration.THROWN_EXCEPTION_TYPES_PROPERTY);</span>
<span class="fc" id="L463">		List&lt;Type&gt; thrownExceptions = method.thrownExceptionTypes();</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">		for (Type exceptionType : thrownExceptions) {</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			if (isUnsupportedEncodingException(exceptionType)) {</span>
<span class="fc" id="L466">				throwsRewrite.remove(exceptionType, group);</span>
<span class="fc" id="L467">				importRewriter.removeImport(JAVA_IO_UNSUPPORTED_ENCODING_EXCEPTION);</span>
			}
		}
<span class="fc" id="L470">	}</span>

	/**
	 * Handles UnsupportedEncodingException removal from a union type in a catch clause.
	 *
	 * @param unionType the union type to modify
	 * @param catchClause the catch clause containing the union type
	 * @param rewrite the AST rewrite to use
	 * @param group the text edit group
	 */
	private static void removeExceptionFromUnionType(UnionType unionType, CatchClause catchClause, ASTRewrite rewrite, TextEditGroup group) {
<span class="fc" id="L481">		ListRewrite unionRewrite = rewrite.getListRewrite(unionType, UnionType.TYPES_PROPERTY);</span>
<span class="fc" id="L482">		List&lt;Type&gt; types = unionType.types();</span>

		// Collect types to remove first to avoid modification during iteration
<span class="fc" id="L485">		List&lt;Type&gt; typesToRemove = types.stream()</span>
<span class="fc" id="L486">				.filter(AbstractExplicitEncoding::isUnsupportedEncodingException)</span>
<span class="fc" id="L487">				.toList();</span>

<span class="fc" id="L489">		typesToRemove.forEach(type -&gt; unionRewrite.remove(type, group));</span>

		// Calculate remaining count after scheduled removals
<span class="fc" id="L492">		int remainingCount = types.size() - typesToRemove.size();</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">		if (remainingCount == 1) {</span>
			// Find the remaining type (not in removal list)
<span class="fc" id="L495">			Type remainingType = types.stream()</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">					.filter(type -&gt; !typesToRemove.contains(type))</span>
<span class="fc" id="L497">					.findFirst()</span>
<span class="fc" id="L498">					.orElse(null);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">			if (remainingType != null) {</span>
<span class="fc" id="L500">				rewrite.replace(unionType, remainingType, group);</span>
			}
<span class="pc bnc" id="L502" title="All 2 branches missed.">		} else if (remainingCount == 0) {</span>
<span class="nc" id="L503">			rewrite.remove(catchClause, group);</span>
		}
<span class="fc" id="L505">	}</span>

	/**
	 * Removes UnsupportedEncodingException from catch clauses in a try statement.
	 *
	 * @param tryStatement the try statement to process
	 * @param rewrite the AST rewrite to use
	 * @param group the text edit group
	 * @param importRewriter the import rewrite to use
	 */
	private static void removeExceptionFromTryCatch(TryStatement tryStatement, ASTRewrite rewrite, TextEditGroup group, ImportRewrite importRewriter) {
<span class="fc" id="L516">		List&lt;CatchClause&gt; catchClauses = tryStatement.catchClauses();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">		for (CatchClause catchClause : catchClauses) {</span>
<span class="fc" id="L518">			SingleVariableDeclaration exception = catchClause.getException();</span>
<span class="fc" id="L519">			Type exceptionType = exception.getType();</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">			if (exceptionType instanceof UnionType) {</span>
<span class="fc" id="L522">				removeExceptionFromUnionType((UnionType) exceptionType, catchClause, rewrite, group);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">			} else if (isUnsupportedEncodingException(exceptionType)) {</span>
<span class="fc" id="L524">				rewrite.remove(catchClause, group);</span>
<span class="fc" id="L525">				importRewriter.removeImport(JAVA_IO_UNSUPPORTED_ENCODING_EXCEPTION);</span>
			}
		}
<span class="fc" id="L528">	}</span>

	/**
	 * Simplifies a try statement that has become empty after removing catch clauses.
	 *
	 * @param tryStatement the try statement to check and simplify
	 * @param rewrite the AST rewrite to use
	 * @param group the text edit group
	 */
	private static void simplifyEmptyTryStatement(TryStatement tryStatement, ASTRewrite rewrite, TextEditGroup group) {
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">		if (!tryStatement.catchClauses().isEmpty() || tryStatement.getFinally() != null) {</span>
<span class="fc" id="L539">			return;</span>
		}

<span class="fc" id="L542">		Block tryBlock = tryStatement.getBody();</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">		boolean hasResources = !tryStatement.resources().isEmpty();</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">		boolean hasStatements = !tryBlock.statements().isEmpty();</span>

<span class="pc bpc" id="L546" title="3 of 4 branches missed.">		if (!hasResources &amp;&amp; !hasStatements) {</span>
<span class="nc" id="L547">			rewrite.remove(tryStatement, group);</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">		} else if (!hasResources) {</span>
<span class="nc" id="L549">			rewrite.replace(tryStatement, tryBlock, group);</span>
		}
<span class="fc" id="L551">	}</span>

	/**
	 * Removes UnsupportedEncodingException from the enclosing method's throws clause
	 * or from catch clauses in a try statement. This is called after converting string-based
	 * encoding to StandardCharsets, since StandardCharsets methods don't throw
	 * UnsupportedEncodingException.
	 *
	 * &lt;p&gt;For method declarations, removes UnsupportedEncodingException from the throws clause.
	 * For try statements, removes catch clauses that only catch UnsupportedEncodingException,
	 * or removes the exception type from union types in multi-catch clauses.
	 *
	 * @param visited the AST node that was modified, must not be null
	 * @param group the text edit group for tracking changes, must not be null
	 * @param rewrite the AST rewrite context, must not be null
	 * @param importRewriter the import rewrite for removing unused imports, must not be null
	 */
	protected void removeUnsupportedEncodingException(final ASTNode visited, TextEditGroup group, ASTRewrite rewrite, ImportRewrite importRewriter) {
<span class="fc" id="L569">		ASTNode parent = findEnclosingMethodOrTry(visited);</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">		if (parent == null) {</span>
<span class="nc" id="L571">			return;</span>
		}

<span class="fc bfc" id="L574" title="All 2 branches covered.">		if (parent instanceof MethodDeclaration) {</span>
<span class="fc" id="L575">			removeExceptionFromMethodThrows((MethodDeclaration) parent, rewrite, group, importRewriter);</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">		} else if (parent instanceof TryStatement) {</span>
<span class="fc" id="L577">			TryStatement tryStatement = (TryStatement) parent;</span>
<span class="fc" id="L578">			removeExceptionFromTryCatch(tryStatement, rewrite, group, importRewriter);</span>
<span class="fc" id="L579">			simplifyEmptyTryStatement(tryStatement, rewrite, group);</span>
		}
<span class="fc" id="L581">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>