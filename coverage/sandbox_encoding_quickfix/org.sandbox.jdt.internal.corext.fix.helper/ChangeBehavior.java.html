<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ChangeBehavior.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_encoding_quickfix</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">ChangeBehavior.java</span></div><h1>ChangeBehavior.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import static org.sandbox.jdt.internal.common.LibStandardNames.METHOD_DEFAULT_CHARSET;
import static org.sandbox.jdt.internal.common.LibStandardNames.METHOD_DISPLAY_NAME;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Map;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;

import org.eclipse.jdt.internal.corext.dom.ASTNodeFactory;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;

<span class="fc" id="L38">public enum ChangeBehavior {</span>
<span class="fc" id="L39">	KEEP_BEHAVIOR() {</span>
		@Override
		protected Expression computeCharsetASTNode(final CompilationUnitRewrite cuRewrite, AST ast, String charset, Map&lt;String, QualifiedName&gt; charsetConstants) {
<span class="fc" id="L42">			Expression callToCharsetDefaultCharset= null;</span>

<span class="fc bfc" id="L44" title="All 2 branches covered.">			if (charset != null) {</span>
<span class="fc" id="L45">				callToCharsetDefaultCharset= addCharsetUTF8(cuRewrite, ast, charset);</span>
<span class="fc" id="L46">			} else {</span>
				// needs Java 1.5
<span class="fc" id="L48">				callToCharsetDefaultCharset= addCharsetComputation(cuRewrite, ast);</span>
			}

<span class="fc" id="L51">			return callToCharsetDefaultCharset;</span>
		}

		@Override
		protected String computeCharsetforPreview() {
<span class="nc" id="L56">			String insert= &quot;Charset.defaultCharset()&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L57">			return insert;</span>
		}
	},
<span class="fc" id="L60">	ENFORCE_UTF8() {</span>
		@Override
		protected Expression computeCharsetASTNode(final CompilationUnitRewrite cuRewrite, AST ast, String charset, Map&lt;String, QualifiedName&gt; charsetConstants) {
<span class="fc bfc" id="L63" title="All 2 branches covered.">			String charset2= charset == null ? &quot;UTF_8&quot; : charset; //$NON-NLS-1$</span>
<span class="fc" id="L64">			Expression callToCharsetDefaultCharset= addCharsetUTF8(cuRewrite, ast, charset2);</span>
<span class="fc" id="L65">			return callToCharsetDefaultCharset;</span>
		}

		@Override
		protected String computeCharsetforPreview() {
<span class="nc" id="L70">			String insert= &quot;StandardCharsets.UTF_8&quot;; //$NON-NLS-1$</span>
<span class="nc" id="L71">			return insert;</span>
		}
	},
<span class="fc" id="L74">	ENFORCE_UTF8_AGGREGATE() {</span>
		@Override
		protected Expression computeCharsetASTNode(final CompilationUnitRewrite cuRewrite, AST ast, String charset2, Map&lt;String, QualifiedName&gt; charsetConstants) {
<span class="fc bfc" id="L77" title="All 2 branches covered.">			String charset= charset2 == null ? &quot;UTF_8&quot; : charset2; //$NON-NLS-1$</span>
			// Generate a valid Java identifier for the charset name (e.g., UTF_8)
<span class="fc" id="L79">		    String fieldName = charset.toUpperCase(Locale.ROOT).replace('-', '_');</span>

		    // Check if this charset constant is already stored in the map
<span class="fc bfc" id="L82" title="All 2 branches covered.">		    if (charsetConstants.containsKey(fieldName)) {</span>
<span class="fc" id="L83">		        return charsetConstants.get(fieldName);</span>
		    }

		    // Add import for StandardCharsets
<span class="fc" id="L87">		    ImportRewrite importRewrite = cuRewrite.getImportRewrite();</span>
<span class="fc" id="L88">		    importRewrite.addImport(StandardCharsets.class.getCanonicalName());</span>
<span class="fc" id="L89">		    importRewrite.addImport(Charset.class.getCanonicalName());</span>

		    // Check if the static field already exists in the class
<span class="fc" id="L92">		    TypeDeclaration enclosingType = (TypeDeclaration) cuRewrite.getRoot().types().get(0);</span>
<span class="fc" id="L93">		    FieldDeclaration existingField = findStaticCharsetField(enclosingType, fieldName);</span>

		    QualifiedName fieldReference;
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">		    if (existingField == null) {</span>
		        // Create a new static field if it doesn't exist
<span class="fc" id="L98">		        VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L99">		        fragment.setName(ast.newSimpleName(fieldName));</span>
<span class="fc" id="L100">		        fragment.setInitializer(createCharsetAccessExpression(ast, charset));</span>

<span class="fc" id="L102">		        FieldDeclaration fieldDeclaration = ast.newFieldDeclaration(fragment);</span>
<span class="fc" id="L103">		        fieldDeclaration.setType(ast.newSimpleType(ast.newName(&quot;Charset&quot;))); //$NON-NLS-1$</span>
<span class="fc" id="L104">		        fieldDeclaration.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PRIVATE_KEYWORD));</span>
<span class="fc" id="L105">		        fieldDeclaration.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));</span>
<span class="fc" id="L106">		        fieldDeclaration.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.FINAL_KEYWORD));</span>

		        // Add the new field to the class
<span class="fc" id="L109">		        cuRewrite.getASTRewrite().getListRewrite(enclosingType, TypeDeclaration.BODY_DECLARATIONS_PROPERTY)</span>
<span class="fc" id="L110">		            .insertFirst(fieldDeclaration, null);</span>

		        // Create a QualifiedName to refer to this new field
<span class="fc" id="L113">		        fieldReference = ast.newQualifiedName(</span>
<span class="fc" id="L114">		        	    ast.newSimpleName(enclosingType.getName().getIdentifier()),</span>
<span class="fc" id="L115">		        	    ast.newSimpleName(fragment.getName().getIdentifier())</span>
		        	);
<span class="fc" id="L117">		    } else {</span>
		        // If the field already exists, find its reference name
<span class="nc" id="L119">		        VariableDeclarationFragment fragment = (VariableDeclarationFragment) existingField.fragments().get(0);</span>
<span class="nc" id="L120">		        fieldReference = ast.newQualifiedName(</span>
<span class="nc" id="L121">		            ast.newSimpleName(enclosingType.getName().getIdentifier()),</span>
<span class="nc" id="L122">		            fragment.getName()</span>
		        );
		    }

		    // Cache the field reference in the map and return it
<span class="fc" id="L127">		    charsetConstants.put(fieldName, fieldReference);</span>
<span class="fc" id="L128">		    return fieldReference;</span>
		}

		@Override
		protected String computeCharsetforPreview() {
<span class="nc" id="L133">			return &quot;CharsetConstant&quot;; //$NON-NLS-1$</span>
		}
	};

	abstract protected Expression computeCharsetASTNode(CompilationUnitRewrite cuRewrite, AST ast, String charset, Map&lt;String, QualifiedName&gt; charsetConstants);

	abstract protected String computeCharsetforPreview();

	protected static FieldDeclaration findStaticCharsetField(TypeDeclaration type, String fieldName) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">	    for (FieldDeclaration field : type.getFields()) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">	        for (Object fragment : field.fragments()) {</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">	            if (fragment instanceof VariableDeclarationFragment) {</span>
<span class="fc" id="L145">	                VariableDeclarationFragment varFrag = (VariableDeclarationFragment) fragment;</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">	                if (varFrag.getName().getIdentifier().equals(fieldName)) {</span>
<span class="nc" id="L147">	                    return field;</span>
	                }
	            }
	        }
	    }
<span class="fc" id="L152">	    return null;</span>
	}

	protected static Expression createCharsetAccessExpression(AST ast, String charset) {
<span class="fc" id="L156">	    FieldAccess fieldAccess = ast.newFieldAccess();</span>
<span class="fc" id="L157">	    fieldAccess.setExpression(ast.newName(StandardCharsets.class.getSimpleName()));</span>
<span class="fc" id="L158">	    fieldAccess.setName(ast.newSimpleName(charset));</span>
<span class="fc" id="L159">	    return fieldAccess;</span>
	}

	/**
	 * Create access to StandardCharsets.UTF_8, needs Java 1.7 or newer
	 *
	 * @param cuRewrite CompilationUnitRewrite
	 * @param ast AST
	 * @param charset Charset as String
	 * @return FieldAccess that returns Charset for UTF_8
	 */
	protected static FieldAccess addCharsetUTF8(CompilationUnitRewrite cuRewrite, AST ast, String charset) {
		/**
		 * Add import java.nio.charset.StandardCharsets - available since Java 1.7
		 */
<span class="fc" id="L174">		ImportRewrite importRewrite= cuRewrite.getImportRewrite();</span>
<span class="fc" id="L175">		importRewrite.addImport(StandardCharsets.class.getCanonicalName());</span>
		/**
		 * Add field access to StandardCharsets.UTF_8
		 */
<span class="fc" id="L179">		FieldAccess fieldaccess= ast.newFieldAccess();</span>
<span class="fc" id="L180">		fieldaccess.setExpression(ASTNodeFactory.newName(ast, StandardCharsets.class.getSimpleName()));</span>

<span class="fc" id="L182">		fieldaccess.setName(ast.newSimpleName(charset));</span>
<span class="fc" id="L183">		return fieldaccess;</span>
	}

	/**
	 * Create call to Charset.defaultCharset(), needs Java 1.5 or newer
	 *
	 * @param cuRewrite CompilationUnitRewrite
	 * @param ast AST
	 * @return MethodInvocation that returns Charset for platform encoding
	 */
	protected static MethodInvocation addCharsetComputation(final CompilationUnitRewrite cuRewrite, AST ast) {
		/**
		 * Add import java.nio.charset.Charset
		 */
<span class="fc" id="L197">		ImportRewrite importRewrite= cuRewrite.getImportRewrite();</span>
<span class="fc" id="L198">		importRewrite.addImport(Charset.class.getCanonicalName());</span>
		/**
		 * Add call to Charset.defaultCharset() - this is available since Java 1.5
		 */
<span class="fc" id="L202">		MethodInvocation firstCall= ast.newMethodInvocation();</span>
<span class="fc" id="L203">		firstCall.setExpression(ASTNodeFactory.newName(ast, Charset.class.getSimpleName()));</span>
<span class="fc" id="L204">		firstCall.setName(ast.newSimpleName(METHOD_DEFAULT_CHARSET));</span>
<span class="fc" id="L205">		return firstCall;</span>
	}

	/**
	 * Create call to Charset.defaultCharset().displayName(), needs Java 1.5 or newer
	 *
	 * @param cuRewrite CompilationUnitRewrite
	 * @param ast AST
	 * @param cb ChangeBehavior
	 * @param charset Charset as String
	 * @return MethodInvocation that returns String
	 */
	protected MethodInvocation addCharsetStringComputation(final CompilationUnitRewrite cuRewrite, AST ast, ChangeBehavior cb, String charset, Map&lt;String, QualifiedName&gt; charsetConstants) {
<span class="nc" id="L218">		Expression callToCharsetDefaultCharset= computeCharsetASTNode(cuRewrite, ast, charset, charsetConstants);</span>
		/**
		 * Add second call to Charset.defaultCharset().displayName()
		 */
<span class="nc" id="L222">		MethodInvocation secondCall= ast.newMethodInvocation();</span>
<span class="nc" id="L223">		secondCall.setExpression(callToCharsetDefaultCharset);</span>
<span class="nc" id="L224">		secondCall.setName(ast.newSimpleName(METHOD_DISPLAY_NAME));</span>
<span class="nc" id="L225">		return secondCall;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>