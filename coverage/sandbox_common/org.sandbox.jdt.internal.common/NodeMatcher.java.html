<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NodeMatcher.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_common</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.common</a> &gt; <span class="el_source">NodeMatcher.java</span></div><h1>NodeMatcher.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.common;

import java.util.List;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

/**
 * A fluent type-safe wrapper for AST nodes that enables pattern matching style processing
 * without deep instanceof chains.
 * 
 * &lt;p&gt;This class provides a more object-oriented and functional approach to handling
 * different AST node types, replacing deeply nested if-instanceof chains with a
 * cleaner fluent API.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Example - Before (nested if-instanceof):&lt;/b&gt;&lt;/p&gt;
 * &lt;pre&gt;{@code
 * if (stmt instanceof VariableDeclarationStatement) {
 *     VariableDeclarationStatement varDecl = (VariableDeclarationStatement) stmt;
 *     // handle variable declaration
 * } else if (stmt instanceof IfStatement) {
 *     IfStatement ifStmt = (IfStatement) stmt;
 *     if (ifStmt.getElseStatement() == null) {
 *         // handle if without else
 *     }
 * } else if (stmt instanceof ExpressionStatement) {
 *     // handle expression
 * }
 * }&lt;/pre&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Example - After (fluent API):&lt;/b&gt;&lt;/p&gt;
 * &lt;pre&gt;{@code
 * NodeMatcher.on(stmt)
 *     .ifVariableDeclaration(varDecl -&gt; {
 *         // handle variable declaration
 *     })
 *     .ifIfStatement(ifStmt -&gt; {
 *         // handle if statement
 *     })
 *     .ifExpressionStatement(exprStmt -&gt; {
 *         // handle expression
 *     })
 *     .orElse(node -&gt; {
 *         // handle other cases
 *     });
 * }&lt;/pre&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Example - With conditions:&lt;/b&gt;&lt;/p&gt;
 * &lt;pre&gt;{@code
 * NodeMatcher.on(stmt)
 *     .ifIfStatementMatching(
 *         ifStmt -&gt; ifStmt.getElseStatement() == null,
 *         ifStmt -&gt; handleIfWithoutElse(ifStmt)
 *     )
 *     .ifIfStatement(ifStmt -&gt; handleIfWithElse(ifStmt));
 * }&lt;/pre&gt;
 * 
 * @param &lt;N&gt; the type of AST node being matched
 * @see AstProcessorBuilder
 */
public final class NodeMatcher&lt;N extends ASTNode&gt; {

	private final N node;
<span class="fc" id="L95">	private boolean handled = false;</span>

<span class="fc" id="L97">	private NodeMatcher(N node) {</span>
<span class="fc" id="L98">		this.node = node;</span>
<span class="fc" id="L99">	}</span>

	/**
	 * Creates a new NodeMatcher for the given AST node.
	 * 
	 * @param &lt;N&gt; the type of AST node
	 * @param node the node to match against
	 * @return a new NodeMatcher instance
	 */
	public static &lt;N extends ASTNode&gt; NodeMatcher&lt;N&gt; on(N node) {
<span class="fc" id="L109">		return new NodeMatcher&lt;&gt;(node);</span>
	}

	/**
	 * Returns the wrapped node.
	 * 
	 * @return the AST node
	 */
	public N getNode() {
<span class="fc" id="L118">		return node;</span>
	}

	/**
	 * Checks if this node has already been handled by a previous matcher.
	 * 
	 * @return true if handled
	 */
	public boolean isHandled() {
<span class="fc" id="L127">		return handled;</span>
	}

	// ========== Statement Type Matchers ==========

	/**
	 * Executes the consumer if the node is a VariableDeclarationStatement.
	 */
	public NodeMatcher&lt;N&gt; ifVariableDeclaration(Consumer&lt;VariableDeclarationStatement&gt; consumer) {
<span class="fc" id="L136">		return ifType(VariableDeclarationStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a VariableDeclarationStatement and matches the predicate.
	 */
	public NodeMatcher&lt;N&gt; ifVariableDeclarationMatching(
			Predicate&lt;VariableDeclarationStatement&gt; predicate,
			Consumer&lt;VariableDeclarationStatement&gt; consumer) {
<span class="fc" id="L145">		return ifTypeMatching(VariableDeclarationStatement.class, predicate, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an IfStatement.
	 */
	public NodeMatcher&lt;N&gt; ifIfStatement(Consumer&lt;IfStatement&gt; consumer) {
<span class="fc" id="L152">		return ifType(IfStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an IfStatement and matches the predicate.
	 */
	public NodeMatcher&lt;N&gt; ifIfStatementMatching(
			Predicate&lt;IfStatement&gt; predicate,
			Consumer&lt;IfStatement&gt; consumer) {
<span class="fc" id="L161">		return ifTypeMatching(IfStatement.class, predicate, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an IfStatement without an else branch.
	 */
	public NodeMatcher&lt;N&gt; ifIfStatementWithoutElse(Consumer&lt;IfStatement&gt; consumer) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		return ifIfStatementMatching(ifStmt -&gt; ifStmt.getElseStatement() == null, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an IfStatement with an else branch.
	 */
	public NodeMatcher&lt;N&gt; ifIfStatementWithElse(Consumer&lt;IfStatement&gt; consumer) {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">		return ifIfStatementMatching(ifStmt -&gt; ifStmt.getElseStatement() != null, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an ExpressionStatement.
	 */
	public NodeMatcher&lt;N&gt; ifExpressionStatement(Consumer&lt;ExpressionStatement&gt; consumer) {
<span class="fc" id="L182">		return ifType(ExpressionStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an ExpressionStatement and matches the predicate.
	 */
	public NodeMatcher&lt;N&gt; ifExpressionStatementMatching(
			Predicate&lt;ExpressionStatement&gt; predicate,
			Consumer&lt;ExpressionStatement&gt; consumer) {
<span class="nc" id="L191">		return ifTypeMatching(ExpressionStatement.class, predicate, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a ReturnStatement.
	 */
	public NodeMatcher&lt;N&gt; ifReturnStatement(Consumer&lt;ReturnStatement&gt; consumer) {
<span class="fc" id="L198">		return ifType(ReturnStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a ContinueStatement.
	 */
	public NodeMatcher&lt;N&gt; ifContinueStatement(Consumer&lt;ContinueStatement&gt; consumer) {
<span class="fc" id="L205">		return ifType(ContinueStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a BreakStatement.
	 */
	public NodeMatcher&lt;N&gt; ifBreakStatement(Consumer&lt;BreakStatement&gt; consumer) {
<span class="fc" id="L212">		return ifType(BreakStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a ThrowStatement.
	 */
	public NodeMatcher&lt;N&gt; ifThrowStatement(Consumer&lt;ThrowStatement&gt; consumer) {
<span class="fc" id="L219">		return ifType(ThrowStatement.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a Block.
	 */
	public NodeMatcher&lt;N&gt; ifBlock(Consumer&lt;Block&gt; consumer) {
<span class="fc" id="L226">		return ifType(Block.class, consumer);</span>
	}

	// ========== Expression Type Matchers ==========

	/**
	 * Executes the consumer if the node is an Assignment.
	 */
	public NodeMatcher&lt;N&gt; ifAssignment(Consumer&lt;Assignment&gt; consumer) {
<span class="fc" id="L235">		return ifType(Assignment.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is an Assignment with the specified operator.
	 */
	public NodeMatcher&lt;N&gt; ifAssignmentWithOperator(
			Assignment.Operator operator,
			Consumer&lt;Assignment&gt; consumer) {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">		return ifTypeMatching(Assignment.class, a -&gt; a.getOperator() == operator, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a MethodInvocation.
	 */
	public NodeMatcher&lt;N&gt; ifMethodInvocation(Consumer&lt;MethodInvocation&gt; consumer) {
<span class="fc" id="L251">		return ifType(MethodInvocation.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a MethodInvocation with the specified method name.
	 */
	public NodeMatcher&lt;N&gt; ifMethodInvocationNamed(String methodName, Consumer&lt;MethodInvocation&gt; consumer) {
<span class="fc" id="L258">		return ifTypeMatching(MethodInvocation.class, </span>
<span class="fc" id="L259">				mi -&gt; methodName.equals(mi.getName().getIdentifier()), consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a PostfixExpression.
	 */
	public NodeMatcher&lt;N&gt; ifPostfixExpression(Consumer&lt;PostfixExpression&gt; consumer) {
<span class="fc" id="L266">		return ifType(PostfixExpression.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a PostfixExpression with increment or decrement.
	 */
	public NodeMatcher&lt;N&gt; ifPostfixIncrementOrDecrement(Consumer&lt;PostfixExpression&gt; consumer) {
<span class="fc" id="L273">		return ifTypeMatching(PostfixExpression.class,</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">				postfix -&gt; postfix.getOperator() == PostfixExpression.Operator.INCREMENT</span>
<span class="pc bnc" id="L275" title="All 2 branches missed.">						|| postfix.getOperator() == PostfixExpression.Operator.DECREMENT,</span>
<span class="fc" id="L276">				consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a PrefixExpression.
	 */
	public NodeMatcher&lt;N&gt; ifPrefixExpression(Consumer&lt;PrefixExpression&gt; consumer) {
<span class="fc" id="L283">		return ifType(PrefixExpression.class, consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a PrefixExpression with increment or decrement.
	 */
	public NodeMatcher&lt;N&gt; ifPrefixIncrementOrDecrement(Consumer&lt;PrefixExpression&gt; consumer) {
<span class="fc" id="L290">		return ifTypeMatching(PrefixExpression.class,</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">				prefix -&gt; prefix.getOperator() == PrefixExpression.Operator.INCREMENT</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">						|| prefix.getOperator() == PrefixExpression.Operator.DECREMENT,</span>
<span class="fc" id="L293">				consumer);</span>
	}

	/**
	 * Executes the consumer if the node is a SimpleName.
	 */
	public NodeMatcher&lt;N&gt; ifSimpleName(Consumer&lt;SimpleName&gt; consumer) {
<span class="fc" id="L300">		return ifType(SimpleName.class, consumer);</span>
	}

	// ========== Generic Type Matcher ==========

	/**
	 * Generic type matcher that handles any specific ASTNode subclass.
	 * 
	 * @param &lt;T&gt; the expected node type
	 * @param nodeClass the class to match
	 * @param consumer the consumer to execute if matched
	 * @return this matcher for chaining
	 */
	public &lt;T extends ASTNode&gt; NodeMatcher&lt;N&gt; ifType(Class&lt;T&gt; nodeClass, Consumer&lt;T&gt; consumer) {
<span class="fc bfc" id="L314" title="All 4 branches covered.">		if (!handled &amp;&amp; nodeClass.isInstance(node)) {</span>
<span class="fc" id="L315">			consumer.accept(nodeClass.cast(node));</span>
<span class="fc" id="L316">			handled = true;</span>
		}
<span class="fc" id="L318">		return this;</span>
	}

	/**
	 * Generic type matcher with predicate.
	 */
	public &lt;T extends ASTNode&gt; NodeMatcher&lt;N&gt; ifTypeMatching(
			Class&lt;T&gt; nodeClass,
			Predicate&lt;T&gt; predicate,
			Consumer&lt;T&gt; consumer) {
<span class="pc bpc" id="L328" title="2 of 4 branches missed.">		if (!handled &amp;&amp; nodeClass.isInstance(node)) {</span>
<span class="fc" id="L329">			T typedNode = nodeClass.cast(node);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">			if (predicate.test(typedNode)) {</span>
<span class="fc" id="L331">				consumer.accept(typedNode);</span>
<span class="fc" id="L332">				handled = true;</span>
			}
		}
<span class="fc" id="L335">		return this;</span>
	}

	// ========== Composite Matchers ==========

	/**
	 * Matches if the node is a Block containing exactly one statement of the given type,
	 * and that statement matches the predicate.
	 *
	 * @param &lt;S&gt; the expected statement type
	 * @param stmtClass the class of the single statement to match
	 * @param predicate the predicate to test the statement
	 * @param consumer the consumer to execute if matched
	 * @return this matcher for chaining
	 */
	public &lt;S extends Statement&gt; NodeMatcher&lt;N&gt; ifBlockWithSingleStatement(
			Class&lt;S&gt; stmtClass,
			Predicate&lt;S&gt; predicate,
			Consumer&lt;S&gt; consumer) {
<span class="pc bpc" id="L354" title="2 of 4 branches missed.">		if (!handled &amp;&amp; node instanceof Block block) {</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">			if (block.statements().size() == 1</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">					&amp;&amp; stmtClass.isInstance(block.statements().get(0))) {</span>
<span class="fc" id="L357">				S stmt = stmtClass.cast(block.statements().get(0));</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">				if (predicate.test(stmt)) {</span>
<span class="fc" id="L359">					consumer.accept(stmt);</span>
<span class="fc" id="L360">					handled = true;</span>
				}
			}
		}
<span class="fc" id="L364">		return this;</span>
	}

	/**
	 * If the node is an IfStatement, extracts the thenStatement and matches it
	 * as either a direct statement or a Block with a single statement of the given type.
	 *
	 * @param &lt;S&gt; the expected statement type
	 * @param stmtClass the class to match the then-branch content against
	 * @param predicate the predicate to test the matched statement
	 * @param consumer the consumer to execute if matched
	 * @return this matcher for chaining
	 */
	public &lt;S extends Statement&gt; NodeMatcher&lt;N&gt; ifThenStatementIs(
			Class&lt;S&gt; stmtClass,
			Predicate&lt;S&gt; predicate,
			Consumer&lt;S&gt; consumer) {
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">		if (!handled &amp;&amp; node instanceof IfStatement ifStmt) {</span>
<span class="fc" id="L382">			Statement then = ifStmt.getThenStatement();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">			if (stmtClass.isInstance(then)) {</span>
<span class="fc" id="L384">				S stmt = stmtClass.cast(then);</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">				if (predicate.test(stmt)) {</span>
<span class="fc" id="L386">					consumer.accept(stmt);</span>
<span class="fc" id="L387">					handled = true;</span>
				}
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">			} else if (then instanceof Block block</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">					&amp;&amp; block.statements().size() == 1</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">					&amp;&amp; stmtClass.isInstance(block.statements().get(0))) {</span>
<span class="fc" id="L392">				S stmt = stmtClass.cast(block.statements().get(0));</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">				if (predicate.test(stmt)) {</span>
<span class="fc" id="L394">					consumer.accept(stmt);</span>
<span class="fc" id="L395">					handled = true;</span>
				}
			}
		}
<span class="fc" id="L399">		return this;</span>
	}

	/**
	 * If the node matches the given type, applies the mapper and passes the result
	 * to the consumer. The node is considered handled if the mapper returns a non-null result.
	 *
	 * @param &lt;T&gt; the expected node type
	 * @param &lt;R&gt; the result type
	 * @param nodeClass the class to match
	 * @param mapper the function to extract a result from the node
	 * @param resultConsumer the consumer to receive the non-null result
	 * @return this matcher for chaining
	 */
	public &lt;T extends ASTNode, R&gt; NodeMatcher&lt;N&gt; ifTypeMapping(
			Class&lt;T&gt; nodeClass,
			Function&lt;T, R&gt; mapper,
			Consumer&lt;R&gt; resultConsumer) {
<span class="pc bpc" id="L417" title="2 of 4 branches missed.">		if (!handled &amp;&amp; nodeClass.isInstance(node)) {</span>
<span class="fc" id="L418">			R result = mapper.apply(nodeClass.cast(node));</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">			if (result != null) {</span>
<span class="fc" id="L420">				resultConsumer.accept(result);</span>
<span class="fc" id="L421">				handled = true;</span>
			}
		}
<span class="fc" id="L424">		return this;</span>
	}

	// ========== Static Utility Methods ==========

	/**
	 * Applies a NodeMatcher configuration to each element in a list.
	 * Only elements that are ASTNode instances are processed.
	 *
	 * @param statements the list of statements to match against
	 * @param matcherConfig the matcher configuration to apply per statement
	 */
	@SuppressWarnings(&quot;rawtypes&quot;)
	public static void matchAll(List statements,
			Function&lt;NodeMatcher&lt;ASTNode&gt;, NodeMatcher&lt;ASTNode&gt;&gt; matcherConfig) {
<span class="fc bfc" id="L439" title="All 2 branches covered.">		for (Object stmt : statements) {</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">			if (stmt instanceof ASTNode astNode) {</span>
<span class="fc" id="L441">				matcherConfig.apply(NodeMatcher.on(astNode));</span>
			}
		}
<span class="fc" id="L444">	}</span>

	// ========== Terminal Operations ==========

	/**
	 * Executes the consumer if no previous matcher handled the node.
	 * 
	 * @param consumer the consumer to execute
	 */
	public void orElse(Consumer&lt;N&gt; consumer) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">		if (!handled) {</span>
<span class="fc" id="L455">			consumer.accept(node);</span>
		}
<span class="fc" id="L457">	}</span>

	/**
	 * Executes the runnable if no previous matcher handled the node.
	 * 
	 * @param runnable the runnable to execute
	 */
	public void orElseDo(Runnable runnable) {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		if (!handled) {</span>
<span class="fc" id="L466">			runnable.run();</span>
		}
<span class="fc" id="L468">	}</span>

	/**
	 * Returns an Optional containing the result of the function if no matcher handled the node.
	 * 
	 * @param &lt;R&gt; the result type
	 * @param function the function to apply
	 * @return an Optional with the result
	 */
	public &lt;R&gt; Optional&lt;R&gt; orElseGet(Function&lt;N, R&gt; function) {
<span class="fc bfc" id="L478" title="All 2 branches covered.">		if (!handled) {</span>
<span class="fc" id="L479">			return Optional.ofNullable(function.apply(node));</span>
		}
<span class="fc" id="L481">		return Optional.empty();</span>
	}

	// ========== Utility Methods ==========

	/**
	 * Checks if the node is any of the &quot;unconvertible&quot; statement types
	 * (return, continue, break, throw).
	 * 
	 * @return true if the node is an unconvertible control flow statement
	 */
	public boolean isControlFlowStatement() {
<span class="fc bfc" id="L493" title="All 2 branches covered.">		return node instanceof ReturnStatement</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">				|| node instanceof ContinueStatement</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">				|| node instanceof BreakStatement</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				|| node instanceof ThrowStatement;</span>
	}

	/**
	 * Checks if the node is an ExpressionStatement containing an Assignment.
	 * 
	 * @return true if the node is an assignment statement
	 */
	public boolean isAssignmentStatement() {
<span class="fc bfc" id="L505" title="All 2 branches covered.">		return node instanceof ExpressionStatement exprStmt</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">				&amp;&amp; exprStmt.getExpression() instanceof Assignment;</span>
	}

	/**
	 * Extracts the Assignment from an ExpressionStatement if present.
	 * 
	 * @return Optional containing the Assignment, or empty if not an assignment statement
	 */
	public Optional&lt;Assignment&gt; getAssignment() {
<span class="fc bfc" id="L515" title="All 2 branches covered.">		if (node instanceof ExpressionStatement exprStmt</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">				&amp;&amp; exprStmt.getExpression() instanceof Assignment assignment) {</span>
<span class="fc" id="L517">			return Optional.of(assignment);</span>
		}
<span class="fc" id="L519">		return Optional.empty();</span>
	}

	/**
	 * Extracts the Expression from an ExpressionStatement if present.
	 * 
	 * @return Optional containing the Expression, or empty if not an ExpressionStatement
	 */
	public Optional&lt;Expression&gt; getExpression() {
<span class="fc bfc" id="L528" title="All 2 branches covered.">		if (node instanceof ExpressionStatement exprStmt) {</span>
<span class="fc" id="L529">			return Optional.of(exprStmt.getExpression());</span>
		}
<span class="fc" id="L531">		return Optional.empty();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>