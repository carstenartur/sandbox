<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_common</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.util</a> &gt; <span class="el_source">ExpressionHelper.java</span></div><h1>ExpressionHelper.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.util;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;

/**
 * Utility class for common expression manipulation and analysis operations.
 * 
 * &lt;p&gt;
 * This class provides helper methods for manipulating and analyzing expressions
 * in the context of AST transformations. It centralizes expression-related
 * operations to avoid code duplication across sandbox cleanup plugins.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Key Functionality:&lt;/b&gt;&lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Expression negation with proper parenthesization&lt;/li&gt;
 * &lt;li&gt;Parentheses requirement detection&lt;/li&gt;
 * &lt;li&gt;Identity mapping detection&lt;/li&gt;
 * &lt;li&gt;Expression unwrapping using JDT utilities&lt;/li&gt;
 * &lt;li&gt;Negation detection and stripping&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @see ASTNodes#getUnparenthesedExpression(Expression)
 */
public final class ExpressionHelper {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private ExpressionHelper() {
		// Utility class - no instances allowed
	}

	/**
	 * Creates a negated expression with proper parenthesization.
	 * 
	 * &lt;p&gt;
	 * This method is used when creating negated conditions in code transformations.
	 * It ensures correct operator precedence by wrapping binary and complex 
	 * expressions in parentheses.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Binary expression needs parentheses
	 * l == null  →  !(l == null)
	 * 
	 * // Simple name doesn't need parentheses
	 * flag  →  !flag
	 * 
	 * // Method call doesn't need parentheses
	 * isEmpty()  →  !isEmpty()
	 * }&lt;/pre&gt;
	 * 
	 * @param ast       the AST to create nodes in (must not be null)
	 * @param condition the condition to negate (must not be null)
	 * @return a negated expression with proper parenthesization
	 * @throws IllegalArgumentException if ast or condition is null
	 * @see #needsParentheses(Expression)
	 */
	public static Expression createNegatedExpression(AST ast, Expression condition) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">		if (ast == null) {</span>
<span class="fc" id="L86">			throw new IllegalArgumentException(&quot;ast cannot be null&quot;); //$NON-NLS-1$</span>
		}
<span class="fc bfc" id="L88" title="All 2 branches covered.">		if (condition == null) {</span>
<span class="fc" id="L89">			throw new IllegalArgumentException(&quot;condition cannot be null&quot;); //$NON-NLS-1$</span>
		}

<span class="fc" id="L92">		Expression operand = (Expression) ASTNode.copySubtree(ast, condition);</span>

		// Wrap binary expressions and other complex expressions in parentheses
		// to ensure correct operator precedence
<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (needsParentheses(condition)) {</span>
<span class="fc" id="L97">			ParenthesizedExpression parenthesized = ast.newParenthesizedExpression();</span>
<span class="fc" id="L98">			parenthesized.setExpression(operand);</span>
<span class="fc" id="L99">			operand = parenthesized;</span>
		}

<span class="fc" id="L102">		PrefixExpression negation = ast.newPrefixExpression();</span>
<span class="fc" id="L103">		negation.setOperator(PrefixExpression.Operator.NOT);</span>
<span class="fc" id="L104">		negation.setOperand(operand);</span>
<span class="fc" id="L105">		return negation;</span>
	}

	/**
	 * Determines if an expression needs parentheses when negated.
	 * 
	 * &lt;p&gt;
	 * Returns {@code true} for expressions where the negation operator {@code !}
	 * would have incorrect precedence without parentheses. This includes binary
	 * expressions, conditional expressions, instanceof expressions, and assignments.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples requiring parentheses:&lt;/b&gt;&lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Binary expressions: {@code x == y}, {@code a &amp;&amp; b}, {@code m &gt; n}&lt;/li&gt;
	 * &lt;li&gt;Conditional expressions: {@code condition ? a : b}&lt;/li&gt;
	 * &lt;li&gt;Instanceof expressions: {@code obj instanceof String}&lt;/li&gt;
	 * &lt;li&gt;Assignment expressions: {@code x = y}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples NOT requiring parentheses:&lt;/b&gt;&lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Simple names: {@code flag}, {@code isValid}&lt;/li&gt;
	 * &lt;li&gt;Literals: {@code true}, {@code 42}&lt;/li&gt;
	 * &lt;li&gt;Method calls: {@code isEmpty()}, {@code obj.check()}&lt;/li&gt;
	 * &lt;li&gt;Field access: {@code obj.field}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @param expr the expression to check (must not be null)
	 * @return true if parentheses are needed when negating this expression
	 * @throws IllegalArgumentException if expr is null
	 */
	public static boolean needsParentheses(Expression expr) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">		if (expr == null) {</span>
<span class="fc" id="L139">			throw new IllegalArgumentException(&quot;expr cannot be null&quot;); //$NON-NLS-1$</span>
		}

		// Binary expressions (==, !=, &lt;, &gt;, &lt;=, &gt;=, &amp;&amp;, ||, etc.) need parentheses
<span class="fc bfc" id="L143" title="All 2 branches covered.">		if (expr instanceof InfixExpression) {</span>
<span class="fc" id="L144">			return true;</span>
		}
		// Conditional expressions (ternary operator) need parentheses
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if (expr instanceof ConditionalExpression) {</span>
<span class="nc" id="L148">			return true;</span>
		}
		// instanceof expressions need parentheses
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">		if (expr instanceof InstanceofExpression) {</span>
<span class="nc" id="L152">			return true;</span>
		}
		// Assignment expressions need parentheses
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if (expr instanceof Assignment) {</span>
<span class="nc" id="L156">			return true;</span>
		}
		// Simple names, literals, method calls, field access, etc. don't need parentheses
<span class="fc" id="L159">		return false;</span>
	}

	/**
	 * Checks if an expression represents an identity mapping.
	 * 
	 * &lt;p&gt;
	 * An identity mapping is a transformation where the input is returned unchanged,
	 * such as {@code num -&gt; num}. This is used to detect when a transformation can
	 * be skipped because it doesn't transform the input.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Identity mapping - returns true
	 * num -&gt; num
	 * 
	 * // Non-identity mapping - returns false
	 * num -&gt; num * 2
	 * num -&gt; num.toString()
	 * }&lt;/pre&gt;
	 * 
	 * @param expression the expression to check (must not be null)
	 * @param varName    the variable name to compare against (may be null)
	 * @return true if the expression is just a reference to varName (identity
	 *         mapping), false otherwise
	 * @throws IllegalArgumentException if expression is null
	 */
	public static boolean isIdentityMapping(Expression expression, String varName) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		if (expression == null) {</span>
<span class="nc" id="L189">			throw new IllegalArgumentException(&quot;expression cannot be null&quot;); //$NON-NLS-1$</span>
		}

<span class="fc bfc" id="L192" title="All 4 branches covered.">		if (expression instanceof SimpleName &amp;&amp; varName != null) {</span>
<span class="fc" id="L193">			SimpleName simpleName = (SimpleName) expression;</span>
<span class="fc" id="L194">			return simpleName.getIdentifier().equals(varName);</span>
		}
<span class="fc" id="L196">		return false;</span>
	}

	/**
	 * Strips the negation from a negated expression using JDT's unwrapping utility.
	 * 
	 * &lt;p&gt;
	 * This method handles {@link ParenthesizedExpression} wrapping using JDT's
	 * {@link ASTNodes#getUnparenthesedExpression(Expression)} to ensure proper
	 * unwrapping of complex nested expressions.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Simple negation
	 * !condition  →  condition
	 * 
	 * // Parenthesized negation
	 * ((!condition))  →  condition
	 * 
	 * // Not a negation (returns original)
	 * condition  →  condition
	 * }&lt;/pre&gt;
	 * 
	 * @param expr the expression to strip negation from (must not be null)
	 * @return the expression without the leading NOT operator, or the original
	 *         expression if not negated
	 * @throws IllegalArgumentException if expr is null
	 * @see ASTNodes#getUnparenthesedExpression(Expression)
	 */
	public static Expression stripNegation(Expression expr) {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">		if (expr == null) {</span>
<span class="nc" id="L228">			throw new IllegalArgumentException(&quot;expr cannot be null&quot;); //$NON-NLS-1$</span>
		}

		// Use JDT utility to unwrap parentheses
<span class="fc" id="L232">		Expression unwrapped = ASTNodes.getUnparenthesedExpression(expr);</span>

		// Check if it's a negated expression
<span class="fc bfc" id="L235" title="All 2 branches covered.">		if (unwrapped instanceof PrefixExpression) {</span>
<span class="fc" id="L236">			PrefixExpression prefixExpr = (PrefixExpression) unwrapped;</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">			if (prefixExpr.getOperator() == PrefixExpression.Operator.NOT) {</span>
				// Return the operand without the NOT
<span class="fc" id="L239">				return prefixExpr.getOperand();</span>
			}
		}

		// Not a negated expression, return as-is
<span class="fc" id="L244">		return expr;</span>
	}

	/**
	 * Checks if an expression is a negated expression (starts with !).
	 * 
	 * &lt;p&gt;
	 * This method handles {@link ParenthesizedExpression} wrapping using JDT's
	 * {@link ASTNodes#getUnparenthesedExpression(Expression)} to properly detect
	 * negation in complex nested expressions.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples returning true:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Simple negation
	 * !condition  →  true
	 * 
	 * // Parenthesized negation
	 * ((!condition))  →  true
	 * 
	 * // Negated comparison
	 * !(a == b)  →  true
	 * }&lt;/pre&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples returning false:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Not negated
	 * condition  →  false
	 * 
	 * // Other prefix operator
	 * -value  →  false
	 * }&lt;/pre&gt;
	 * 
	 * @param expr the expression to check (must not be null)
	 * @return true if the expression is a negation (has a leading NOT operator),
	 *         false otherwise
	 * @throws IllegalArgumentException if expr is null
	 * @see ASTNodes#getUnparenthesedExpression(Expression)
	 */
	public static boolean isNegatedExpression(Expression expr) {
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">		if (expr == null) {</span>
<span class="nc" id="L285">			throw new IllegalArgumentException(&quot;expr cannot be null&quot;); //$NON-NLS-1$</span>
		}

		// Use JDT utility to unwrap parentheses
<span class="fc" id="L289">		Expression unwrapped = ASTNodes.getUnparenthesedExpression(expr);</span>

		// Check if it's a negated expression
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (unwrapped instanceof PrefixExpression) {</span>
<span class="fc" id="L293">			PrefixExpression prefixExpr = (PrefixExpression) unwrapped;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">			return prefixExpr.getOperator() == PrefixExpression.Operator.NOT;</span>
		}

<span class="fc" id="L297">		return false;</span>
	}

	/**
	 * Gets the unparenthesized form of an expression using JDT utilities.
	 * 
	 * &lt;p&gt;
	 * This is a convenience method that delegates to
	 * {@link ASTNodes#getUnparenthesedExpression(Expression)} for consistency
	 * across the codebase.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;/p&gt;
	 * &lt;pre&gt;{@code
	 * // Single level of parentheses
	 * (x)  →  x
	 * 
	 * // Multiple levels of parentheses
	 * (((x + y)))  →  x + y
	 * 
	 * // No parentheses (returns original)
	 * x  →  x
	 * }&lt;/pre&gt;
	 * 
	 * @param expr the expression to unwrap (may be null)
	 * @return the unparenthesized expression, or null if expr is null
	 * @see ASTNodes#getUnparenthesedExpression(Expression)
	 */
	public static Expression getUnparenthesized(Expression expr) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if (expr == null) {</span>
<span class="nc" id="L327">			return null;</span>
		}
<span class="nc" id="L329">		return ASTNodes.getUnparenthesedExpression(expr);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>