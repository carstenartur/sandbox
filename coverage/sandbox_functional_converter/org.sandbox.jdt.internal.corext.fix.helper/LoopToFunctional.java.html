<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>LoopToFunctional.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">LoopToFunctional.java</span></div><h1>LoopToFunctional.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Set;

import org.eclipse.core.runtime.CoreException;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperation;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.common.HelperVisitor;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.UseFunctionalCallFixCore;

/**
 * Converts enhanced for-loops to functional stream operations.
 * 
 * &lt;p&gt;
 * This class implements the Eclipse JDT cleanup framework to find and transform
 * imperative for-loops into declarative stream pipelines. It integrates with
 * the Eclipse IDE's quick fix and cleanup mechanisms.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Example Transformation:&lt;/b&gt;&lt;/p&gt;
 * &lt;pre&gt;{@code
 * // Before:
 * for (Integer l : ls) {
 *     System.out.println(l);
 * }
 * 
 * // After:
 * ls.forEach(l -&gt; {
 *     System.out.println(l);
 * });
 * }&lt;/pre&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Integration with Eclipse:&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * This class extends {@link AbstractFunctionalCall} and is registered as a
 * cleanup contributor in the Eclipse JDT UI framework. It participates in:
 * &lt;ul&gt;
 * &lt;li&gt;Source cleanup actions (Ctrl+Shift+F in Eclipse)&lt;/li&gt;
 * &lt;li&gt;Quick fix suggestions (Ctrl+1)&lt;/li&gt;
 * &lt;li&gt;Batch cleanup operations&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Processing Flow:&lt;/b&gt;&lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;{@link #find(UseFunctionalCallFixCore, CompilationUnit, Set, Set)}: 
 *     Visits all EnhancedForStatements and identifies convertible loops&lt;/li&gt;
 * &lt;li&gt;{@link #rewrite(UseFunctionalCallFixCore, EnhancedForStatement, CompilationUnitRewrite, TextEditGroup)}:
 *     Performs the actual AST transformation for each identified loop&lt;/li&gt;
 * &lt;li&gt;{@link #getPreview(boolean)}: Provides before/after preview in Eclipse UI&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Safety Checks:&lt;/b&gt;&lt;/p&gt;
 * &lt;p&gt;
 * The conversion only occurs if:
 * &lt;ul&gt;
 * &lt;li&gt;{@link PreconditionsChecker} validates the loop is safe to refactor&lt;/li&gt;
 * &lt;li&gt;{@link StreamPipelineBuilder} successfully analyzes the loop body&lt;/li&gt;
 * &lt;li&gt;All variables are effectively final&lt;/li&gt;
 * &lt;li&gt;No break, labeled continue, or exception throwing occurs&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * 
 * @see AbstractFunctionalCall
 * @see StreamPipelineBuilder
 * @see PreconditionsChecker
 * @see Refactorer
 */
<span class="fc" id="L89">public class LoopToFunctional extends AbstractFunctionalCall&lt;EnhancedForStatement&gt; {</span>

	@Override
	public void find(UseFunctionalCallFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperation&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {
<span class="fc" id="L94">		ReferenceHolder&lt;Integer, FunctionalHolder&gt; dataHolder= new ReferenceHolder&lt;&gt;();</span>
<span class="fc" id="L95">		ReferenceHolder&lt;ASTNode, Object&gt; sharedDataHolder = new ReferenceHolder&lt;&gt;();</span>
<span class="fc" id="L96">		HelperVisitor.callEnhancedForStatementVisitor(compilationUnit, dataHolder, nodesprocessed,</span>
<span class="fc" id="L97">				(visited, aholder) -&gt; processFoundNode(fixcore, operations, nodesprocessed, visited, aholder, sharedDataHolder),(visited, aholder) -&gt; {});</span>
<span class="fc" id="L98">	}</span>

	private boolean processFoundNode(UseFunctionalCallFixCore fixcore,
			Set&lt;CompilationUnitRewriteOperation&gt; operations, Set&lt;ASTNode&gt; nodesprocessed, EnhancedForStatement visited,
			ReferenceHolder&lt;Integer, FunctionalHolder&gt; dataHolder, ReferenceHolder&lt;ASTNode, Object&gt; sharedDataHolder) {
<span class="fc" id="L103">		PreconditionsChecker pc = new PreconditionsChecker(visited, (CompilationUnit) visited.getRoot());</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">		if (!pc.isSafeToRefactor()) {</span>
			// Loop cannot be safely refactored to functional style
			// Return true to continue visiting children - inner loops may still be convertible
<span class="nc" id="L107">			return false;</span>
		}
		// Check if the loop can be analyzed for stream conversion
<span class="fc" id="L110">		StreamPipelineBuilder builder = new StreamPipelineBuilder(visited, pc);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (!builder.analyze()) {</span>
			// Cannot convert this loop to functional style
			// Return true to continue visiting children - inner loops may still be convertible
<span class="fc" id="L114">			return false;</span>
		}
		// V1 doesn't need to store data in the holder, but we pass it to maintain signature compatibility
<span class="fc" id="L117">		operations.add(fixcore.rewrite(visited, sharedDataHolder));</span>
<span class="fc" id="L118">		nodesprocessed.add(visited);</span>
		// Return false to prevent visiting children since this loop was converted
		// (children are now part of the lambda expression)
<span class="fc" id="L121">		return false;</span>
	}

	@Override
	public void rewrite(UseFunctionalCallFixCore upp, final EnhancedForStatement visited,
			final CompilationUnitRewrite cuRewrite, TextEditGroup group, 
			org.sandbox.jdt.internal.common.ReferenceHolder&lt;ASTNode, Object&gt; data) throws CoreException {
<span class="fc" id="L128">		ASTRewrite rewrite = cuRewrite.getASTRewrite();</span>
<span class="fc" id="L129">		PreconditionsChecker pc = new PreconditionsChecker(visited, (CompilationUnit) visited.getRoot());</span>
<span class="fc" id="L130">		Refactorer refactorer = new Refactorer(visited, rewrite, pc, group, cuRewrite);</span>
		// Preconditions already checked in find(), but refactorer.refactor() handles edge cases
<span class="fc" id="L132">		refactorer.refactor();</span>
<span class="fc" id="L133">	}</span>

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (afterRefactoring) {</span>
<span class="nc" id="L138">			return &quot;ls.forEach(l -&gt; {\n	System.out.println(l);\n});\n&quot;; //$NON-NLS-1$</span>
		}
<span class="nc" id="L140">		return &quot;for (Integer l : ls)\n	System.out.println(l);\n\n&quot;; //$NON-NLS-1$</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>