<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ASTIteratorWhileRenderer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">ASTIteratorWhileRenderer.java</span></div><h1>ASTIteratorWhileRenderer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.functional.core.model.LoopModel;
import org.sandbox.functional.core.terminal.ForEachTerminal;

/**
 * ULR-based renderer that converts a {@link LoopModel} into an iterator-based while-loop.
 * 
 * &lt;p&gt;This renderer takes the abstract ULR model and produces JDT AST nodes for
 * the iterator-while pattern:&lt;/p&gt;
 * &lt;pre&gt;
 * Iterator&amp;lt;T&amp;gt; it = collection.iterator();
 * while (it.hasNext()) {
 *     T item = it.next();
 *     // body statements
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;This class is the iterator-while counterpart to {@link ASTStreamRenderer},
 * enabling the ULR pipeline to target iterator-while loops instead of streams.&lt;/p&gt;
 * 
 * @see LoopModel
 * @see ASTStreamRenderer
 */
public class ASTIteratorWhileRenderer {

	private static final String ITERATOR_NAME = &quot;it&quot;; //$NON-NLS-1$

	private final AST ast;
	private final ASTRewrite rewrite;

<span class="fc" id="L50">	public ASTIteratorWhileRenderer(AST ast, ASTRewrite rewrite) {</span>
<span class="fc" id="L51">		this.ast = ast;</span>
<span class="fc" id="L52">		this.rewrite = rewrite;</span>
<span class="fc" id="L53">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop, replacing the original statement.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original enhanced for-loop to replace
	 * @param originalBody the original loop body (for createCopyTarget comment preservation)
	 * @param group the text edit group
	 */
	public void render(LoopModel model, Statement originalStatement, Statement originalBody, TextEditGroup group) {
<span class="fc" id="L64">		String elementType = model.getElement().typeName();</span>
<span class="fc" id="L65">		String elementName = model.getElement().variableName();</span>
<span class="fc" id="L66">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="fc" id="L69">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while (it.hasNext()) { T item = it.next(); body... }
<span class="fc" id="L72">		WhileStatement whileStmt = createWhileStatement(elementType, elementName, originalBody);</span>

		// Replace the original statement with iterator decl + while
<span class="fc" id="L75">		replaceWithIteratorAndWhile(originalStatement, iteratorDecl, whileStmt, group);</span>
<span class="fc" id="L76">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop using string-based body statements.
	 * Used when the original AST body is not available for createCopyTarget.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original enhanced for-loop to replace
	 * @param group the text edit group
	 */
	public void renderFromModel(LoopModel model, Statement originalStatement, TextEditGroup group) {
<span class="nc" id="L87">		String elementType = model.getElement().typeName();</span>
<span class="nc" id="L88">		String elementName = model.getElement().variableName();</span>
<span class="nc" id="L89">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="nc" id="L92">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while statement with body from model terminal
<span class="nc" id="L95">		WhileStatement whileStmt = createWhileStatementFromModel(elementType, elementName, model);</span>

		// Replace the original statement with iterator decl + while
<span class="nc" id="L98">		replaceWithIteratorAndWhile(originalStatement, iteratorDecl, whileStmt, group);</span>
<span class="nc" id="L99">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop with body from AST statement nodes.
	 * Used when the body is available as AST nodes (e.g., from a lambda body) for createCopyTarget.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original statement to replace
	 * @param bodyStatements the body statements to copy into the while-loop
	 * @param group the text edit group
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void renderWithBodyStatements(LoopModel model, Statement originalStatement,
			java.util.List&lt;Statement&gt; bodyStatements, TextEditGroup group) {
<span class="fc" id="L113">		String elementType = model.getElement().typeName();</span>
<span class="fc" id="L114">		String elementName = model.getElement().variableName();</span>
<span class="fc" id="L115">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="fc" id="L118">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while statement with body from provided statements
<span class="fc" id="L121">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L122">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L123">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L125">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="fc" id="L126">		whileStmt.setExpression(hasNextCall);</span>

<span class="fc" id="L128">		Block whileBody = ast.newBlock();</span>
<span class="fc" id="L129">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">		for (Statement stmt : bodyStatements) {</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">			if (stmt.getParent() != null) {</span>
<span class="fc" id="L133">				whileBody.statements().add(rewrite.createCopyTarget(stmt));</span>
<span class="fc" id="L134">			} else {</span>
<span class="nc" id="L135">				whileBody.statements().add(stmt);</span>
			}
		}

<span class="fc" id="L139">		whileStmt.setBody(whileBody);</span>

		// Replace the original statement with iterator decl + while
<span class="fc" id="L142">		replaceWithIteratorAndWhile(originalStatement, iteratorDecl, whileStmt, group);</span>
<span class="fc" id="L143">	}</span>

	/**
	 * Replaces the original statement with an iterator declaration followed by a while-loop.
	 * Handles both block-level (inserts before + replaces) and non-block parents (wraps in new block).
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private void replaceWithIteratorAndWhile(Statement originalStatement,
			VariableDeclarationStatement iteratorDecl, WhileStatement whileStmt, TextEditGroup group) {
<span class="fc" id="L152">		ASTNode parent = originalStatement.getParent();</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		if (parent instanceof Block parentBlock) {</span>
<span class="fc" id="L154">			ListRewrite listRewrite = rewrite.getListRewrite(parentBlock, Block.STATEMENTS_PROPERTY);</span>
<span class="fc" id="L155">			listRewrite.insertBefore(iteratorDecl, originalStatement, group);</span>
<span class="fc" id="L156">			listRewrite.replace(originalStatement, whileStmt, group);</span>
<span class="fc" id="L157">		} else {</span>
<span class="nc" id="L158">			Block newBlock = ast.newBlock();</span>
<span class="nc" id="L159">			newBlock.statements().add(iteratorDecl);</span>
<span class="nc" id="L160">			newBlock.statements().add(whileStmt);</span>
<span class="nc" id="L161">			rewrite.replace(originalStatement, newBlock, group);</span>
		}
<span class="fc" id="L163">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private VariableDeclarationStatement createIteratorDeclaration(String elementType, String collectionExpr) {
		// Iterator&lt;T&gt;
<span class="fc" id="L168">		ParameterizedType iteratorType = ast.newParameterizedType(ast.newSimpleType(ast.newName(&quot;Iterator&quot;))); //$NON-NLS-1$</span>
<span class="fc" id="L169">		iteratorType.typeArguments().add(ast.newSimpleType(ast.newName(elementType)));</span>

		// it = collection.iterator()
<span class="fc" id="L172">		VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L173">		fragment.setName(ast.newSimpleName(ITERATOR_NAME));</span>

<span class="fc" id="L175">		MethodInvocation iteratorCall = ast.newMethodInvocation();</span>
<span class="fc" id="L176">		iteratorCall.setExpression(createExpression(collectionExpr));</span>
<span class="fc" id="L177">		iteratorCall.setName(ast.newSimpleName(&quot;iterator&quot;)); //$NON-NLS-1$</span>
<span class="fc" id="L178">		fragment.setInitializer(iteratorCall);</span>

<span class="fc" id="L180">		VariableDeclarationStatement decl = ast.newVariableDeclarationStatement(fragment);</span>
<span class="fc" id="L181">		decl.setType(iteratorType);</span>
<span class="fc" id="L182">		return decl;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private WhileStatement createWhileStatement(String elementType, String elementName, Statement originalBody) {
		// while (it.hasNext())
<span class="fc" id="L188">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L189">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L190">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L192">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="fc" id="L193">		whileStmt.setExpression(hasNextCall);</span>

		// T item = it.next();
<span class="fc" id="L196">		Block whileBody = ast.newBlock();</span>
<span class="fc" id="L197">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

		// Copy original body statements, preserving comments via createCopyTarget
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">		if (originalBody instanceof Block origBlock) {</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			for (Object stmt : origBlock.statements()) {</span>
<span class="fc" id="L202">				whileBody.statements().add(rewrite.createCopyTarget((Statement) stmt));</span>
			}
<span class="fc" id="L204">		} else {</span>
<span class="nc" id="L205">			whileBody.statements().add(rewrite.createCopyTarget(originalBody));</span>
		}

<span class="fc" id="L208">		whileStmt.setBody(whileBody);</span>
<span class="fc" id="L209">		return whileStmt;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private WhileStatement createWhileStatementFromModel(String elementType, String elementName, LoopModel model) {
		// while (it.hasNext())
<span class="nc" id="L215">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="nc" id="L216">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="nc" id="L217">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="nc" id="L219">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="nc" id="L220">		whileStmt.setExpression(hasNextCall);</span>

		// T item = it.next();
<span class="nc" id="L223">		Block whileBody = ast.newBlock();</span>
<span class="nc" id="L224">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

		// Add body from model terminal
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (model.getTerminal() instanceof ForEachTerminal forEachTerminal) {</span>
<span class="nc" id="L228">			List&lt;String&gt; bodyStatements = forEachTerminal.bodyStatements();</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">			for (String stmtStr : bodyStatements) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">				String withSemicolon = stmtStr.endsWith(&quot;;&quot;) ? stmtStr : stmtStr + &quot;;&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L231">				ASTNode parsedStmt = rewrite.createStringPlaceholder(withSemicolon, ASTNode.EXPRESSION_STATEMENT);</span>
<span class="nc" id="L232">				whileBody.statements().add(parsedStmt);</span>
			}
		}

<span class="nc" id="L236">		whileStmt.setBody(whileBody);</span>
<span class="nc" id="L237">		return whileStmt;</span>
	}

	private VariableDeclarationStatement createItemDeclaration(String elementType, String elementName) {
		// T item = it.next();
<span class="fc" id="L242">		MethodInvocation nextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L243">		nextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L244">		nextCall.setName(ast.newSimpleName(&quot;next&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L246">		VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L247">		fragment.setName(ast.newSimpleName(elementName));</span>
<span class="fc" id="L248">		fragment.setInitializer(nextCall);</span>

<span class="fc" id="L250">		VariableDeclarationStatement decl = ast.newVariableDeclarationStatement(fragment);</span>
<span class="fc" id="L251">		decl.setType(ast.newSimpleType(ast.newName(elementType)));</span>
<span class="fc" id="L252">		return decl;</span>
	}

	private Expression createExpression(String expressionStr) {
<span class="fc" id="L256">		return ExpressionHelper.createExpression(ast, rewrite, expressionStr);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>