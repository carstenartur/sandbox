<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ASTIteratorWhileRenderer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">ASTIteratorWhileRenderer.java</span></div><h1>ASTIteratorWhileRenderer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.functional.core.model.LoopModel;
import org.sandbox.functional.core.terminal.ForEachTerminal;

/**
 * ULR-based renderer that converts a {@link LoopModel} into an iterator-based while-loop.
 * 
 * &lt;p&gt;This renderer takes the abstract ULR model and produces JDT AST nodes for
 * the iterator-while pattern:&lt;/p&gt;
 * &lt;pre&gt;
 * Iterator&amp;lt;T&amp;gt; it = collection.iterator();
 * while (it.hasNext()) {
 *     T item = it.next();
 *     // body statements
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;This class is the iterator-while counterpart to {@link ASTStreamRenderer},
 * enabling the ULR pipeline to target iterator-while loops instead of streams.&lt;/p&gt;
 * 
 * @see LoopModel
 * @see ASTStreamRenderer
 */
public class ASTIteratorWhileRenderer {

	private static final String ITERATOR_NAME = &quot;it&quot;; //$NON-NLS-1$

	private final AST ast;
	private final ASTRewrite rewrite;

<span class="fc" id="L50">	public ASTIteratorWhileRenderer(AST ast, ASTRewrite rewrite) {</span>
<span class="fc" id="L51">		this.ast = ast;</span>
<span class="fc" id="L52">		this.rewrite = rewrite;</span>
<span class="fc" id="L53">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop, replacing the original statement.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original enhanced for-loop to replace
	 * @param originalBody the original loop body (for createCopyTarget comment preservation)
	 * @param group the text edit group
	 */
	public void render(LoopModel model, Statement originalStatement, Statement originalBody, TextEditGroup group) {
<span class="fc" id="L64">		String elementType = model.getElement().typeName();</span>
<span class="fc" id="L65">		String elementName = model.getElement().variableName();</span>
<span class="fc" id="L66">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="fc" id="L69">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while (it.hasNext()) { T item = it.next(); body... }
<span class="fc" id="L72">		WhileStatement whileStmt = createWhileStatement(elementType, elementName, originalBody);</span>

		// Replace the original for-loop with iterator decl + while
<span class="fc" id="L75">		ASTNode parent = originalStatement.getParent();</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (parent instanceof Block parentBlock) {</span>
<span class="fc" id="L77">			ListRewrite listRewrite = rewrite.getListRewrite(parentBlock, Block.STATEMENTS_PROPERTY);</span>
<span class="fc" id="L78">			listRewrite.insertBefore(iteratorDecl, originalStatement, group);</span>
<span class="fc" id="L79">			listRewrite.replace(originalStatement, whileStmt, group);</span>
<span class="fc" id="L80">		} else {</span>
<span class="nc" id="L81">			Block newBlock = ast.newBlock();</span>
<span class="nc" id="L82">			newBlock.statements().add(iteratorDecl);</span>
<span class="nc" id="L83">			newBlock.statements().add(whileStmt);</span>
<span class="nc" id="L84">			rewrite.replace(originalStatement, newBlock, group);</span>
		}
<span class="fc" id="L86">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop using string-based body statements.
	 * Used when the original AST body is not available for createCopyTarget.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original enhanced for-loop to replace
	 * @param group the text edit group
	 */
	public void renderFromModel(LoopModel model, Statement originalStatement, TextEditGroup group) {
<span class="nc" id="L97">		String elementType = model.getElement().typeName();</span>
<span class="nc" id="L98">		String elementName = model.getElement().variableName();</span>
<span class="nc" id="L99">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="nc" id="L102">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while statement with body from model terminal
<span class="nc" id="L105">		WhileStatement whileStmt = createWhileStatementFromModel(elementType, elementName, model);</span>

		// Replace the original for-loop with iterator decl + while
<span class="nc" id="L108">		ASTNode parent = originalStatement.getParent();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">		if (parent instanceof Block parentBlock) {</span>
<span class="nc" id="L110">			ListRewrite listRewrite = rewrite.getListRewrite(parentBlock, Block.STATEMENTS_PROPERTY);</span>
<span class="nc" id="L111">			listRewrite.insertBefore(iteratorDecl, originalStatement, group);</span>
<span class="nc" id="L112">			listRewrite.replace(originalStatement, whileStmt, group);</span>
<span class="nc" id="L113">		} else {</span>
<span class="nc" id="L114">			Block newBlock = ast.newBlock();</span>
<span class="nc" id="L115">			newBlock.statements().add(iteratorDecl);</span>
<span class="nc" id="L116">			newBlock.statements().add(whileStmt);</span>
<span class="nc" id="L117">			rewrite.replace(originalStatement, newBlock, group);</span>
		}
<span class="nc" id="L119">	}</span>

	/**
	 * Renders the given LoopModel as an iterator-while loop with body from AST statement nodes.
	 * Used when the body is available as AST nodes (e.g., from a lambda body) for createCopyTarget.
	 * 
	 * @param model the ULR LoopModel to render
	 * @param originalStatement the original statement to replace
	 * @param bodyStatements the body statements to copy into the while-loop
	 * @param group the text edit group
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void renderWithBodyStatements(LoopModel model, Statement originalStatement,
			java.util.List&lt;Statement&gt; bodyStatements, TextEditGroup group) {
<span class="fc" id="L133">		String elementType = model.getElement().typeName();</span>
<span class="fc" id="L134">		String elementName = model.getElement().variableName();</span>
<span class="fc" id="L135">		String collectionExpr = model.getSource().expression();</span>

		// Create Iterator&lt;T&gt; it = collection.iterator();
<span class="fc" id="L138">		VariableDeclarationStatement iteratorDecl = createIteratorDeclaration(elementType, collectionExpr);</span>

		// Create while statement with body from provided statements
<span class="fc" id="L141">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L142">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L143">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L145">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="fc" id="L146">		whileStmt.setExpression(hasNextCall);</span>

<span class="fc" id="L148">		Block whileBody = ast.newBlock();</span>
<span class="fc" id="L149">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">		for (Statement stmt : bodyStatements) {</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">			if (stmt.getParent() != null) {</span>
<span class="fc" id="L153">				whileBody.statements().add(rewrite.createCopyTarget(stmt));</span>
<span class="fc" id="L154">			} else {</span>
<span class="nc" id="L155">				whileBody.statements().add(stmt);</span>
			}
		}

<span class="fc" id="L159">		whileStmt.setBody(whileBody);</span>

		// Replace the original statement with iterator decl + while
<span class="fc" id="L162">		ASTNode parent = originalStatement.getParent();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">		if (parent instanceof Block parentBlock) {</span>
<span class="fc" id="L164">			ListRewrite listRewrite = rewrite.getListRewrite(parentBlock, Block.STATEMENTS_PROPERTY);</span>
<span class="fc" id="L165">			listRewrite.insertBefore(iteratorDecl, originalStatement, group);</span>
<span class="fc" id="L166">			listRewrite.replace(originalStatement, whileStmt, group);</span>
<span class="fc" id="L167">		} else {</span>
<span class="nc" id="L168">			Block newBlock = ast.newBlock();</span>
<span class="nc" id="L169">			newBlock.statements().add(iteratorDecl);</span>
<span class="nc" id="L170">			newBlock.statements().add(whileStmt);</span>
<span class="nc" id="L171">			rewrite.replace(originalStatement, newBlock, group);</span>
		}
<span class="fc" id="L173">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private VariableDeclarationStatement createIteratorDeclaration(String elementType, String collectionExpr) {
		// Iterator&lt;T&gt;
<span class="fc" id="L178">		ParameterizedType iteratorType = ast.newParameterizedType(ast.newSimpleType(ast.newName(&quot;Iterator&quot;))); //$NON-NLS-1$</span>
<span class="fc" id="L179">		iteratorType.typeArguments().add(ast.newSimpleType(ast.newName(elementType)));</span>

		// it = collection.iterator()
<span class="fc" id="L182">		VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L183">		fragment.setName(ast.newSimpleName(ITERATOR_NAME));</span>

<span class="fc" id="L185">		MethodInvocation iteratorCall = ast.newMethodInvocation();</span>
<span class="fc" id="L186">		iteratorCall.setExpression(createExpression(collectionExpr));</span>
<span class="fc" id="L187">		iteratorCall.setName(ast.newSimpleName(&quot;iterator&quot;)); //$NON-NLS-1$</span>
<span class="fc" id="L188">		fragment.setInitializer(iteratorCall);</span>

<span class="fc" id="L190">		VariableDeclarationStatement decl = ast.newVariableDeclarationStatement(fragment);</span>
<span class="fc" id="L191">		decl.setType(iteratorType);</span>
<span class="fc" id="L192">		return decl;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private WhileStatement createWhileStatement(String elementType, String elementName, Statement originalBody) {
		// while (it.hasNext())
<span class="fc" id="L198">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L199">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L200">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L202">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="fc" id="L203">		whileStmt.setExpression(hasNextCall);</span>

		// T item = it.next();
<span class="fc" id="L206">		Block whileBody = ast.newBlock();</span>
<span class="fc" id="L207">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

		// Copy original body statements, preserving comments via createCopyTarget
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		if (originalBody instanceof Block origBlock) {</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">			for (Object stmt : origBlock.statements()) {</span>
<span class="fc" id="L212">				whileBody.statements().add(rewrite.createCopyTarget((Statement) stmt));</span>
			}
<span class="fc" id="L214">		} else {</span>
<span class="nc" id="L215">			whileBody.statements().add(rewrite.createCopyTarget(originalBody));</span>
		}

<span class="fc" id="L218">		whileStmt.setBody(whileBody);</span>
<span class="fc" id="L219">		return whileStmt;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private WhileStatement createWhileStatementFromModel(String elementType, String elementName, LoopModel model) {
		// while (it.hasNext())
<span class="nc" id="L225">		MethodInvocation hasNextCall = ast.newMethodInvocation();</span>
<span class="nc" id="L226">		hasNextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="nc" id="L227">		hasNextCall.setName(ast.newSimpleName(&quot;hasNext&quot;)); //$NON-NLS-1$</span>

<span class="nc" id="L229">		WhileStatement whileStmt = ast.newWhileStatement();</span>
<span class="nc" id="L230">		whileStmt.setExpression(hasNextCall);</span>

		// T item = it.next();
<span class="nc" id="L233">		Block whileBody = ast.newBlock();</span>
<span class="nc" id="L234">		whileBody.statements().add(createItemDeclaration(elementType, elementName));</span>

		// Add body from model terminal
<span class="nc bnc" id="L237" title="All 2 branches missed.">		if (model.getTerminal() instanceof ForEachTerminal forEachTerminal) {</span>
<span class="nc" id="L238">			List&lt;String&gt; bodyStatements = forEachTerminal.bodyStatements();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">			for (String stmtStr : bodyStatements) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">				String withSemicolon = stmtStr.endsWith(&quot;;&quot;) ? stmtStr : stmtStr + &quot;;&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L241">				ASTNode parsedStmt = rewrite.createStringPlaceholder(withSemicolon, ASTNode.EXPRESSION_STATEMENT);</span>
<span class="nc" id="L242">				whileBody.statements().add(parsedStmt);</span>
			}
		}

<span class="nc" id="L246">		whileStmt.setBody(whileBody);</span>
<span class="nc" id="L247">		return whileStmt;</span>
	}

	private VariableDeclarationStatement createItemDeclaration(String elementType, String elementName) {
		// T item = it.next();
<span class="fc" id="L252">		MethodInvocation nextCall = ast.newMethodInvocation();</span>
<span class="fc" id="L253">		nextCall.setExpression(ast.newSimpleName(ITERATOR_NAME));</span>
<span class="fc" id="L254">		nextCall.setName(ast.newSimpleName(&quot;next&quot;)); //$NON-NLS-1$</span>

<span class="fc" id="L256">		VariableDeclarationFragment fragment = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L257">		fragment.setName(ast.newSimpleName(elementName));</span>
<span class="fc" id="L258">		fragment.setInitializer(nextCall);</span>

<span class="fc" id="L260">		VariableDeclarationStatement decl = ast.newVariableDeclarationStatement(fragment);</span>
<span class="fc" id="L261">		decl.setType(ast.newSimpleType(ast.newName(elementType)));</span>
<span class="fc" id="L262">		return decl;</span>
	}

	/**
	 * Creates an AST Expression from a string expression.
	 */
	private Expression createExpression(String expressionStr) {
		// For simple names, create SimpleName directly
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">		if (expressionStr.matches(&quot;[a-zA-Z_$][a-zA-Z0-9_$]*&quot;)) { //$NON-NLS-1$</span>
<span class="fc" id="L271">			return ast.newSimpleName(expressionStr);</span>
		}
		// For qualified names (e.g., &quot;this.items&quot;), create QualifiedName
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if (expressionStr.matches(&quot;[a-zA-Z_$][a-zA-Z0-9_$.]*&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L275">			return ast.newName(expressionStr);</span>
		}
		// For complex expressions, use string placeholder
<span class="nc" id="L278">		return (Expression) rewrite.createStringPlaceholder(expressionStr, ASTNode.SIMPLE_NAME);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>