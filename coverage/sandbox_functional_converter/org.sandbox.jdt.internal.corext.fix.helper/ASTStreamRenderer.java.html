<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ASTStreamRenderer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">ASTStreamRenderer.java</span></div><h1>ASTStreamRenderer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.sandbox.functional.core.model.SourceDescriptor;
import org.sandbox.functional.core.renderer.StreamPipelineRenderer;
import org.sandbox.functional.core.terminal.*;

/**
 * JDT AST-based renderer for stream pipeline generation.
 * 
 * &lt;p&gt;This renderer generates JDT AST nodes instead of strings,
 * allowing direct integration with Eclipse refactoring infrastructure.&lt;/p&gt;
 * 
 * @see StreamPipelineRenderer
 */
public class ASTStreamRenderer implements StreamPipelineRenderer&lt;Expression&gt; {
    
    private final AST ast;
    
<span class="fc" id="L35">    public ASTStreamRenderer(AST ast, ASTRewrite rewrite) {</span>
<span class="fc" id="L36">        this.ast = ast;</span>
        // Note: rewrite parameter reserved for future use in complex AST transformations
<span class="fc" id="L38">    }</span>
    
    @Override
    public Expression renderSource(SourceDescriptor source) {
        // Create: collection.stream() or Arrays.stream(array)
<span class="pc bpc" id="L43" title="1 of 5 branches missed.">        switch (source.type()) {</span>
            case COLLECTION:
                // collection.stream()
<span class="fc" id="L46">                MethodInvocation streamCall = ast.newMethodInvocation();</span>
<span class="fc" id="L47">                streamCall.setExpression(createExpression(source.expression()));</span>
<span class="fc" id="L48">                streamCall.setName(ast.newSimpleName(&quot;stream&quot;));</span>
<span class="fc" id="L49">                return streamCall;</span>
                
            case ARRAY:
                // Arrays.stream(array)
<span class="fc" id="L53">                MethodInvocation arraysStream = ast.newMethodInvocation();</span>
<span class="fc" id="L54">                arraysStream.setExpression(ast.newSimpleName(&quot;Arrays&quot;));</span>
<span class="fc" id="L55">                arraysStream.setName(ast.newSimpleName(&quot;stream&quot;));</span>
<span class="fc" id="L56">                arraysStream.arguments().add(createExpression(source.expression()));</span>
<span class="fc" id="L57">                return arraysStream;</span>
                
            case ITERABLE:
                // StreamSupport.stream(iterable.spliterator(), false)
<span class="fc" id="L61">                MethodInvocation streamSupport = ast.newMethodInvocation();</span>
<span class="fc" id="L62">                streamSupport.setExpression(ast.newSimpleName(&quot;StreamSupport&quot;));</span>
<span class="fc" id="L63">                streamSupport.setName(ast.newSimpleName(&quot;stream&quot;));</span>
                
<span class="fc" id="L65">                MethodInvocation spliterator = ast.newMethodInvocation();</span>
<span class="fc" id="L66">                spliterator.setExpression(createExpression(source.expression()));</span>
<span class="fc" id="L67">                spliterator.setName(ast.newSimpleName(&quot;spliterator&quot;));</span>
                
<span class="fc" id="L69">                streamSupport.arguments().add(spliterator);</span>
<span class="fc" id="L70">                streamSupport.arguments().add(ast.newBooleanLiteral(false));</span>
<span class="fc" id="L71">                return streamSupport;</span>
                
            case INT_RANGE:
                // IntStream.range(start, end)
<span class="fc" id="L75">                MethodInvocation intStream = ast.newMethodInvocation();</span>
<span class="fc" id="L76">                intStream.setExpression(ast.newSimpleName(&quot;IntStream&quot;));</span>
<span class="fc" id="L77">                intStream.setName(ast.newSimpleName(&quot;range&quot;));</span>
                // Parse start and end from expression (format: &quot;start,end&quot;)
<span class="fc" id="L79">                String[] parts = source.expression().split(&quot;,&quot;);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                if (parts.length != 2) {</span>
<span class="nc" id="L81">                    throw new IllegalArgumentException(&quot;Invalid INT_RANGE expression: '&quot; + source.expression()</span>
                            + &quot;'. Expected format 'start,end'.&quot;);
                }
<span class="fc" id="L84">                intStream.arguments().add(createExpression(parts[0].trim()));</span>
<span class="fc" id="L85">                intStream.arguments().add(createExpression(parts[1].trim()));</span>
<span class="fc" id="L86">                return intStream;</span>
                
            case STREAM:
            default:
                // Already a Stream
<span class="nc" id="L91">                return createExpression(source.expression());</span>
        }
    }
    
    @Override
    public Expression renderFilter(Expression pipeline, String expression, String variableName) {
        // pipeline.filter(var -&gt; expression)
<span class="fc" id="L98">        MethodInvocation filterCall = ast.newMethodInvocation();</span>
<span class="fc" id="L99">        filterCall.setExpression(pipeline);</span>
<span class="fc" id="L100">        filterCall.setName(ast.newSimpleName(&quot;filter&quot;));</span>
<span class="fc" id="L101">        filterCall.arguments().add(createLambda(variableName, expression));</span>
<span class="fc" id="L102">        return filterCall;</span>
    }
    
    @Override
    public Expression renderMap(Expression pipeline, String expression, String variableName, String targetType) {
        // pipeline.map(var -&gt; expression)
<span class="fc" id="L108">        MethodInvocation mapCall = ast.newMethodInvocation();</span>
<span class="fc" id="L109">        mapCall.setExpression(pipeline);</span>
<span class="fc" id="L110">        mapCall.setName(ast.newSimpleName(&quot;map&quot;));</span>
<span class="fc" id="L111">        mapCall.arguments().add(createLambda(variableName, expression));</span>
<span class="fc" id="L112">        return mapCall;</span>
    }
    
    @Override
    public Expression renderFlatMap(Expression pipeline, String expression, String variableName) {
        // pipeline.flatMap(var -&gt; expression)
<span class="fc" id="L118">        MethodInvocation flatMapCall = ast.newMethodInvocation();</span>
<span class="fc" id="L119">        flatMapCall.setExpression(pipeline);</span>
<span class="fc" id="L120">        flatMapCall.setName(ast.newSimpleName(&quot;flatMap&quot;));</span>
<span class="fc" id="L121">        flatMapCall.arguments().add(createLambda(variableName, expression));</span>
<span class="fc" id="L122">        return flatMapCall;</span>
    }
    
    @Override
    public Expression renderPeek(Expression pipeline, String expression, String variableName) {
        // pipeline.peek(var -&gt; expression)
<span class="fc" id="L128">        MethodInvocation peekCall = ast.newMethodInvocation();</span>
<span class="fc" id="L129">        peekCall.setExpression(pipeline);</span>
<span class="fc" id="L130">        peekCall.setName(ast.newSimpleName(&quot;peek&quot;));</span>
<span class="fc" id="L131">        peekCall.arguments().add(createLambda(variableName, expression));</span>
<span class="fc" id="L132">        return peekCall;</span>
    }
    
    @Override
    public Expression renderDistinct(Expression pipeline) {
        // pipeline.distinct()
<span class="fc" id="L138">        MethodInvocation distinctCall = ast.newMethodInvocation();</span>
<span class="fc" id="L139">        distinctCall.setExpression(pipeline);</span>
<span class="fc" id="L140">        distinctCall.setName(ast.newSimpleName(&quot;distinct&quot;));</span>
<span class="fc" id="L141">        return distinctCall;</span>
    }
    
    @Override
    public Expression renderSorted(Expression pipeline, String comparatorExpression) {
        // pipeline.sorted() oder pipeline.sorted(comparator)
<span class="fc" id="L147">        MethodInvocation sortedCall = ast.newMethodInvocation();</span>
<span class="fc" id="L148">        sortedCall.setExpression(pipeline);</span>
<span class="fc" id="L149">        sortedCall.setName(ast.newSimpleName(&quot;sorted&quot;));</span>
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">        if (comparatorExpression != null &amp;&amp; !comparatorExpression.isEmpty()) {</span>
<span class="fc" id="L151">            sortedCall.arguments().add(createExpression(comparatorExpression));</span>
        }
<span class="fc" id="L153">        return sortedCall;</span>
    }
    
    @Override
    public Expression renderLimit(Expression pipeline, long maxSize) {
        // pipeline.limit(maxSize)
<span class="fc" id="L159">        MethodInvocation limitCall = ast.newMethodInvocation();</span>
<span class="fc" id="L160">        limitCall.setExpression(pipeline);</span>
<span class="fc" id="L161">        limitCall.setName(ast.newSimpleName(&quot;limit&quot;));</span>
<span class="fc" id="L162">        limitCall.arguments().add(ast.newNumberLiteral(String.valueOf(maxSize)));</span>
<span class="fc" id="L163">        return limitCall;</span>
    }
    
    @Override
    public Expression renderSkip(Expression pipeline, long count) {
        // pipeline.skip(count)
<span class="fc" id="L169">        MethodInvocation skipCall = ast.newMethodInvocation();</span>
<span class="fc" id="L170">        skipCall.setExpression(pipeline);</span>
<span class="fc" id="L171">        skipCall.setName(ast.newSimpleName(&quot;skip&quot;));</span>
<span class="fc" id="L172">        skipCall.arguments().add(ast.newNumberLiteral(String.valueOf(count)));</span>
<span class="fc" id="L173">        return skipCall;</span>
    }
    
    @Override
    public Expression renderForEach(Expression pipeline, List&lt;String&gt; bodyStatements, 
                                     String variableName, boolean ordered) {
        // pipeline.forEach(var -&gt; { statements }) oder forEachOrdered
<span class="fc" id="L180">        MethodInvocation forEachCall = ast.newMethodInvocation();</span>
<span class="fc" id="L181">        forEachCall.setExpression(pipeline);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        forEachCall.setName(ast.newSimpleName(ordered ? &quot;forEachOrdered&quot; : &quot;forEach&quot;));</span>
        
<span class="fc" id="L184">        LambdaExpression lambda = ast.newLambdaExpression();</span>
<span class="fc" id="L185">        VariableDeclarationFragment param = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L186">        param.setName(ast.newSimpleName(variableName));</span>
<span class="fc" id="L187">        lambda.parameters().add(param);</span>
        
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (bodyStatements.size() == 1) {</span>
            // Einzelne Expression -&gt; Expression-Body
<span class="fc" id="L191">            lambda.setBody(createExpression(bodyStatements.get(0)));</span>
<span class="fc" id="L192">        } else {</span>
            // Mehrere Statements -&gt; Block-Body
<span class="fc" id="L194">            Block block = ast.newBlock();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (String stmt : bodyStatements) {</span>
<span class="fc" id="L196">                block.statements().add(createStatement(stmt));</span>
            }
<span class="fc" id="L198">            lambda.setBody(block);</span>
        }
        
<span class="fc" id="L201">        forEachCall.arguments().add(lambda);</span>
<span class="fc" id="L202">        return forEachCall;</span>
    }
    
    @Override
    public Expression renderCollect(Expression pipeline, CollectTerminal terminal, String variableName) {
        // pipeline.collect(Collectors.toList()) etc.
<span class="fc" id="L208">        MethodInvocation collectCall = ast.newMethodInvocation();</span>
<span class="fc" id="L209">        collectCall.setExpression(pipeline);</span>
<span class="fc" id="L210">        collectCall.setName(ast.newSimpleName(&quot;collect&quot;));</span>
        
<span class="fc" id="L212">        MethodInvocation collector = ast.newMethodInvocation();</span>
<span class="fc" id="L213">        collector.setExpression(ast.newSimpleName(&quot;Collectors&quot;));</span>
        
<span class="pc bpc" id="L215" title="4 of 6 branches missed.">        switch (terminal.collectorType()) {</span>
            case TO_LIST:
<span class="fc" id="L217">                collector.setName(ast.newSimpleName(&quot;toList&quot;));</span>
<span class="fc" id="L218">                break;</span>
            case TO_SET:
<span class="fc" id="L220">                collector.setName(ast.newSimpleName(&quot;toSet&quot;));</span>
<span class="fc" id="L221">                break;</span>
            case TO_MAP:
<span class="nc" id="L223">                collector.setName(ast.newSimpleName(&quot;toMap&quot;));</span>
                // Key and value mappers würden hier hinzugefügt
<span class="nc" id="L225">                break;</span>
            case JOINING:
<span class="nc" id="L227">                collector.setName(ast.newSimpleName(&quot;joining&quot;));</span>
<span class="nc" id="L228">                break;</span>
            case GROUPING_BY:
<span class="nc" id="L230">                collector.setName(ast.newSimpleName(&quot;groupingBy&quot;));</span>
<span class="nc" id="L231">                break;</span>
            case CUSTOM:
            default:
<span class="nc" id="L234">                collector.setName(ast.newSimpleName(&quot;toList&quot;));</span>
        }
        
<span class="fc" id="L237">        collectCall.arguments().add(collector);</span>
<span class="fc" id="L238">        return collectCall;</span>
    }
    
    @Override
    public Expression renderReduce(Expression pipeline, ReduceTerminal terminal, String variableName) {
        // pipeline.reduce(identity, accumulator) etc.
<span class="fc" id="L244">        MethodInvocation reduceCall = ast.newMethodInvocation();</span>
<span class="fc" id="L245">        reduceCall.setExpression(pipeline);</span>
<span class="fc" id="L246">        reduceCall.setName(ast.newSimpleName(&quot;reduce&quot;));</span>
        
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (terminal.identity() != null) {</span>
<span class="fc" id="L249">            reduceCall.arguments().add(createExpression(terminal.identity()));</span>
        }
<span class="fc" id="L251">        reduceCall.arguments().add(createExpression(terminal.accumulator()));</span>
        
<span class="fc" id="L253">        return reduceCall;</span>
    }
    
    @Override
    public Expression renderCount(Expression pipeline) {
        // pipeline.count()
<span class="fc" id="L259">        MethodInvocation countCall = ast.newMethodInvocation();</span>
<span class="fc" id="L260">        countCall.setExpression(pipeline);</span>
<span class="fc" id="L261">        countCall.setName(ast.newSimpleName(&quot;count&quot;));</span>
<span class="fc" id="L262">        return countCall;</span>
    }
    
    @Override
    public Expression renderFind(Expression pipeline, boolean findFirst) {
        // pipeline.findFirst() oder pipeline.findAny()
<span class="fc" id="L268">        MethodInvocation findCall = ast.newMethodInvocation();</span>
<span class="fc" id="L269">        findCall.setExpression(pipeline);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        findCall.setName(ast.newSimpleName(findFirst ? &quot;findFirst&quot; : &quot;findAny&quot;));</span>
<span class="fc" id="L271">        return findCall;</span>
    }
    
    @Override
    public Expression renderMatch(Expression pipeline, MatchTerminal terminal, String variableName) {
        // pipeline.anyMatch/allMatch/noneMatch(var -&gt; predicate)
<span class="fc" id="L277">        MethodInvocation matchCall = ast.newMethodInvocation();</span>
<span class="fc" id="L278">        matchCall.setExpression(pipeline);</span>
        
<span class="pc bpc" id="L280" title="1 of 4 branches missed.">        switch (terminal.matchType()) {</span>
            case ANY_MATCH:
<span class="fc" id="L282">                matchCall.setName(ast.newSimpleName(&quot;anyMatch&quot;));</span>
<span class="fc" id="L283">                break;</span>
            case ALL_MATCH:
<span class="fc" id="L285">                matchCall.setName(ast.newSimpleName(&quot;allMatch&quot;));</span>
<span class="fc" id="L286">                break;</span>
            case NONE_MATCH:
<span class="fc" id="L288">                matchCall.setName(ast.newSimpleName(&quot;noneMatch&quot;));</span>
<span class="fc" id="L289">                break;</span>
            default:
<span class="nc" id="L291">                throw new IllegalArgumentException(&quot;Unknown match type: &quot; + terminal.matchType());</span>
        }
        
<span class="fc" id="L294">        matchCall.arguments().add(createLambda(variableName, terminal.predicate()));</span>
<span class="fc" id="L295">        return matchCall;</span>
    }
    
    // Helper methods
    
    private LambdaExpression createLambda(String paramName, String bodyExpression) {
<span class="fc" id="L301">        LambdaExpression lambda = ast.newLambdaExpression();</span>
<span class="fc" id="L302">        VariableDeclarationFragment param = ast.newVariableDeclarationFragment();</span>
<span class="fc" id="L303">        param.setName(ast.newSimpleName(paramName));</span>
<span class="fc" id="L304">        lambda.parameters().add(param);</span>
<span class="fc" id="L305">        lambda.setBody(createExpression(bodyExpression));</span>
<span class="fc" id="L306">        return lambda;</span>
    }
    
    private Expression createExpression(String expressionText) {
        // Parse expression string to AST node
<span class="pc bpc" id="L311" title="2 of 4 branches missed.">        if (expressionText == null || expressionText.isEmpty()) {</span>
<span class="nc" id="L312">            return ast.newNullLiteral();</span>
        }
        
        // Check for simple identifiers using Java's identifier validation
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (isValidJavaIdentifier(expressionText)) {</span>
<span class="fc" id="L317">            return ast.newSimpleName(expressionText);</span>
        }
        
        // For complex expressions: use ASTParser
<span class="fc" id="L321">        ASTParser parser = ASTParser.newParser(AST.getJLSLatest());</span>
<span class="fc" id="L322">        parser.setKind(ASTParser.K_EXPRESSION);</span>
<span class="fc" id="L323">        parser.setSource(expressionText.toCharArray());</span>
<span class="fc" id="L324">        ASTNode result = parser.createAST(null);</span>
        
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        if (result instanceof Expression) {</span>
<span class="fc" id="L327">            return (Expression) ASTNode.copySubtree(ast, result);</span>
        }
        
        // Expression could not be parsed; fail fast instead of silently mangling it
<span class="nc" id="L331">        throw new IllegalArgumentException(&quot;Unable to parse expression: &quot; + expressionText);</span>
    }
    
    /**
     * Validates if a string is a valid Java identifier.
     * Supports Unicode identifiers, underscores, and dollar signs.
     */
    private boolean isValidJavaIdentifier(String str) {
<span class="pc bpc" id="L339" title="2 of 4 branches missed.">        if (str == null || str.isEmpty()) {</span>
<span class="nc" id="L340">            return false;</span>
        }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (!Character.isJavaIdentifierStart(str.charAt(0))) {</span>
<span class="fc" id="L343">            return false;</span>
        }
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (int i = 1; i &lt; str.length(); i++) {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (!Character.isJavaIdentifierPart(str.charAt(i))) {</span>
<span class="fc" id="L347">                return false;</span>
            }
        }
<span class="fc" id="L350">        return true;</span>
    }
    
    private Statement createStatement(String statementText) {
        // Ensure statement ends with semicolon for proper parsing
<span class="fc" id="L355">        String normalizedStatement = statementText.trim();</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (!normalizedStatement.endsWith(&quot;;&quot;)) {</span>
<span class="fc" id="L357">            normalizedStatement += &quot;;&quot;;</span>
        }
        
<span class="fc" id="L360">        ASTParser parser = ASTParser.newParser(AST.getJLSLatest());</span>
<span class="fc" id="L361">        parser.setKind(ASTParser.K_STATEMENTS);</span>
<span class="fc" id="L362">        parser.setSource(normalizedStatement.toCharArray());</span>
<span class="fc" id="L363">        ASTNode result = parser.createAST(null);</span>
        
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if (result instanceof Block) {</span>
<span class="fc" id="L366">            Block block = (Block) result;</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (!block.statements().isEmpty()) {</span>
<span class="fc" id="L368">                return (Statement) ASTNode.copySubtree(ast, (Statement) block.statements().get(0));</span>
            }
        }
        
        // Statement could not be parsed; fail fast
<span class="nc" id="L373">        throw new IllegalArgumentException(&quot;Unable to parse statement: &quot; + statementText);</span>
    }
    
    /**
     * Returns the AST used by this renderer.
     */
    public AST getAST() {
<span class="fc" id="L380">        return ast;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>