<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IteratorWhileHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">IteratorWhileHandler.java</span></div><h1>IteratorWhileHandler.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import java.util.Set;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperation;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.functional.core.builder.LoopModelBuilder;
import org.sandbox.functional.core.model.ElementDescriptor;
import org.sandbox.functional.core.model.LoopModel;
import org.sandbox.functional.core.model.SourceDescriptor;
import org.sandbox.functional.core.terminal.ForEachTerminal;
import org.sandbox.functional.core.transformer.LoopModelTransformer;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.UseFunctionalCallFixCore;
import org.sandbox.jdt.internal.corext.fix.helper.IteratorLoopAnalyzer.SafetyAnalysis;
import org.sandbox.jdt.internal.corext.fix.helper.IteratorLoopBodyParser.ParsedBody;
import org.sandbox.jdt.internal.corext.fix.helper.IteratorPatternDetector.IteratorPattern;

/**
 * Handler for converting iterator-based while-loops to functional stream operations.
 * 
 * &lt;p&gt;This handler processes:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;while-iterator pattern: {@code Iterator&lt;T&gt; it = coll.iterator(); while (it.hasNext()) { T item = it.next(); ... }}&lt;/li&gt;
 *   &lt;li&gt;for-loop-iterator pattern: {@code for (Iterator&lt;T&gt; it = coll.iterator(); it.hasNext(); ) { T item = it.next(); ... }}&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;Uses the ULR pipeline: {@code LoopModelBuilder → LoopModel → LoopModelTransformer → ASTStreamRenderer}.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Naming Note:&lt;/b&gt; This class is named after the &lt;i&gt;source&lt;/i&gt; loop type (iterator while-loop),
 * not the target format. The architecture supports bidirectional transformations, so the name
 * describes what loop pattern this handler processes.&lt;/p&gt;
 * 
 * @see LoopModel
 * @see ASTStreamRenderer
 * @see LoopModelTransformer
 */
<span class="fc" id="L55">public class IteratorWhileHandler extends AbstractFunctionalCall&lt;ASTNode&gt; {</span>
    
<span class="fc" id="L57">    private final IteratorPatternDetector patternDetector = new IteratorPatternDetector();</span>
<span class="fc" id="L58">    private final IteratorLoopAnalyzer loopAnalyzer = new IteratorLoopAnalyzer();</span>
<span class="fc" id="L59">    private final IteratorLoopBodyParser bodyParser = new IteratorLoopBodyParser();</span>
    
    @Override
    public void find(UseFunctionalCallFixCore fixCore, CompilationUnit compilationUnit,
                     Set&lt;CompilationUnitRewriteOperation&gt; operations, Set&lt;ASTNode&gt; nodesProcessed) {
        
<span class="fc" id="L65">        compilationUnit.accept(new ASTVisitor() {</span>
            
            @Override
            public boolean visit(WhileStatement node) {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">                if (nodesProcessed.contains(node)) {</span>
<span class="nc" id="L70">                    return false;</span>
                }
                
                // Find previous statement for while-iterator pattern
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">                if (!IteratorPatternDetector.isStatementInBlock(node)) {</span>
<span class="nc" id="L75">                    return true;</span>
                }
                
<span class="fc" id="L78">                Block parentBlock = (Block) node.getParent();</span>
<span class="fc" id="L79">                Statement previousStmt = IteratorPatternDetector.findPreviousStatement(parentBlock, node);</span>
                
<span class="fc" id="L81">                IteratorPattern pattern = patternDetector.detectWhilePattern(node, previousStmt);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">                if (pattern == null) {</span>
<span class="fc" id="L83">                    return true;</span>
                }
                
<span class="fc bfc" id="L86" title="All 2 branches covered.">                if (!analyzeAndValidate(pattern)) {</span>
<span class="fc" id="L87">                    return true;</span>
                }
                
                // Mark both the iterator declaration and the while loop as processed
<span class="fc" id="L91">                nodesProcessed.add(previousStmt);</span>
<span class="fc" id="L92">                nodesProcessed.add(node);</span>
                
<span class="fc" id="L94">                ReferenceHolder&lt;ASTNode, Object&gt; holder = ReferenceHolder.create();</span>
<span class="fc" id="L95">                holder.put(node, pattern);</span>
                
<span class="fc" id="L97">                operations.add(fixCore.rewrite(node, holder));</span>
                
<span class="fc" id="L99">                return false;</span>
            }
            
            @Override
            public boolean visit(ForStatement node) {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">                if (nodesProcessed.contains(node)) {</span>
<span class="nc" id="L105">                    return false;</span>
                }
                
<span class="fc" id="L108">                IteratorPattern pattern = patternDetector.detectForLoopPattern(node);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (pattern == null) {</span>
<span class="fc" id="L110">                    return true;</span>
                }
                
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if (!analyzeAndValidate(pattern)) {</span>
<span class="nc" id="L114">                    return true;</span>
                }
                
<span class="fc" id="L117">                nodesProcessed.add(node);</span>
                
<span class="fc" id="L119">                ReferenceHolder&lt;ASTNode, Object&gt; holder = ReferenceHolder.create();</span>
<span class="fc" id="L120">                holder.put(node, pattern);</span>
                
<span class="fc" id="L122">                operations.add(fixCore.rewrite(node, holder));</span>
                
<span class="fc" id="L124">                return false;</span>
            }
        });
<span class="fc" id="L127">    }</span>
    
    /**
     * Analyzes and validates that the pattern can be safely converted.
     */
    private boolean analyzeAndValidate(IteratorPattern pattern) {
        // Analyze for safety
<span class="fc" id="L134">        SafetyAnalysis analysis = loopAnalyzer.analyze(pattern.loopBody, pattern.iteratorVariableName);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (!analysis.isSafe) {</span>
            // Cannot convert unsafe patterns
<span class="fc" id="L137">            return false;</span>
        }
        
        // Parse body to ensure it has the expected structure
<span class="fc" id="L141">        ParsedBody parsedBody = bodyParser.parse(pattern.loopBody, pattern.iteratorVariableName);</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (parsedBody == null) {</span>
            // Body doesn't match expected pattern
<span class="nc" id="L144">            return false;</span>
        }
        
<span class="fc" id="L147">        return true;</span>
    }
    
    @Override
    public void rewrite(UseFunctionalCallFixCore fixCore, ASTNode node, 
                        CompilationUnitRewrite cuRewrite, TextEditGroup group,
                        ReferenceHolder&lt;ASTNode, Object&gt; holder) throws CoreException {
        
<span class="fc" id="L155">        Object data = holder.get(node);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (!(data instanceof IteratorPattern)) {</span>
<span class="nc" id="L157">            return;</span>
        }
        
<span class="fc" id="L160">        IteratorPattern pattern = (IteratorPattern) data;</span>
<span class="fc" id="L161">        ParsedBody parsedBody = bodyParser.parse(pattern.loopBody, pattern.iteratorVariableName);</span>
        
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (parsedBody == null) {</span>
<span class="nc" id="L164">            return;</span>
        }
        
<span class="fc" id="L167">        AST ast = cuRewrite.getRoot().getAST();</span>
<span class="fc" id="L168">        ASTRewrite rewrite = cuRewrite.getASTRewrite();</span>
        
        // Build LoopModel using the ULR pipeline
<span class="fc" id="L171">        LoopModel model = buildLoopModel(pattern, parsedBody);</span>
        
        // Create renderer with the original loop body for AST node access
<span class="fc" id="L174">        ASTStreamRenderer renderer = new ASTStreamRenderer(ast, rewrite, cuRewrite.getRoot(), pattern.loopBody);</span>
        
        // Transform using LoopModelTransformer
<span class="fc" id="L177">        LoopModelTransformer&lt;Expression&gt; transformer = new LoopModelTransformer&lt;&gt;(renderer);</span>
<span class="fc" id="L178">        Expression streamExpression = transformer.transform(model);</span>
        
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (streamExpression != null) {</span>
            // For while pattern, also remove the iterator declaration
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (node instanceof WhileStatement) {</span>
<span class="fc" id="L183">                Block parentBlock = (Block) node.getParent();</span>
<span class="fc" id="L184">                Statement previousStmt = IteratorPatternDetector.findPreviousStatement(parentBlock, (Statement) node);</span>
                
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">                if (previousStmt != null) {</span>
<span class="fc" id="L187">                    rewrite.remove(previousStmt, group);</span>
                }
            }
            
            // Wrap in ExpressionStatement and replace the loop
<span class="fc" id="L192">            ExpressionStatement newStatement = ast.newExpressionStatement(streamExpression);</span>
<span class="fc" id="L193">            rewrite.replace(node, newStatement, group);</span>
        }
<span class="fc" id="L195">    }</span>
    
    /**
     * Builds a LoopModel from the iterator pattern using the ULR pipeline.
     * Uses COLLECTION source type since the iterator comes from collection.iterator().
     */
    private LoopModel buildLoopModel(IteratorPattern pattern, ParsedBody parsedBody) {
        // Build COLLECTION source descriptor using the collection expression
<span class="fc" id="L203">        SourceDescriptor source = new SourceDescriptor(</span>
<span class="fc" id="L204">            SourceDescriptor.SourceType.COLLECTION,</span>
<span class="fc" id="L205">            pattern.collectionExpression.toString(),</span>
<span class="fc" id="L206">            parsedBody.elementType</span>
        );
        
        // Build element descriptor for the loop variable
<span class="fc" id="L210">        ElementDescriptor element = new ElementDescriptor(</span>
<span class="fc" id="L211">            parsedBody.elementVariableName,</span>
<span class="fc" id="L212">            parsedBody.elementType,</span>
<span class="fc" id="L213">            true // is a collection element</span>
        );
        
        // Extract body statements as expression strings (strip trailing semicolons)
<span class="fc" id="L217">        List&lt;String&gt; bodyStatements = extractBodyStatementsAsStrings(parsedBody.actualBodyStatements);</span>
        
        // Build ForEachTerminal
<span class="fc" id="L220">        ForEachTerminal terminal = new ForEachTerminal(bodyStatements, false);</span>
        
        // Build and return LoopModel
<span class="fc" id="L223">        return new LoopModelBuilder()</span>
<span class="fc" id="L224">            .source(source)</span>
<span class="fc" id="L225">            .element(element)</span>
<span class="fc" id="L226">            .terminal(terminal)</span>
<span class="fc" id="L227">            .build();</span>
    }
    
    /**
     * Converts body statements to expression strings for the ForEachTerminal.
     * Trailing semicolons are stripped because ForEachTerminal / ASTStreamRenderer.createExpression()
     * expects pure expressions, not statements.
     */
    private List&lt;String&gt; extractBodyStatementsAsStrings(List&lt;Statement&gt; statements) {
<span class="fc" id="L236">        List&lt;String&gt; bodyStmts = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        for (Statement stmt : statements) {</span>
<span class="fc" id="L238">            bodyStmts.add(stripTrailingSemicolon(stmt.toString()));</span>
        }
<span class="fc" id="L240">        return bodyStmts;</span>
    }
    
    /**
     * Strips a trailing semicolon (and surrounding whitespace) from a statement string.
     */
    private static String stripTrailingSemicolon(String stmtStr) {
<span class="fc" id="L247">        String trimmed = stmtStr.trim();</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (trimmed.endsWith(&quot;;&quot;)) {</span>
<span class="fc" id="L249">            trimmed = trimmed.substring(0, trimmed.length() - 1).trim();</span>
        }
<span class="fc" id="L251">        return trimmed;</span>
    }
    
    @Override
    public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (afterRefactoring) {</span>
<span class="nc" id="L257">            return &quot;&quot;&quot;</span>
                   items.stream()
                       .forEach(item -&gt; System.out.println(item));
                   &quot;&quot;&quot;;
        } else {
<span class="nc" id="L262">            return &quot;&quot;&quot;</span>
                   Iterator&lt;String&gt; it = items.iterator();
                   while (it.hasNext()) {
                       String item = it.next();
                       System.out.println(item);
                   }
                   &quot;&quot;&quot;;
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>