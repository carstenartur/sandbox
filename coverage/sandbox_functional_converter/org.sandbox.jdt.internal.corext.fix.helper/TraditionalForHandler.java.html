<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TraditionalForHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">TraditionalForHandler.java</span></div><h1>TraditionalForHandler.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*******************************************************************************</span>
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.List;
import java.util.Set;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperation;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.functional.core.builder.LoopModelBuilder;
import org.sandbox.functional.core.model.ElementDescriptor;
import org.sandbox.functional.core.model.LoopModel;
import org.sandbox.functional.core.model.SourceDescriptor;
import org.sandbox.functional.core.terminal.ForEachTerminal;
import org.sandbox.functional.core.transformer.LoopModelTransformer;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.UseFunctionalCallFixCore;

/**
 * Handler for converting traditional index-based for-loops to IntStream.range() operations.
 * 
 * &lt;p&gt;This handler converts classic for-loops with integer counters to functional IntStream operations:&lt;/p&gt;
 * &lt;pre&gt;{@code
 * // Before:
 * for (int i = 0; i &lt; 10; i++) {
 *     System.out.println(i);
 * }
 * 
 * // After:
 * IntStream.range(0, 10).forEach(i -&gt; System.out.println(i));
 * }&lt;/pre&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Supported Patterns:&lt;/b&gt;&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Initializer: {@code int i = start} (single variable declaration with int type)&lt;/li&gt;
 *   &lt;li&gt;Condition: {@code i &lt; end} or {@code i &lt;= end} (comparison with loop variable)&lt;/li&gt;
 *   &lt;li&gt;Updater: {@code i++} or {@code ++i} (increment operator)&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Infrastructure:&lt;/b&gt;&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Uses {@link SourceDescriptor.SourceType#EXPLICIT_RANGE} for range representation&lt;/li&gt;
 *   &lt;li&gt;Leverages existing {@link ASTStreamRenderer} for IntStream.range() rendering&lt;/li&gt;
 *   &lt;li&gt;Builds {@link LoopModel} with {@link ForEachTerminal} for body statements&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Thread-Safety Guards:&lt;/b&gt;&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Nested loop guard&lt;/b&gt;: {@code isNestedInsideLoop()} rejects loops inside other loops
 *       to avoid interfering with the {@code EnhancedForHandler}'s scope analysis and to
 *       prevent generating IntStream calls inside lambdas where mutable loop state could be captured&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;Unconvertible statement detection&lt;/b&gt;: {@code containsUnconvertibleStatements()} rejects
 *       loops with {@code break}, {@code continue}, or {@code return} which cannot be expressed
 *       in lambda bodies&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;Sequential-only streams&lt;/b&gt;: Always generates {@code IntStream.range()} (sequential),
 *       never parallel streams, avoiding complex synchronization requirements&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;Synchronized block detection&lt;/b&gt;: Handled upstream by {@code JdtLoopExtractor} and
 *       {@code PreconditionsChecker}, which reject loops containing synchronized statements
 *       before they reach this handler&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;&lt;b&gt;Naming Note:&lt;/b&gt; This class is named after the &lt;i&gt;source&lt;/i&gt; loop type (traditional for-loop),
 * not the target format. The architecture supports bidirectional transformations, so the name
 * describes what loop pattern this handler processes.&lt;/p&gt;
 * 
 * @see SourceDescriptor.SourceType#EXPLICIT_RANGE
 * @see ASTStreamRenderer#renderSource(SourceDescriptor)
 */
<span class="fc" id="L84">public class TraditionalForHandler extends AbstractFunctionalCall&lt;ForStatement&gt; {</span>
    
    @Override
    public void find(UseFunctionalCallFixCore fixcore, CompilationUnit compilationUnit,
                     Set&lt;CompilationUnitRewriteOperation&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {
        
<span class="fc" id="L90">        compilationUnit.accept(new ASTVisitor() {</span>
            @Override
            public boolean visit(ForStatement node) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">                if (nodesprocessed.contains(node)) {</span>
<span class="fc" id="L94">                    return false;</span>
                }
                
                // Analyze the for-loop structure
<span class="fc" id="L98">                ForLoopPattern pattern = analyzeForLoop(node);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (pattern == null) {</span>
<span class="fc" id="L100">                    return true; // Not a convertible pattern, continue visiting</span>
                }
                
                // Mark as processed and add operation
<span class="fc" id="L104">                nodesprocessed.add(node);</span>
<span class="fc" id="L105">                ReferenceHolder&lt;ASTNode, Object&gt; holder = ReferenceHolder.create();</span>
<span class="fc" id="L106">                holder.put(node, pattern);</span>
<span class="fc" id="L107">                operations.add(fixcore.rewrite(node, holder));</span>
                
<span class="fc" id="L109">                return false; // Don't visit children of convertible loops</span>
            }
        });
<span class="fc" id="L112">    }</span>
    
    /**
     * Analyzes a ForStatement to determine if it follows the convertible pattern.
     * 
     * @param forStmt the ForStatement to analyze
     * @return a ForLoopPattern if convertible, null otherwise
     */
    private ForLoopPattern analyzeForLoop(ForStatement forStmt) {
        // Skip for-loops nested inside other loops to avoid converting
        // inner loops that the EnhancedForHandler expects to remain unchanged
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (isNestedInsideLoop(forStmt)) {</span>
<span class="fc" id="L124">            return null;</span>
        }
        
        // Check initializer: must be single variable declaration of type int
<span class="fc" id="L128">        List&lt;?&gt; initializers = forStmt.initializers();</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (initializers.size() != 1) {</span>
<span class="nc" id="L130">            return null;</span>
        }
        
<span class="fc" id="L133">        Object initObj = initializers.get(0);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (!(initObj instanceof VariableDeclarationExpression)) {</span>
<span class="nc" id="L135">            return null;</span>
        }
        
<span class="fc" id="L138">        VariableDeclarationExpression varDecl = (VariableDeclarationExpression) initObj;</span>
<span class="fc" id="L139">        Type type = varDecl.getType();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (!isPrimitiveInt(type)) {</span>
<span class="nc" id="L141">            return null;</span>
        }
        
<span class="fc" id="L144">        List&lt;?&gt; fragments = varDecl.fragments();</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (fragments.size() != 1) {</span>
<span class="nc" id="L146">            return null;</span>
        }
        
<span class="fc" id="L149">        VariableDeclarationFragment fragment = (VariableDeclarationFragment) fragments.get(0);</span>
<span class="fc" id="L150">        String loopVarName = fragment.getName().getIdentifier();</span>
<span class="fc" id="L151">        Expression startExpr = fragment.getInitializer();</span>
        
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (startExpr == null) {</span>
<span class="nc" id="L154">            return null;</span>
        }
        
        // Check condition: must be infix comparison with loop variable
<span class="fc" id="L158">        Expression condition = forStmt.getExpression();</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (!(condition instanceof InfixExpression)) {</span>
<span class="nc" id="L160">            return null;</span>
        }
        
<span class="fc" id="L163">        InfixExpression infixCond = (InfixExpression) condition;</span>
<span class="fc" id="L164">        InfixExpression.Operator operator = infixCond.getOperator();</span>
        
        // Check that left operand is the loop variable
<span class="fc" id="L167">        Expression leftOperand = infixCond.getLeftOperand();</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (!(leftOperand instanceof SimpleName)) {</span>
<span class="nc" id="L169">            return null;</span>
        }
        
<span class="fc" id="L172">        SimpleName leftName = (SimpleName) leftOperand;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (!leftName.getIdentifier().equals(loopVarName)) {</span>
<span class="nc" id="L174">            return null;</span>
        }
        
<span class="fc" id="L177">        Expression endExpr = infixCond.getRightOperand();</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (endExpr == null) {</span>
<span class="nc" id="L179">            return null;</span>
        }
        
<span class="fc" id="L182">        boolean inclusive = false;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (operator == InfixExpression.Operator.LESS) {</span>
            // i &lt; end  →  IntStream.range(start, end)
<span class="fc" id="L185">            inclusive = false;</span>
<span class="pc bnc" id="L186" title="All 2 branches missed.">        } else if (operator == InfixExpression.Operator.LESS_EQUALS) {</span>
            // i &lt;= end  →  IntStream.rangeClosed(start, end) or range(start, end+1)
<span class="nc" id="L188">            inclusive = true;</span>
<span class="nc" id="L189">        } else {</span>
<span class="nc" id="L190">            return null; // Unsupported operator</span>
        }
        
        // Check updater: must be i++ or ++i
<span class="fc" id="L194">        List&lt;?&gt; updaters = forStmt.updaters();</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (updaters.size() != 1) {</span>
<span class="nc" id="L196">            return null;</span>
        }
        
<span class="fc" id="L199">        Object updaterObj = updaters.get(0);</span>
<span class="fc" id="L200">        boolean isIncrement = false;</span>
        
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (updaterObj instanceof PostfixExpression) {</span>
<span class="fc" id="L203">            PostfixExpression postfix = (PostfixExpression) updaterObj;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (postfix.getOperator() == PostfixExpression.Operator.INCREMENT) {</span>
<span class="fc" id="L205">                Expression operand = postfix.getOperand();</span>
<span class="pc bpc" id="L206" title="2 of 4 branches missed.">                if (operand instanceof SimpleName &amp;&amp; ((SimpleName) operand).getIdentifier().equals(loopVarName)) {</span>
<span class="fc" id="L207">                    isIncrement = true;</span>
                }
            }
<span class="pc bnc" id="L210" title="All 2 branches missed.">        } else if (updaterObj instanceof PrefixExpression) {</span>
<span class="nc" id="L211">            PrefixExpression prefix = (PrefixExpression) updaterObj;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (prefix.getOperator() == PrefixExpression.Operator.INCREMENT) {</span>
<span class="nc" id="L213">                Expression operand = prefix.getOperand();</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">                if (operand instanceof SimpleName &amp;&amp; ((SimpleName) operand).getIdentifier().equals(loopVarName)) {</span>
<span class="nc" id="L215">                    isIncrement = true;</span>
                }
            }
        }
        
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (!isIncrement) {</span>
<span class="nc" id="L221">            return null;</span>
        }
        
        // Extract body
<span class="fc" id="L225">        Statement body = forStmt.getBody();</span>
        
        // Check if body contains unconvertible statements (break, continue, return)
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (containsUnconvertibleStatements(body)) {</span>
<span class="nc" id="L229">            return null;</span>
        }
        
        // Issue #670: Check if the index variable is used in the body for complex
        // patterns like a[i+1], a[i-1], or i%2 that indicate neighbor access or
        // non-trivial index semantics. These patterns suggest the loop relies on
        // index arithmetic that may not be safely convertible.
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (usesIndexBeyondSimpleAccess(body, loopVarName)) {</span>
<span class="fc" id="L237">            return null;</span>
        }
        
<span class="fc" id="L240">        return new ForLoopPattern(loopVarName, startExpr, endExpr, inclusive, body);</span>
    }
    
    /**
     * Checks if a Type represents primitive int.
     */
    private boolean isPrimitiveInt(Type type) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (type instanceof PrimitiveType) {</span>
<span class="fc" id="L248">            PrimitiveType primType = (PrimitiveType) type;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            return primType.getPrimitiveTypeCode() == PrimitiveType.INT;</span>
        }
<span class="nc" id="L251">        return false;</span>
    }
    
    /**
     * Checks if the for-loop is nested inside another loop (enhanced-for, while, for, do-while).
     * Nested traditional for-loops are skipped to avoid interfering with the EnhancedForHandler's
     * analysis of outer enhanced-for loops.
     */
    private boolean isNestedInsideLoop(ForStatement forStmt) {
<span class="fc" id="L260">        ASTNode parent = forStmt.getParent();</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        while (parent != null) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (parent instanceof EnhancedForStatement</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                    || parent instanceof ForStatement</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                    || parent instanceof WhileStatement</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">                    || parent instanceof DoStatement) {</span>
<span class="fc" id="L266">                return true;</span>
            }
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">            if (parent instanceof MethodDeclaration || parent instanceof TypeDeclaration) {</span>
<span class="nc" id="L269">                break;</span>
            }
<span class="fc" id="L271">            parent = parent.getParent();</span>
        }
<span class="fc" id="L273">        return false;</span>
    }
    
    /**
     * Checks if the loop body contains unconvertible statements.
     * Statements containing break, continue, or return cannot be converted to lambda.
     */
    private boolean containsUnconvertibleStatements(Statement body) {
<span class="fc" id="L281">        final boolean[] hasUnconvertible = {false};</span>
        
<span class="fc" id="L283">        body.accept(new ASTVisitor() {</span>
            @Override
            public boolean visit(BreakStatement node) {
<span class="nc" id="L286">                hasUnconvertible[0] = true;</span>
<span class="nc" id="L287">                return false;</span>
            }
            
            @Override
            public boolean visit(ContinueStatement node) {
<span class="nc" id="L292">                hasUnconvertible[0] = true;</span>
<span class="nc" id="L293">                return false;</span>
            }
            
            @Override
            public boolean visit(ReturnStatement node) {
<span class="nc" id="L298">                hasUnconvertible[0] = true;</span>
<span class="nc" id="L299">                return false;</span>
            }
        });
        
<span class="fc" id="L303">        return hasUnconvertible[0];</span>
    }
    
    /**
     * Checks if the index variable is used in the loop body for complex patterns
     * that go beyond simple counter semantics.
     * 
     * &lt;p&gt;Detects the index variable participating in arithmetic InfixExpressions
     * (e.g., {@code i + 1}, {@code i - 1}, {@code i * 2}, {@code i % 2}).
     * This also catches array/list neighbor access patterns like {@code a[i+1]}
     * because the subscript expression {@code i+1} is itself an InfixExpression.&lt;/p&gt;
     * 
     * &lt;p&gt;These patterns indicate the loop relies on index relationships between
     * iterations, which may not be safely convertible to stream operations.&lt;/p&gt;
     * 
     * @param body the loop body statement
     * @param indexVarName the name of the index variable
     * @return true if the index is used in complex patterns
     * 
     * @see &lt;a href=&quot;https://github.com/carstenartur/sandbox/issues/670&quot;&gt;Issue #670&lt;/a&gt;
     */
    private boolean usesIndexBeyondSimpleAccess(Statement body, String indexVarName) {
<span class="fc" id="L325">        final boolean[] hasComplexUsage = {false};</span>
        
<span class="fc" id="L327">        body.accept(new ASTVisitor() {</span>
            @Override
            public boolean visit(InfixExpression node) {
                // Check if the index variable is used in arithmetic operations
                // like i+1, i-1, i*2, i%2
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (isIndexInArithmeticExpression(node, indexVarName)) {</span>
<span class="fc" id="L333">                    hasComplexUsage[0] = true;</span>
<span class="fc" id="L334">                    return false;</span>
                }
<span class="fc" id="L336">                return true;</span>
            }
        });
        
<span class="fc" id="L340">        return hasComplexUsage[0];</span>
    }
    
    /**
     * Checks if an InfixExpression uses the index variable in arithmetic.
     * Detects patterns: i+1, i-1, i*2, i%2, etc., including nested and chained
     * arithmetic expressions (e.g., (i + 1) + offset, multiplier * (i - 1)).
     */
    private boolean isIndexInArithmeticExpression(InfixExpression expr, String indexVarName) {
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (!isArithmeticOperator(expr.getOperator())) {</span>
<span class="fc" id="L350">            return false;</span>
        }

        // Recursively inspect all operands (left, right, and extended) for
        // arithmetic usage of the index variable.
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (containsIndexInArithmeticOperand(expr.getLeftOperand(), indexVarName)) {</span>
<span class="fc" id="L356">            return true;</span>
        }
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (containsIndexInArithmeticOperand(expr.getRightOperand(), indexVarName)) {</span>
<span class="nc" id="L359">            return true;</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L362">        List&lt;Expression&gt; extended = expr.extendedOperands();</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        for (Expression operand : extended) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (containsIndexInArithmeticOperand(operand, indexVarName)) {</span>
<span class="nc" id="L365">                return true;</span>
            }
        }
<span class="fc" id="L368">        return false;</span>
    }

    /**
     * Returns {@code true} if the given operator is an arithmetic operator
     * relevant for index arithmetic detection.
     */
    private boolean isArithmeticOperator(InfixExpression.Operator op) {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        return op == InfixExpression.Operator.PLUS</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                || op == InfixExpression.Operator.MINUS</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                || op == InfixExpression.Operator.TIMES</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">                || op == InfixExpression.Operator.DIVIDE</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                || op == InfixExpression.Operator.REMAINDER;</span>
    }

    /**
     * Recursively checks whether the given expression contains an arithmetic
     * use of the index variable.
     */
    private boolean containsIndexInArithmeticOperand(Expression expr, String indexVarName) {
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (expr == null) {</span>
<span class="nc" id="L389">            return false;</span>
        }

<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (expr instanceof SimpleName) {</span>
<span class="fc" id="L393">            return ((SimpleName) expr).getIdentifier().equals(indexVarName);</span>
        }

<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (expr instanceof ParenthesizedExpression) {</span>
<span class="nc" id="L397">            Expression inner = ((ParenthesizedExpression) expr).getExpression();</span>
<span class="nc" id="L398">            return containsIndexInArithmeticOperand(inner, indexVarName);</span>
        }

<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (expr instanceof InfixExpression infix) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (!isArithmeticOperator(infix.getOperator())) {</span>
<span class="nc" id="L403">                return false;</span>
            }
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (containsIndexInArithmeticOperand(infix.getLeftOperand(), indexVarName)) {</span>
<span class="nc" id="L406">                return true;</span>
            }
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (containsIndexInArithmeticOperand(infix.getRightOperand(), indexVarName)) {</span>
<span class="nc" id="L409">                return true;</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L412">            List&lt;Expression&gt; extended = infix.extendedOperands();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            for (Expression operand : extended) {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (containsIndexInArithmeticOperand(operand, indexVarName)) {</span>
<span class="nc" id="L415">                    return true;</span>
                }
            }
        }

<span class="fc" id="L420">        return false;</span>
    }
    
    @Override
    public void rewrite(UseFunctionalCallFixCore upp, ForStatement visited,
                        CompilationUnitRewrite cuRewrite, TextEditGroup group,
                        ReferenceHolder&lt;ASTNode, Object&gt; data) throws CoreException {
        
<span class="fc" id="L428">        Object patternObj = data.get(visited);</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (!(patternObj instanceof ForLoopPattern pattern)) {</span>
<span class="nc" id="L430">            return;</span>
        }
        
<span class="fc" id="L433">        AST ast = cuRewrite.getRoot().getAST();</span>
<span class="fc" id="L434">        ASTRewrite rewrite = cuRewrite.getASTRewrite();</span>
        
        // Build LoopModel
<span class="fc" id="L437">        LoopModel model = buildLoopModel(pattern, ast);</span>
        
        // Create renderer
<span class="fc" id="L440">        ASTStreamRenderer renderer = new ASTStreamRenderer(ast, rewrite, cuRewrite.getRoot(), pattern.body());</span>
        
        // Transform using LoopModelTransformer
<span class="fc" id="L443">        LoopModelTransformer&lt;Expression&gt; transformer = new LoopModelTransformer&lt;&gt;(renderer);</span>
<span class="fc" id="L444">        Expression streamExpression = transformer.transform(model);</span>
        
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (streamExpression != null) {</span>
            // Wrap in ExpressionStatement
<span class="fc" id="L448">            ExpressionStatement newStatement = ast.newExpressionStatement(streamExpression);</span>
<span class="fc" id="L449">            rewrite.replace(visited, newStatement, group);</span>
            
            // Add IntStream import
<span class="fc" id="L452">            cuRewrite.getImportRewrite().addImport(&quot;java.util.stream.IntStream&quot;);</span>
        }
<span class="fc" id="L454">    }</span>
    
    /**
     * Builds a LoopModel from the analyzed ForLoopPattern.
     */
    private LoopModel buildLoopModel(ForLoopPattern pattern, AST ast) {
        // Get start and end expressions as strings
<span class="fc" id="L461">        String startStr = pattern.startExpr().toString();</span>
<span class="fc" id="L462">        String endStr = pattern.endExpr().toString();</span>
        
        // Adjust end expression for inclusive range (i &lt;= end)
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">        if (pattern.inclusive()) {</span>
            // For i &lt;= end, we need IntStream.range(start, (end) + 1)
            // Parenthesize end expression to preserve operator precedence
<span class="nc" id="L468">            endStr = &quot;(&quot; + endStr + &quot;) + 1&quot;;</span>
        }
        
        // Build EXPLICIT_RANGE source descriptor
<span class="fc" id="L472">        String rangeExpression = startStr + &quot;,&quot; + endStr;</span>
<span class="fc" id="L473">        SourceDescriptor source = new SourceDescriptor(</span>
<span class="fc" id="L474">            SourceDescriptor.SourceType.EXPLICIT_RANGE,</span>
<span class="fc" id="L475">            rangeExpression,</span>
<span class="fc" id="L476">            &quot;int&quot;</span>
        );
        
        // Build element descriptor for the loop variable
<span class="fc" id="L480">        ElementDescriptor element = new ElementDescriptor(</span>
<span class="fc" id="L481">            pattern.loopVarName(),</span>
<span class="fc" id="L482">            &quot;int&quot;,</span>
<span class="fc" id="L483">            false // not a collection element</span>
        );
        
        // Extract body statements and convert to strings
<span class="fc" id="L487">        List&lt;String&gt; bodyStatements = extractBodyStatementsAsStrings(pattern.body());</span>
        
        // Build ForEachTerminal
<span class="fc" id="L490">        ForEachTerminal terminal = new ForEachTerminal(bodyStatements, false); // uses forEach (not forEachOrdered)</span>
        
        // Build and return LoopModel
<span class="fc" id="L493">        return new LoopModelBuilder()</span>
<span class="fc" id="L494">            .source(source)</span>
<span class="fc" id="L495">            .element(element)</span>
<span class="fc" id="L496">            .terminal(terminal)</span>
<span class="fc" id="L497">            .build();</span>
    }
    
    /**
     * Extracts statements from the loop body and converts them to expression strings.
     * Trailing semicolons are stripped because ForEachTerminal / ASTStreamRenderer.createExpression()
     * expects pure expressions, not statements.  This matches how
     * {@code JdtLoopExtractor.addSimpleForEachTerminal()} produces body strings for
     * the existing EnhancedForHandler.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private List&lt;String&gt; extractBodyStatementsAsStrings(Statement body) {
<span class="fc" id="L509">        return ExpressionHelper.bodyStatementsToStrings(body);</span>
    }
    
    @Override
    public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (afterRefactoring) {</span>
<span class="nc" id="L515">            return &quot;IntStream.range(0, 10).forEach(i -&gt; System.out.println(i));\n&quot;;</span>
        }
<span class="nc" id="L517">        return &quot;for (int i = 0; i &lt; 10; i++)\n    System.out.println(i);\n&quot;;</span>
    }
    
    /**
     * Immutable representation of an analyzed traditional for-loop pattern.
     *
     * @param loopVarName the loop variable name (e.g. {@code &quot;i&quot;})
     * @param startExpr the start expression (e.g. {@code 0})
     * @param endExpr the end expression (e.g. {@code list.size()})
     * @param inclusive {@code true} for {@code &lt;=}, {@code false} for {@code &lt;}
     * @param body the loop body statement
     */
    private record ForLoopPattern(String loopVarName, Expression startExpr, Expression endExpr,
                                  boolean inclusive, Statement body) {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>