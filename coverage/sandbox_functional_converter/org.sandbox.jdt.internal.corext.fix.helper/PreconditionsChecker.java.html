<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PreconditionsChecker.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">PreconditionsChecker.java</span></div><h1>PreconditionsChecker.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Set;

import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.sandbox.jdt.internal.common.AstProcessorBuilder;
import org.sandbox.jdt.internal.common.ReferenceHolder;

import java.util.*;

/**
 * Analyzes a loop statement to check various preconditions for safe refactoring
 * to stream operations. Uses AstProcessorBuilder for cleaner AST traversal.
 * 
 * &lt;p&gt;
 * This class is final to prevent subclassing and potential finalizer attacks,
 * since the constructor calls analysis methods that could potentially throw
 * exceptions.
 * &lt;/p&gt;
 */
public final class PreconditionsChecker {
	private final Statement loop;
//    private final CompilationUnit compilationUnit;
<span class="fc" id="L39">	private final Set&lt;VariableDeclarationFragment&gt; innerVariables = new HashSet&lt;&gt;();</span>
<span class="fc" id="L40">	private boolean containsBreak = false;</span>
<span class="fc" id="L41">	private boolean containsLabeledContinue = false;</span>
<span class="fc" id="L42">	private boolean containsReturn = false;</span>
<span class="fc" id="L43">	private boolean throwsException = false;</span>
<span class="fc" id="L44">	private boolean containsNEFs = false;</span>
<span class="fc" id="L45">	private boolean containsNestedLoop = false;</span>
<span class="fc" id="L46">	private boolean hasReducer = false;</span>
<span class="fc" id="L47">	private Statement reducerStatement = null;</span>
<span class="fc" id="L48">	private boolean isAnyMatchPattern = false;</span>
<span class="fc" id="L49">	private boolean isNoneMatchPattern = false;</span>
<span class="fc" id="L50">	private boolean isAllMatchPattern = false;</span>
<span class="fc" id="L51">	private boolean hasCollectPattern = false;</span>
<span class="fc" id="L52">	private Statement collectStatement = null;</span>
<span class="fc" id="L53">	private String collectTargetVariable = null;</span>
	/**
	 * Constructor for PreconditionsChecker.
	 * 
	 * @param loop            the statement containing the loop to analyze (must not
	 *                        be null)
	 * @param compilationUnit the compilation unit containing the loop
	 */
<span class="fc" id="L61">	public PreconditionsChecker(Statement loop, CompilationUnit compilationUnit) {</span>
		// Set loop field first - if null, we'll handle it gracefully in the catch block
<span class="fc" id="L63">		this.loop = loop;</span>
//        this.compilationUnit = compilationUnit;

		// Analyze the loop in a try-catch to prevent partial initialization
		// if any exception occurs during analysis
		try {
			// Perform analysis only if loop is not null
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			if (loop != null) {</span>
<span class="fc" id="L71">				analyzeLoop();</span>
<span class="fc" id="L72">			} else {</span>
				// Null loop - treat as unsafe to refactor
<span class="nc" id="L74">				this.containsBreak = true;</span>
			}
<span class="nc" id="L76">		} catch (Exception e) {</span>
			// If analysis fails, treat loop as unsafe to refactor
			// Set flags to prevent conversion
<span class="nc" id="L79">			this.containsBreak = true; // Conservatively block conversion</span>
		}
<span class="fc" id="L81">	}</span>

	/**
	 * Checks if the loop is safe to refactor to stream operations.
	 * 
	 * &lt;p&gt;
	 * A loop is safe to refactor if it meets all of the following conditions:
	 * &lt;ul&gt;
	 * &lt;li&gt;Does not throw exceptions (throwsException == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain break statements (containsBreak == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain labeled continue statements (containsLabeledContinue ==
	 * false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain return statements OR contains only pattern-matching
	 * returns (anyMatch/noneMatch/allMatch)&lt;/li&gt;
	 * &lt;li&gt;All variables are effectively final (containsNEFs == false)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Note on continue statements:&lt;/b&gt; Unlabeled continue statements are allowed
	 * and will be converted to filter operations by StreamPipelineBuilder. Only
	 * labeled continues are rejected because they cannot be safely translated to
	 * stream operations.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Pattern-matching early returns:&lt;/b&gt; Early returns matching anyMatch,
	 * noneMatch, or allMatch patterns are allowed because they can be converted to
	 * the corresponding terminal stream operations.
	 * &lt;/p&gt;
	 * 
	 * @return true if the loop can be safely converted to stream operations, false
	 *         otherwise
	 * @see StreamPipelineBuilder#parseLoopBody
	 */
	public boolean isSafeToRefactor() {
		// Allow early returns if they match anyMatch/noneMatch/allMatch patterns
<span class="pc bpc" id="L117" title="7 of 8 branches missed.">		boolean allowedReturn = containsReturn &amp;&amp; (isAnyMatchPattern || isNoneMatchPattern || isAllMatchPattern);</span>
		// Note: Unlabeled continues are allowed and will be converted to filters by
		// StreamPipelineBuilder
		// Only labeled continues are rejected here
<span class="pc bpc" id="L121" title="6 of 10 branches missed.">		return !throwsException &amp;&amp; !containsBreak &amp;&amp; !containsLabeledContinue &amp;&amp; (!containsReturn || allowedReturn)</span>
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">				&amp;&amp; !containsNEFs &amp;&amp; !containsNestedLoop;</span>
	}

	/**
	 * Checks if the loop contains a reducer pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for accumulator patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;i++, i--, ++i, --i&lt;/li&gt;
	 * &lt;li&gt;sum += x, product *= x, count -= 1&lt;/li&gt;
	 * &lt;li&gt;Other compound assignments (|=, &amp;=, etc.)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a reducer pattern is detected, false otherwise
	 * 
	 * @see #getReducer()
	 */
	public boolean isReducer() {
<span class="nc" id="L141">		return hasReducer;</span>
	}

	/**
	 * Returns the statement containing the reducer pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple reducers exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the reducer, or null if no reducer was
	 *         detected
	 * 
	 * @see #isReducer()
	 */
	public Statement getReducer() {
<span class="nc" id="L158">		return reducerStatement;</span>
	}

	/**
	 * Checks if the loop matches the anyMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AnyMatch pattern: loop contains {@code if (condition) return true;}
	 * &lt;/p&gt;
	 * 
	 * @return true if anyMatch pattern is detected
	 */
	public boolean isAnyMatchPattern() {
<span class="fc" id="L171">		return isAnyMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the noneMatch pattern.
	 * 
	 * &lt;p&gt;
	 * NoneMatch pattern: loop contains {@code if (condition) return false;}
	 * &lt;/p&gt;
	 * 
	 * @return true if noneMatch pattern is detected
	 */
	public boolean isNoneMatchPattern() {
<span class="fc" id="L184">		return isNoneMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the allMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AllMatch pattern: loop contains {@code if (condition) return false;} but the
	 * method returns true after the loop, or {@code if (!condition) return false;}
	 * checking all elements meet a condition.
	 * &lt;/p&gt;
	 * 
	 * @return true if allMatch pattern is detected
	 */
	public boolean isAllMatchPattern() {
<span class="fc" id="L199">		return isAllMatchPattern;</span>
	}

	/**
	 * Checks if the loop contains a collect pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for collection accumulation patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;result.add(item)&lt;/li&gt;
	 * &lt;li&gt;set.add(value)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a collect pattern is detected, false otherwise
	 * 
	 * @see #getCollectStatement()
	 * @see #getCollectTarget()
	 */
	public boolean isCollectPattern() {
<span class="nc" id="L218">		return hasCollectPattern;</span>
	}

	/**
	 * Returns the statement containing the collect pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple collect statements exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the collect operation, or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public Statement getCollectStatement() {
<span class="nc" id="L234">		return collectStatement;</span>
	}

	/**
	 * Returns the target collection variable name for the collect pattern.
	 * 
	 * @return the target variable name (e.g., &quot;result&quot;), or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public String getCollectTarget() {
<span class="nc" id="L245">		return collectTargetVariable;</span>
	}

	/**
	 * Analyzes the loop statement to identify relevant elements for refactoring.
	 * 
	 * &lt;p&gt;
	 * This method uses {@link AstProcessorBuilder} for cleaner and more
	 * maintainable AST traversal. It performs the following analysis:
	 * &lt;ul&gt;
	 * &lt;li&gt;Collects variable declarations within the loop&lt;/li&gt;
	 * &lt;li&gt;Detects control flow statements (break, continue, return, throw)&lt;/li&gt;
	 * &lt;li&gt;Identifies reducer patterns (i++, sum += x, etc.)&lt;/li&gt;
	 * &lt;li&gt;Detects early return patterns (anyMatch, noneMatch, allMatch)&lt;/li&gt;
	 * &lt;li&gt;Checks if variables are effectively final&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The analysis results are stored in instance variables that can be queried via
	 * getter methods like {@link #isSafeToRefactor()}, {@link #isReducer()}, etc.
	 * &lt;/p&gt;
	 */
	private void analyzeLoop() {
<span class="fc" id="L268">		AstProcessorBuilder&lt;String, Object&gt; builder = AstProcessorBuilder.with(new ReferenceHolder&lt;String, Object&gt;());</span>

<span class="fc" id="L270">		builder.onVariableDeclarationFragment((node, h) -&gt; {</span>
<span class="fc" id="L271">			innerVariables.add(node);</span>
<span class="fc" id="L272">			return true;</span>
<span class="fc" id="L273">		}).onBreakStatement((node, h) -&gt; {</span>
<span class="nc" id="L274">			containsBreak = true;</span>
<span class="nc" id="L275">			return true;</span>
<span class="fc" id="L276">		}).onLabeledContinue((node, h) -&gt; {</span>
			// Labeled continue should prevent conversion (unlabeled continues are allowed)
<span class="nc" id="L278">			containsLabeledContinue = true;</span>
<span class="nc" id="L279">			return true;</span>
<span class="fc" id="L280">		}).onReturnStatement((node, h) -&gt; {</span>
<span class="nc" id="L281">			containsReturn = true;</span>
<span class="nc" id="L282">			return true;</span>
<span class="fc" id="L283">		}).onThrowStatement((node, h) -&gt; {</span>
<span class="nc" id="L284">			throwsException = true;</span>
<span class="nc" id="L285">			return true;</span>
<span class="fc" id="L286">		}).onEnhancedForStatement((node, h) -&gt; {</span>
			// If we encounter another EnhancedForStatement inside the loop body,
			// it's a nested loop - mark as not convertible
			// We check that this is NOT the same node as the outer loop
<span class="nc bnc" id="L290" title="All 2 branches missed.">			if (node != loop) {</span>
<span class="nc" id="L291">				containsNestedLoop = true;</span>
			}
<span class="nc" id="L293">			return true;</span>
<span class="fc" id="L294">		}).onForStatement((node, h) -&gt; {</span>
			// Traditional for loops inside the enhanced-for also prevent conversion
<span class="nc" id="L296">			containsNestedLoop = true;</span>
<span class="nc" id="L297">			return true;</span>
<span class="fc" id="L298">		}).onWhileStatement((node, h) -&gt; {</span>
			// While loops inside the enhanced-for also prevent conversion
<span class="nc" id="L300">			containsNestedLoop = true;</span>
<span class="nc" id="L301">			return true;</span>
<span class="fc" id="L302">		}).onDoStatement((node, h) -&gt; {</span>
			// Do-while loops inside the enhanced-for also prevent conversion
<span class="nc" id="L304">			containsNestedLoop = true;</span>
<span class="nc" id="L305">			return true;</span>
<span class="fc" id="L306">		}).onTryStatement((node, h) -&gt; {</span>
			// Try-catch blocks inside the loop prevent conversion
			// (exception handling in lambdas is complex)
<span class="nc" id="L309">			containsNEFs = true;</span>
<span class="nc" id="L310">			return true;</span>
<span class="fc" id="L311">		}).onSwitchStatement((node, h) -&gt; {</span>
			// Switch statements inside the loop prevent conversion
<span class="nc" id="L313">			containsNEFs = true;</span>
<span class="nc" id="L314">			return true;</span>
<span class="fc" id="L315">		}).onSynchronizedStatement((node, h) -&gt; {</span>
			// Synchronized blocks inside the loop prevent conversion
<span class="nc" id="L317">			containsNEFs = true;</span>
<span class="nc" id="L318">			return true;</span>
<span class="fc" id="L319">		}).onCompoundAssignment((node, h) -&gt; {</span>
			// Compound assignments: +=, -=, *=, /=, |=, &amp;=, etc.
<span class="nc" id="L321">			markAsReducer(node);</span>
<span class="nc" id="L322">			return true;</span>
<span class="fc" id="L323">		}).onAssignment((node, h) -&gt; {</span>
			// Check for Math.max/Math.min patterns: max = Math.max(max, x)
<span class="nc bnc" id="L325" title="All 4 branches missed.">			if (node.getOperator() == Assignment.Operator.ASSIGN &amp;&amp; isMathMinMaxReducerPattern(node)) {</span>
<span class="nc" id="L326">				markAsReducer(node);</span>
			}
<span class="nc" id="L328">			return true;</span>
<span class="fc" id="L329">		}).onPostfixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect i++, i--
<span class="nc" id="L331">			markAsReducer(node);</span>
<span class="nc" id="L332">			return true;</span>
<span class="fc" id="L333">		}).onPrefixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect ++i, --i
<span class="nc" id="L335">			markAsReducer(node);</span>
<span class="nc" id="L336">			return true;</span>
<span class="fc" id="L337">		}).onMethodInvocation((node, h) -&gt; {</span>
			// Detect collection.add() patterns for collect operation
<span class="nc bnc" id="L339" title="All 2 branches missed.">			if (isCollectPattern(node)) {</span>
<span class="nc" id="L340">				markAsCollectPattern(node);</span>
			}
<span class="nc" id="L342">			return true;</span>
		});

		// First, analyze just the loop itself
<span class="fc" id="L346">		builder.build(loop);</span>

		// Save the containsReturn flag state after analyzing only the loop body
		// This is important because we want to distinguish between:
		// 1. Returns INSIDE the loop (which may prevent conversion, except for match patterns)
		// 2. Returns AFTER the loop (which are just part of the method and shouldn't prevent conversion)
<span class="fc" id="L352">		boolean containsReturnInsideLoop = containsReturn;</span>

		// Then, if the loop is inside a Block, analyze only the immediately following
		// statement (if any). This lets us detect patterns that depend on the statement
		// right after the loop without pulling in unrelated statements.
<span class="fc" id="L357">		ASTNode parent = loop.getParent();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">		if (parent instanceof Block) {</span>
<span class="fc" id="L359">			Block block = (Block) parent;</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L361">			List&lt;Statement&gt; statements = block.statements();</span>
<span class="fc" id="L362">			int loopIndex = statements.indexOf(loop);</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">			if (loopIndex != -1 &amp;&amp; loopIndex + 1 &lt; statements.size()) {</span>
<span class="fc" id="L364">				Statement followingStatement = statements.get(loopIndex + 1);</span>
<span class="fc" id="L365">				builder.build(followingStatement);</span>
			}
		}

		// Detect anyMatch/noneMatch patterns
		// This needs to see if there's a return statement after the loop,
		// so containsReturn may be true from analyzing the following statement
<span class="fc" id="L372">		detectEarlyReturnPatterns();</span>

		// Restore the containsReturn flag to only reflect returns INSIDE the loop
		// This ensures that isSafeToRefactor() only rejects loops with returns inside,
		// not loops followed by return statements (like reducers)
<span class="fc" id="L377">		containsReturn = containsReturnInsideLoop;</span>

<span class="fc" id="L379">		analyzeEffectivelyFinalVariables();</span>
<span class="fc" id="L380">	}</span>

	/**
	 * Checks if variables declared within the loop are effectively final.
	 * 
	 * &lt;p&gt;
	 * A variable is effectively final if it is never modified after its
	 * initialization. This is important for stream operations because lambda
	 * expressions can only capture effectively final variables from their enclosing
	 * scope.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * Sets {@link #containsNEFs} to true if any non-effectively-final variable is
	 * found.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Important:&lt;/b&gt; Variables declared inside the loop body that are modified
	 * within the same loop iteration are NOT checked here. Such variables will be
	 * converted to map operations in the stream pipeline. Only variables that would
	 * need to be captured from an outer scope are relevant for this check.
	 * &lt;/p&gt;
	 */
	private void analyzeEffectivelyFinalVariables() {
		// Variables declared INSIDE the loop body are allowed to be modified,
		// as they will be converted to map operations in the stream pipeline.
		// We need to check for variables declared OUTSIDE the loop that
		// are used inside the loop body - these must be effectively final
		// to be captured by a lambda.
		//
		// EXCEPTION: For reducer patterns (hasReducer == true), the accumulator
		// variable doesn't need to be effectively final because it will become
		// the reduce accumulator, not a captured variable in a lambda.
		
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">		if (!(loop instanceof EnhancedForStatement)) {</span>
<span class="nc" id="L416">			return;</span>
		}
		
		// If this is a reducer pattern, the accumulator variable is allowed
		// to be non-effectively-final since it will be part of the reduce operation
		// and won't need to be captured by a lambda.
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">		if (hasReducer) {</span>
			// For reducers, we don't check effectively final because the
			// modified variable becomes the reduce accumulator, not a captured var
<span class="nc" id="L425">			return;</span>
		}
		
<span class="fc" id="L428">		EnhancedForStatement enhancedFor = (EnhancedForStatement) loop;</span>
<span class="fc" id="L429">		Statement body = enhancedFor.getBody();</span>
		
		// Get the loop parameter name (the iteration variable)
<span class="fc" id="L432">		String loopParamName = enhancedFor.getParameter().getName().getIdentifier();</span>
		
		// Collect all names of variables declared inside the loop
<span class="fc" id="L435">		Set&lt;String&gt; innerVariableNames = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">		for (VariableDeclarationFragment frag : innerVariables) {</span>
<span class="fc" id="L437">			innerVariableNames.add(frag.getName().getIdentifier());</span>
		}
		
		// Visit all SimpleName references in the loop body
<span class="fc" id="L441">		body.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(SimpleName node) {
				// Skip if this is a declaration, not a reference
<span class="fc bfc" id="L445" title="All 2 branches covered.">				if (node.isDeclaration()) {</span>
<span class="fc" id="L446">					return true;</span>
				}
				
				// Skip if this is the loop parameter
<span class="fc bfc" id="L450" title="All 2 branches covered.">				if (node.getIdentifier().equals(loopParamName)) {</span>
<span class="fc" id="L451">					return true;</span>
				}
				
				// Skip if this is a variable declared inside the loop
<span class="fc bfc" id="L455" title="All 2 branches covered.">				if (innerVariableNames.contains(node.getIdentifier())) {</span>
<span class="fc" id="L456">					return true;</span>
				}
				
				// Resolve the binding
<span class="fc" id="L460">				IBinding binding = node.resolveBinding();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">				if (binding == null) {</span>
					// Cannot resolve binding - skip this check (don't block conversion)
<span class="fc" id="L463">					return true;</span>
				}
				
<span class="fc bfc" id="L466" title="All 2 branches covered.">				if (binding instanceof IVariableBinding) {</span>
<span class="fc" id="L467">					IVariableBinding varBinding = (IVariableBinding) binding;</span>
					
					// Skip fields - they're not captured as local variables
<span class="fc bfc" id="L470" title="All 2 branches covered.">					if (varBinding.isField()) {</span>
<span class="fc" id="L471">						return true;</span>
					}
					
					// Skip method parameters - they're allowed to be captured
<span class="fc bfc" id="L475" title="All 2 branches covered.">					if (varBinding.isParameter()) {</span>
<span class="fc" id="L476">						return true;</span>
					}
					
					// Check if the variable is effectively final
					// Note: final variables and effectively final variables both return true
<span class="fc" id="L481">					if (!varBinding.isEffectivelyFinal()) {</span>
						// This variable is captured from an outer scope but is not effectively final
						// It cannot be used in a lambda
//						containsNEFs = true;
					}
				}
<span class="fc" id="L487">				return true;</span>
			}
		});
<span class="fc" id="L490">	}</span>

	/**
	 * Marks an AST node as a reducer pattern and records its statement.
	 * 
	 * @param node the AST node that represents a reducer operation
	 */
	private void markAsReducer(ASTNode node) {
<span class="nc" id="L498">		hasReducer = true;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">		if (reducerStatement == null) {</span>
<span class="nc" id="L500">			reducerStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
<span class="nc" id="L502">	}</span>

	/**
	 * Marks an AST node as a collect pattern and records its statement.
	 * 
	 * @param node the AST node that represents a collect operation (MethodInvocation)
	 */
	private void markAsCollectPattern(ASTNode node) {
<span class="nc" id="L510">		hasCollectPattern = true;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">		if (collectStatement == null) {</span>
<span class="nc" id="L512">			collectStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
		// Extract target variable from the MethodInvocation
<span class="nc bnc" id="L515" title="All 4 branches missed.">		if (node instanceof MethodInvocation methodInv &amp;&amp; collectTargetVariable == null) {</span>
<span class="nc" id="L516">			Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">			if (receiver instanceof SimpleName) {</span>
<span class="nc" id="L518">				collectTargetVariable = ((SimpleName) receiver).getIdentifier();</span>
			}
		}
<span class="nc" id="L521">	}</span>

	/**
	 * Checks if a method invocation represents a collect pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code result.add(item)} or {@code set.add(value)}&lt;/p&gt;
	 * 
	 * @param methodInv the method invocation to check
	 * @return true if this is a collect pattern
	 */
	private boolean isCollectPattern(MethodInvocation methodInv) {
		// Check if method name is &quot;add&quot;
<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (!&quot;add&quot;.equals(methodInv.getName().getIdentifier())) {</span>
<span class="nc" id="L534">			return false;</span>
		}
		
		// Check if invoked on a SimpleName (collection variable)
<span class="nc" id="L538">		Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">		if (!(receiver instanceof SimpleName)) {</span>
<span class="nc" id="L540">			return false;</span>
		}
		
		// Check if add() has one argument
<span class="nc bnc" id="L544" title="All 2 branches missed.">		if (methodInv.arguments().size() != 1) {</span>
<span class="nc" id="L545">			return false;</span>
		}
		
		// Additional validation: check if the receiver is a collection type
		// This is done in CollectPatternDetector, but for preconditions checking
		// we'll allow it here and let the detector do the full validation
<span class="nc" id="L551">		return true;</span>
	}

	/**
	 * Checks if an assignment represents a Math.max or Math.min reducer pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code max = Math.max(max, x)} or {@code min = Math.min(min, x)}&lt;/p&gt;
	 * 
	 * @param assignment the assignment to check
	 * @return true if this is a Math.max/Math.min reducer pattern
	 */
	private boolean isMathMinMaxReducerPattern(Assignment assignment) {
<span class="nc" id="L563">		Expression rhs = assignment.getRightHandSide();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">		if (!(rhs instanceof MethodInvocation methodInv)) {</span>
<span class="nc" id="L565">			return false;</span>
		}
		
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if (!isMathMinMaxInvocation(methodInv)) {</span>
<span class="nc" id="L569">			return false;</span>
		}
		
<span class="nc" id="L572">		return isLhsVariableInArguments(assignment.getLeftHandSide(), methodInv.arguments());</span>
	}

	/**
	 * Checks if a method invocation is Math.max or Math.min.
	 */
	private boolean isMathMinMaxInvocation(MethodInvocation methodInv) {
<span class="nc" id="L579">		Expression methodExpr = methodInv.getExpression();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">		if (!(methodExpr instanceof SimpleName className)) {</span>
<span class="nc" id="L581">			return false;</span>
		}
		
<span class="nc bnc" id="L584" title="All 2 branches missed.">		if (!&quot;Math&quot;.equals(className.getIdentifier())) {</span>
<span class="nc" id="L585">			return false;</span>
		}
		
<span class="nc" id="L588">		String methodName = methodInv.getName().getIdentifier();</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">		return &quot;max&quot;.equals(methodName) || &quot;min&quot;.equals(methodName);</span>
	}

	/**
	 * Checks if the LHS variable name appears in the method arguments.
	 */
	private boolean isLhsVariableInArguments(Expression lhs, List&lt;?&gt; arguments) {
<span class="nc bnc" id="L596" title="All 2 branches missed.">		if (!(lhs instanceof SimpleName lhsName)) {</span>
<span class="nc" id="L597">			return false;</span>
		}
		
<span class="nc bnc" id="L600" title="All 2 branches missed.">		if (arguments.size() != 2) {</span>
<span class="nc" id="L601">			return false;</span>
		}
		
<span class="nc" id="L604">		String varName = lhsName.getIdentifier();</span>
<span class="nc" id="L605">		return arguments.stream()</span>
<span class="nc" id="L606">				.filter(SimpleName.class::isInstance)</span>
<span class="nc" id="L607">				.map(SimpleName.class::cast)</span>
<span class="nc" id="L608">				.anyMatch(arg -&gt; varName.equals(arg.getIdentifier()));</span>
	}

	/**
	 * Detects anyMatch, noneMatch, and allMatch patterns in the loop.
	 * 
	 * &lt;p&gt;
	 * Patterns:
	 * &lt;ul&gt;
	 * &lt;li&gt;AnyMatch: {@code if (condition) return true;}&lt;/li&gt;
	 * &lt;li&gt;NoneMatch: {@code if (condition) return false;}&lt;/li&gt;
	 * &lt;li&gt;AllMatch: {@code if (!condition) return false;} or
	 * {@code if (condition) return false;} when negated&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * These patterns must be the only statement with a return in the loop body.
	 * 
	 * &lt;p&gt;
	 * AllMatch is typically used in patterns like:
	 * 
	 * &lt;pre&gt;
	 * for (Item item : items) {
	 * 	if (!item.isValid())
	 * 		return false;
	 * }
	 * return true;
	 * &lt;/pre&gt;
	 */
	private void detectEarlyReturnPatterns() {
<span class="pc bpc" id="L638" title="3 of 4 branches missed.">		if (!containsReturn || !(loop instanceof EnhancedForStatement)) {</span>
<span class="fc" id="L639">			return;</span>
		}

<span class="nc" id="L642">		EnhancedForStatement forLoop = (EnhancedForStatement) loop;</span>
<span class="nc" id="L643">		Statement body = forLoop.getBody();</span>

		// Find all IF statements with return statements in the loop
<span class="nc" id="L646">		final List&lt;IfStatement&gt; ifStatementsWithReturn = new ArrayList&lt;&gt;();</span>

		// Use ASTVisitor to find IF statements
<span class="nc" id="L649">		body.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(IfStatement node) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">				if (hasReturnInThenBranch(node)) {</span>
<span class="nc" id="L653">					ifStatementsWithReturn.add(node);</span>
				}
<span class="nc" id="L655">				return true;</span>
			}
		});

		// For anyMatch/noneMatch/allMatch, we expect exactly one IF with return
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (ifStatementsWithReturn.size() != 1) {</span>
<span class="nc" id="L661">			return;</span>
		}

<span class="nc" id="L664">		IfStatement ifStmt = ifStatementsWithReturn.get(0);</span>

		// The IF must not have an else branch for these patterns
<span class="nc bnc" id="L667" title="All 2 branches missed.">		if (ifStmt.getElseStatement() != null) {</span>
<span class="nc" id="L668">			return;</span>
		}

		// Check if the IF returns a boolean literal
<span class="nc" id="L672">		BooleanLiteral returnValue = getReturnValueFromIf(ifStmt);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (returnValue == null) {</span>
<span class="nc" id="L674">			return;</span>
		}

		// Check what statement follows the loop
<span class="nc" id="L678">		BooleanLiteral followingReturn = getReturnAfterLoop(forLoop);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">		if (followingReturn == null) {</span>
<span class="nc" id="L680">			return;</span>
		}

		// Determine pattern based on return values
<span class="nc" id="L684">		determineMatchPattern(returnValue.booleanValue(), followingReturn.booleanValue(), ifStmt.getExpression());</span>
<span class="nc" id="L685">	}</span>

	/**
	 * Determines which match pattern (anyMatch, noneMatch, allMatch) applies based on
	 * the return values and condition.
	 * 
	 * @param returnValueInLoop the boolean value returned inside the loop
	 * @param returnValueAfterLoop the boolean value returned after the loop
	 * @param condition the condition expression in the if statement
	 */
	private void determineMatchPattern(boolean returnValueInLoop, boolean returnValueAfterLoop, Expression condition) {
<span class="nc bnc" id="L696" title="All 4 branches missed.">		if (returnValueInLoop &amp;&amp; !returnValueAfterLoop) {</span>
			// if (condition) return true; + return false; → anyMatch
<span class="nc" id="L698">			isAnyMatchPattern = true;</span>
<span class="nc bnc" id="L699" title="All 4 branches missed.">		} else if (!returnValueInLoop &amp;&amp; returnValueAfterLoop) {</span>
			// if (condition) return false; + return true; → could be noneMatch OR allMatch
			// Distinguish based on condition negation:
			// - if (!condition) return false; + return true; → allMatch(condition)
			// - if (condition) return false; + return true; → noneMatch(condition)
<span class="nc bnc" id="L704" title="All 2 branches missed.">			if (isNegatedCondition(condition)) {</span>
<span class="nc" id="L705">				isAllMatchPattern = true;</span>
<span class="nc" id="L706">			} else {</span>
<span class="nc" id="L707">				isNoneMatchPattern = true;</span>
			}
		}
<span class="nc" id="L710">	}</span>

	/**
	 * Checks if the IF statement has a return in its then branch.
	 */
	private boolean hasReturnInThenBranch(IfStatement ifStmt) {
<span class="nc" id="L716">		return getReturnStatementFromThenBranch(ifStmt).isPresent();</span>
	}

	/**
	 * Extracts the return statement from the then branch of an if statement.
	 * Handles both direct return statements and blocks with a single return statement.
	 * 
	 * @param ifStmt the if statement to check
	 * @return Optional containing the ReturnStatement, or empty if not found
	 */
	private Optional&lt;ReturnStatement&gt; getReturnStatementFromThenBranch(IfStatement ifStmt) {
<span class="nc" id="L727">		Statement thenStmt = ifStmt.getThenStatement();</span>

<span class="nc bnc" id="L729" title="All 2 branches missed.">		if (thenStmt instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L730">			return Optional.of(returnStmt);</span>
		}

<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (thenStmt instanceof Block block) {</span>
<span class="nc" id="L734">			List&lt;?&gt; stmts = block.statements();</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">			if (stmts.size() == 1 &amp;&amp; stmts.get(0) instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L736">				return Optional.of(returnStmt);</span>
			}
		}

<span class="nc" id="L740">		return Optional.empty();</span>
	}

	/**
	 * Extracts the boolean literal value from a return statement in an IF.
	 * 
	 * @return the BooleanLiteral if the IF returns a boolean literal, null
	 *         otherwise
	 */
	private BooleanLiteral getReturnValueFromIf(IfStatement ifStmt) {
<span class="nc" id="L750">		return getReturnStatementFromThenBranch(ifStmt)</span>
<span class="nc" id="L751">				.map(ReturnStatement::getExpression)</span>
<span class="nc" id="L752">				.filter(BooleanLiteral.class::isInstance)</span>
<span class="nc" id="L753">				.map(BooleanLiteral.class::cast)</span>
<span class="nc" id="L754">				.orElse(null);</span>
	}

	/**
	 * Checks if an expression is a negated condition (starts with !).
	 * Handles ParenthesizedExpression wrapping.
	 * 
	 * @param expr the expression to check
	 * @return true if the expression is a PrefixExpression with NOT operator (possibly wrapped in parentheses)
	 */
	private boolean isNegatedCondition(Expression expr) {
		// Unwrap parentheses
<span class="nc bnc" id="L766" title="All 2 branches missed.">		while (expr instanceof ParenthesizedExpression) {</span>
<span class="nc" id="L767">			expr = ((ParenthesizedExpression) expr).getExpression();</span>
		}
		
<span class="nc bnc" id="L770" title="All 2 branches missed.">		return expr instanceof PrefixExpression</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">				&amp;&amp; ((PrefixExpression) expr).getOperator() == PrefixExpression.Operator.NOT;</span>
	}

	/**
	 * Gets the boolean return value from the statement immediately following the loop.
	 * 
	 * &lt;p&gt;
	 * For anyMatch/allMatch/noneMatch patterns, we expect a return statement with a
	 * boolean literal immediately after the loop. This method finds the loop's parent
	 * (usually a Block), locates the loop, and checks the next statement.
	 * &lt;/p&gt;
	 * 
	 * @param forLoop the EnhancedForStatement to check
	 * @return the BooleanLiteral returned after the loop, or null if not found
	 */
	private BooleanLiteral getReturnAfterLoop(EnhancedForStatement forLoop) {
<span class="nc" id="L787">		ASTNode parent = forLoop.getParent();</span>
		
		// The loop must be in a Block (method body, if-then block, etc.)
<span class="nc bnc" id="L790" title="All 2 branches missed.">		if (!(parent instanceof Block)) {</span>
<span class="nc" id="L791">			return null;</span>
		}
		
<span class="nc" id="L794">		Block block = (Block) parent;</span>
<span class="nc" id="L795">		List&lt;?&gt; statements = block.statements();</span>
		
		// Find the loop in the block's statements
<span class="nc" id="L798">		int loopIndex = statements.indexOf(forLoop);</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">		if (loopIndex == -1 || loopIndex &gt;= statements.size() - 1) {</span>
			// Loop not found or is the last statement
<span class="nc" id="L801">			return null;</span>
		}
		
		// Check the next statement
<span class="nc" id="L805">		Statement nextStmt = (Statement) statements.get(loopIndex + 1);</span>
		
		// We expect a return statement with a boolean literal
<span class="nc bnc" id="L808" title="All 2 branches missed.">		if (nextStmt instanceof ReturnStatement) {</span>
<span class="nc" id="L809">			ReturnStatement returnStmt = (ReturnStatement) nextStmt;</span>
<span class="nc" id="L810">			Expression expr = returnStmt.getExpression();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">			if (expr instanceof BooleanLiteral) {</span>
<span class="nc" id="L812">				return (BooleanLiteral) expr;</span>
			}
		}
		
<span class="nc" id="L816">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>