<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PreconditionsChecker.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">PreconditionsChecker.java</span></div><h1>PreconditionsChecker.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Set;

import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.sandbox.jdt.internal.common.AstProcessorBuilder;
import org.sandbox.jdt.internal.common.ReferenceHolder;

import java.util.*;

/**
 * Analyzes a loop statement to check various preconditions for safe refactoring
 * to stream operations. Uses AstProcessorBuilder for cleaner AST traversal.
 * 
 * &lt;p&gt;
 * This class is final to prevent subclassing and potential finalizer attacks,
 * since the constructor calls analysis methods that could potentially throw
 * exceptions.
 * &lt;/p&gt;
 */
public final class PreconditionsChecker {
	private final Statement loop;
//    private final CompilationUnit compilationUnit;
<span class="fc" id="L39">	private final Set&lt;VariableDeclarationFragment&gt; innerVariables = new HashSet&lt;&gt;();</span>
<span class="fc" id="L40">	private boolean containsBreak = false;</span>
<span class="fc" id="L41">	private boolean containsLabeledContinue = false;</span>
<span class="fc" id="L42">	private boolean containsReturn = false;</span>
<span class="fc" id="L43">	private boolean throwsException = false;</span>
<span class="fc" id="L44">	private boolean containsNEFs = false;</span>
<span class="fc" id="L45">	private boolean containsNestedLoop = false;</span>
<span class="fc" id="L46">	private boolean hasReducer = false;</span>
<span class="fc" id="L47">	private Statement reducerStatement = null;</span>
<span class="fc" id="L48">	private boolean isAnyMatchPattern = false;</span>
<span class="fc" id="L49">	private boolean isNoneMatchPattern = false;</span>
<span class="fc" id="L50">	private boolean isAllMatchPattern = false;</span>
<span class="fc" id="L51">	private boolean hasCollectPattern = false;</span>
<span class="fc" id="L52">	private Statement collectStatement = null;</span>
<span class="fc" id="L53">	private String collectTargetVariable = null;</span>
<span class="fc" id="L54">	private boolean modifiesIteratedCollection = false;</span>
<span class="fc" id="L55">	private boolean isConcurrentCollection = false;</span>
	/**
	 * Constructor for PreconditionsChecker.
	 * 
	 * @param loop            the statement containing the loop to analyze (must not
	 *                        be null)
	 * @param compilationUnit the compilation unit containing the loop
	 */
<span class="fc" id="L63">	public PreconditionsChecker(Statement loop, CompilationUnit compilationUnit) {</span>
		// Set loop field first - if null, we'll handle it gracefully in the catch block
<span class="fc" id="L65">		this.loop = loop;</span>
//        this.compilationUnit = compilationUnit;

		// Analyze the loop in a try-catch to prevent partial initialization
		// if any exception occurs during analysis
		try {
			// Perform analysis only if loop is not null
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">			if (loop != null) {</span>
<span class="fc" id="L73">				analyzeLoop();</span>
<span class="fc" id="L74">			} else {</span>
				// Null loop - treat as unsafe to refactor
<span class="nc" id="L76">				this.containsBreak = true;</span>
			}
<span class="nc" id="L78">		} catch (Exception e) {</span>
			// If analysis fails, treat loop as unsafe to refactor
			// Set flags to prevent conversion
<span class="nc" id="L81">			this.containsBreak = true; // Conservatively block conversion</span>
		}
<span class="fc" id="L83">	}</span>

	/**
	 * Checks if the loop is safe to refactor to stream operations.
	 * 
	 * &lt;p&gt;
	 * A loop is safe to refactor if it meets all of the following conditions:
	 * &lt;ul&gt;
	 * &lt;li&gt;Does not throw exceptions (throwsException == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain break statements (containsBreak == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain labeled continue statements (containsLabeledContinue ==
	 * false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain return statements OR contains only pattern-matching
	 * returns (anyMatch/noneMatch/allMatch)&lt;/li&gt;
	 * &lt;li&gt;All variables are effectively final (containsNEFs == false)&lt;/li&gt;
	 * &lt;li&gt;Does not iterate over concurrent collections (isConcurrentCollection == false)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Note on continue statements:&lt;/b&gt; Unlabeled continue statements are allowed
	 * and will be converted to filter operations by StreamPipelineBuilder. Only
	 * labeled continues are rejected because they cannot be safely translated to
	 * stream operations.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Pattern-matching early returns:&lt;/b&gt; Early returns matching anyMatch,
	 * noneMatch, or allMatch patterns are allowed because they can be converted to
	 * the corresponding terminal stream operations.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Concurrent collections:&lt;/b&gt; Loops over concurrent collections (e.g.,
	 * {@code CopyOnWriteArrayList}, {@code ConcurrentHashMap}) are blocked
	 * conservatively to prevent unsafe conversions. Concurrent collections have
	 * iteration semantics that differ from standard collections (for example,
	 * snapshot-based iterators for {@code CopyOnWriteArrayList} and
	 * weakly-consistent iterators for {@code ConcurrentHashMap}) that may not
	 * translate correctly to stream operations.
	 * &lt;/p&gt;
	 * 
	 * @return true if the loop can be safely converted to stream operations, false
	 *         otherwise
	 * @see StreamPipelineBuilder#parseLoopBody
	 */
	public boolean isSafeToRefactor() {
		// Allow early returns if they match anyMatch/noneMatch/allMatch patterns
<span class="pc bpc" id="L130" title="7 of 8 branches missed.">		boolean allowedReturn = containsReturn &amp;&amp; (isAnyMatchPattern || isNoneMatchPattern || isAllMatchPattern);</span>
		// Note: Unlabeled continues are allowed and will be converted to filters by
		// StreamPipelineBuilder
		// Only labeled continues are rejected here
		// Issue #670: Block conversion when the iterated collection is modified (add/remove/put/clear)
		// Issue #670: Block conversion when iterating over concurrent collections (conservative approach)
<span class="pc bpc" id="L136" title="6 of 10 branches missed.">		return !throwsException &amp;&amp; !containsBreak &amp;&amp; !containsLabeledContinue &amp;&amp; (!containsReturn || allowedReturn)</span>
<span class="pc bpc" id="L137" title="4 of 8 branches missed.">				&amp;&amp; !containsNEFs &amp;&amp; !containsNestedLoop &amp;&amp; !modifiesIteratedCollection &amp;&amp; !isConcurrentCollection;</span>
	}

	/**
	 * Checks if the loop contains a reducer pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for accumulator patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;i++, i--, ++i, --i&lt;/li&gt;
	 * &lt;li&gt;sum += x, product *= x, count -= 1&lt;/li&gt;
	 * &lt;li&gt;Other compound assignments (|=, &amp;=, etc.)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a reducer pattern is detected, false otherwise
	 * 
	 * @see #getReducer()
	 */
	public boolean isReducer() {
<span class="nc" id="L156">		return hasReducer;</span>
	}

	/**
	 * Returns the statement containing the reducer pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple reducers exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the reducer, or null if no reducer was
	 *         detected
	 * 
	 * @see #isReducer()
	 */
	public Statement getReducer() {
<span class="nc" id="L173">		return reducerStatement;</span>
	}

	/**
	 * Checks if the loop matches the anyMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AnyMatch pattern: loop contains {@code if (condition) return true;}
	 * &lt;/p&gt;
	 * 
	 * @return true if anyMatch pattern is detected
	 */
	public boolean isAnyMatchPattern() {
<span class="fc" id="L186">		return isAnyMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the noneMatch pattern.
	 * 
	 * &lt;p&gt;
	 * NoneMatch pattern: loop contains {@code if (condition) return false;}
	 * &lt;/p&gt;
	 * 
	 * @return true if noneMatch pattern is detected
	 */
	public boolean isNoneMatchPattern() {
<span class="fc" id="L199">		return isNoneMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the allMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AllMatch pattern: loop contains {@code if (condition) return false;} but the
	 * method returns true after the loop, or {@code if (!condition) return false;}
	 * checking all elements meet a condition.
	 * &lt;/p&gt;
	 * 
	 * @return true if allMatch pattern is detected
	 */
	public boolean isAllMatchPattern() {
<span class="fc" id="L214">		return isAllMatchPattern;</span>
	}

	/**
	 * Checks if the loop contains a collect pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for collection accumulation patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;result.add(item)&lt;/li&gt;
	 * &lt;li&gt;set.add(value)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a collect pattern is detected, false otherwise
	 * 
	 * @see #getCollectStatement()
	 * @see #getCollectTarget()
	 */
	public boolean isCollectPattern() {
<span class="nc" id="L233">		return hasCollectPattern;</span>
	}

	/**
	 * Returns the statement containing the collect pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple collect statements exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the collect operation, or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public Statement getCollectStatement() {
<span class="nc" id="L249">		return collectStatement;</span>
	}

	/**
	 * Returns the target collection variable name for the collect pattern.
	 * 
	 * @return the target variable name (e.g., &quot;result&quot;), or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public String getCollectTarget() {
<span class="nc" id="L260">		return collectTargetVariable;</span>
	}

	/**
	 * Checks if the loop modifies the collection being iterated over.
	 * 
	 * &lt;p&gt;
	 * Detects calls to structural modification methods (remove, add, put, clear,
	 * set, addAll, removeAll, retainAll, removeIf, replaceAll, sort, and Map methods
	 * like putIfAbsent, compute, merge, replace) on the iterated collection. Such
	 * modifications cause ConcurrentModificationException with fail-fast iterators
	 * and change iteration semantics.
	 * &lt;/p&gt;
	 * 
	 * @return true if the iterated collection is modified in the loop body
	 * 
	 * @see CollectionModificationDetector
	 * @see &lt;a href=&quot;https://github.com/carstenartur/sandbox/issues/670&quot;&gt;Issue #670&lt;/a&gt;
	 */
	public boolean modifiesIteratedCollection() {
<span class="nc" id="L280">		return modifiesIteratedCollection;</span>
	}
	
	/**
	 * Checks if the iterated collection is a concurrent collection type.
	 * 
	 * &lt;p&gt;
	 * Concurrent collections like {@code CopyOnWriteArrayList}, {@code ConcurrentHashMap},
	 * etc. have iteration semantics that differ from standard collections (for example,
	 * snapshot-based iterators for {@code CopyOnWriteArrayList} and
	 * weakly-consistent iterators for {@code ConcurrentHashMap}) that may not
	 * translate correctly to stream operations.
	 * Additionally, many concurrent collections do not support {@code iterator.remove()}.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Current Integration:&lt;/b&gt; Loops over concurrent collections are &lt;b&gt;blocked&lt;/b&gt;
	 * from conversion by {@link #isSafeToRefactor()}. This conservative approach prevents
	 * potential issues with iterator semantics that may not translate
	 * correctly to stream operations.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;&lt;b&gt;Rationale for Blocking:&lt;/b&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;Concurrent collections and collections with snapshot-based iterators can
	 * have iterator semantics that may not translate correctly to stream
	 * operations (Issue #670).&lt;/li&gt;
	 * &lt;li&gt;Iterator behavior differs significantly from standard collections&lt;/li&gt;
	 * &lt;li&gt;Many concurrent collections don't support {@code iterator.remove()}&lt;/li&gt;
	 * &lt;li&gt;Conservative approach ensures correctness over convenience&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;/p&gt;
	 * 
	 * @return true if the iterated collection is a concurrent collection
	 * 
	 * @see ConcurrentCollectionDetector
	 * @see #isSafeToRefactor()
	 * @see &lt;a href=&quot;https://github.com/carstenartur/sandbox/issues/670&quot;&gt;Issue #670 - Point 2.4&lt;/a&gt;
	 */
	public boolean isConcurrentCollection() {
<span class="nc" id="L319">		return isConcurrentCollection;</span>
	}

	/**
	 * Analyzes the loop statement to identify relevant elements for refactoring.
	 * 
	 * &lt;p&gt;
	 * This method uses {@link AstProcessorBuilder} for cleaner and more
	 * maintainable AST traversal. It performs the following analysis:
	 * &lt;ul&gt;
	 * &lt;li&gt;Collects variable declarations within the loop&lt;/li&gt;
	 * &lt;li&gt;Detects control flow statements (break, continue, return, throw)&lt;/li&gt;
	 * &lt;li&gt;Identifies reducer patterns (i++, sum += x, etc.)&lt;/li&gt;
	 * &lt;li&gt;Detects early return patterns (anyMatch, noneMatch, allMatch)&lt;/li&gt;
	 * &lt;li&gt;Checks if variables are effectively final&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The analysis results are stored in instance variables that can be queried via
	 * getter methods like {@link #isSafeToRefactor()}, {@link #isReducer()}, etc.
	 * &lt;/p&gt;
	 */
	private void analyzeLoop() {
		// Extract the iterated collection name and type for modification detection (Issue #670)
<span class="fc" id="L343">		String iteratedCollectionName = extractIteratedCollectionName();</span>
<span class="fc" id="L344">		ITypeBinding iteratedCollectionType = extractIteratedCollectionType();</span>
		
		// Check if iterating over a concurrent collection (Issue #670 - Point 2.4)
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">		if (iteratedCollectionType != null) {</span>
<span class="fc" id="L348">			isConcurrentCollection = ConcurrentCollectionDetector.isConcurrentCollection(iteratedCollectionType);</span>
		}
		
<span class="fc" id="L351">		AstProcessorBuilder&lt;String, Object&gt; builder = AstProcessorBuilder.with(new ReferenceHolder&lt;String, Object&gt;());</span>

<span class="fc" id="L353">		builder.onVariableDeclarationFragment((node, h) -&gt; {</span>
<span class="nc" id="L354">			innerVariables.add(node);</span>
<span class="nc" id="L355">			return true;</span>
<span class="fc" id="L356">		}).onBreakStatement((node, h) -&gt; {</span>
<span class="nc" id="L357">			containsBreak = true;</span>
<span class="nc" id="L358">			return true;</span>
<span class="fc" id="L359">		}).onLabeledContinue((node, h) -&gt; {</span>
			// Labeled continue should prevent conversion (unlabeled continues are allowed)
<span class="nc" id="L361">			containsLabeledContinue = true;</span>
<span class="nc" id="L362">			return true;</span>
<span class="fc" id="L363">		}).onReturnStatement((node, h) -&gt; {</span>
<span class="nc" id="L364">			containsReturn = true;</span>
<span class="nc" id="L365">			return true;</span>
<span class="fc" id="L366">		}).onThrowStatement((node, h) -&gt; {</span>
<span class="nc" id="L367">			throwsException = true;</span>
<span class="nc" id="L368">			return true;</span>
<span class="fc" id="L369">		}).onEnhancedForStatement((node, h) -&gt; {</span>
			// If we encounter another EnhancedForStatement inside the loop body,
			// it's a nested loop.
			// PHASE 9: With LoopTree, nested loops are handled separately in the tree.
			// We should NOT descend into them, as they'll be analyzed independently.
			// Only mark as containsNestedLoop if this is the root loop we're analyzing.
<span class="nc bnc" id="L375" title="All 2 branches missed.">			if (node == loop) {</span>
<span class="nc" id="L376">				return true; // Continue analyzing this loop's body</span>
			}
			// Found a nested loop - don't descend into it (return false)
			// The LoopTree will handle this nested loop separately
<span class="nc" id="L380">			return false;</span>
<span class="fc" id="L381">		}).onForStatement((node, h) -&gt; {</span>
			// Traditional for loops inside the enhanced-for also prevent conversion
<span class="nc" id="L383">			containsNestedLoop = true;</span>
<span class="nc" id="L384">			return true;</span>
<span class="fc" id="L385">		}).onWhileStatement((node, h) -&gt; {</span>
			// While loops inside the enhanced-for also prevent conversion
<span class="nc" id="L387">			containsNestedLoop = true;</span>
<span class="nc" id="L388">			return true;</span>
<span class="fc" id="L389">		}).onDoStatement((node, h) -&gt; {</span>
			// Do-while loops inside the enhanced-for also prevent conversion
<span class="nc" id="L391">			containsNestedLoop = true;</span>
<span class="nc" id="L392">			return true;</span>
<span class="fc" id="L393">		}).onTryStatement((node, h) -&gt; {</span>
			// Try-catch blocks inside the loop prevent conversion
			// (exception handling in lambdas is complex)
<span class="nc" id="L396">			containsNEFs = true;</span>
<span class="nc" id="L397">			return true;</span>
<span class="fc" id="L398">		}).onSwitchStatement((node, h) -&gt; {</span>
			// Switch statements inside the loop prevent conversion
<span class="nc" id="L400">			containsNEFs = true;</span>
<span class="nc" id="L401">			return true;</span>
<span class="fc" id="L402">		}).onSynchronizedStatement((node, h) -&gt; {</span>
			// Synchronized blocks inside the loop prevent conversion
<span class="nc" id="L404">			containsNEFs = true;</span>
<span class="nc" id="L405">			return true;</span>
<span class="fc" id="L406">		}).onCompoundAssignment((node, h) -&gt; {</span>
			// Compound assignments: +=, -=, *=, /=, |=, &amp;=, etc.
<span class="nc" id="L408">			markAsReducer(node);</span>
<span class="nc" id="L409">			return true;</span>
<span class="fc" id="L410">		}).onAssignment((node, h) -&gt; {</span>
			// Check for Math.max/Math.min patterns: max = Math.max(max, x)
<span class="nc bnc" id="L412" title="All 4 branches missed.">			if (node.getOperator() == Assignment.Operator.ASSIGN &amp;&amp; isMathMinMaxReducerPattern(node)) {</span>
<span class="nc" id="L413">				markAsReducer(node);</span>
			}
<span class="nc" id="L415">			return true;</span>
<span class="fc" id="L416">		}).onPostfixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect i++, i--
<span class="nc" id="L418">			markAsReducer(node);</span>
<span class="nc" id="L419">			return true;</span>
<span class="fc" id="L420">		}).onPrefixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect ++i, --i
<span class="nc" id="L422">			markAsReducer(node);</span>
<span class="nc" id="L423">			return true;</span>
<span class="fc" id="L424">		}).onMethodInvocation((node, h) -&gt; {</span>
			// Detect collection.add() patterns for collect operation
<span class="nc bnc" id="L426" title="All 2 branches missed.">			if (isCollectPattern(node)) {</span>
<span class="nc" id="L427">				markAsCollectPattern(node);</span>
			}
			// Issue #670: Detect structural modifications on the iterated collection
<span class="nc bnc" id="L430" title="All 2 branches missed.">			if (iteratedCollectionName != null</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">					&amp;&amp; CollectionModificationDetector.isModification(node, iteratedCollectionName)) {</span>
<span class="nc" id="L432">				modifiesIteratedCollection = true;</span>
			}
<span class="nc" id="L434">			return true;</span>
		});

		// First, analyze just the loop itself
<span class="fc" id="L438">		builder.build(loop);</span>

		// Save the containsReturn flag state after analyzing only the loop body
		// This is important because we want to distinguish between:
		// 1. Returns INSIDE the loop (which may prevent conversion, except for match patterns)
		// 2. Returns AFTER the loop (which are just part of the method and shouldn't prevent conversion)
<span class="fc" id="L444">		boolean containsReturnInsideLoop = containsReturn;</span>

		// Then, if the loop is inside a Block, analyze only the immediately following
		// statement (if any). This lets us detect patterns that depend on the statement
		// right after the loop without pulling in unrelated statements.
<span class="fc" id="L449">		ASTNode parent = loop.getParent();</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">		if (parent instanceof Block block) {</span>
<span class="fc" id="L451">			List&lt;Statement&gt; statements = block.statements();</span>
<span class="fc" id="L452">			int loopIndex = statements.indexOf(loop);</span>
<span class="pc bpc" id="L453" title="2 of 4 branches missed.">			if (loopIndex != -1 &amp;&amp; loopIndex + 1 &lt; statements.size()) {</span>
<span class="fc" id="L454">				Statement followingStatement = statements.get(loopIndex + 1);</span>
<span class="fc" id="L455">				builder.build(followingStatement);</span>
			}
		}

		// Detect anyMatch/noneMatch patterns
		// This needs to see if there's a return statement after the loop,
		// so containsReturn may be true from analyzing the following statement
<span class="fc" id="L462">		detectEarlyReturnPatterns();</span>

		// Restore the containsReturn flag to only reflect returns INSIDE the loop
		// This ensures that isSafeToRefactor() only rejects loops with returns inside,
		// not loops followed by return statements (like reducers)
<span class="fc" id="L467">		containsReturn = containsReturnInsideLoop;</span>
		
		// NOTE: Effectively-final variable checks for nested loops are now handled
		// by EnhancedForHandler.endVisitLoop() using LoopTree/ScopeInfo, which properly
		// tracks modifications in ancestor scopes while allowing reducer patterns.
<span class="fc" id="L472">	}</span>

	/**
	 * Marks an AST node as a reducer pattern and records its statement.
	 * 
	 * @param node the AST node that represents a reducer operation
	 */
	private void markAsReducer(ASTNode node) {
<span class="nc" id="L480">		hasReducer = true;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		if (reducerStatement == null) {</span>
<span class="nc" id="L482">			reducerStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
<span class="nc" id="L484">	}</span>

	/**
	 * Marks an AST node as a collect pattern and records its statement.
	 * 
	 * @param node the AST node that represents a collect operation (MethodInvocation)
	 */
	private void markAsCollectPattern(ASTNode node) {
<span class="nc" id="L492">		hasCollectPattern = true;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">		if (collectStatement == null) {</span>
<span class="nc" id="L494">			collectStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
		// Extract target variable from the MethodInvocation
<span class="nc bnc" id="L497" title="All 4 branches missed.">		if (node instanceof MethodInvocation methodInv &amp;&amp; collectTargetVariable == null) {</span>
<span class="nc" id="L498">			Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">			if (receiver instanceof SimpleName simpleName) {</span>
<span class="nc" id="L500">				collectTargetVariable = simpleName.getIdentifier();</span>
			}
		}
<span class="nc" id="L503">	}</span>

	/**
	 * Checks if a method invocation represents a collect pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code result.add(item)} or {@code set.add(value)}&lt;/p&gt;
	 * 
	 * @param methodInv the method invocation to check
	 * @return true if this is a collect pattern
	 */
	private boolean isCollectPattern(MethodInvocation methodInv) {
		// Check if method name is &quot;add&quot;
<span class="nc bnc" id="L515" title="All 2 branches missed.">		if (!&quot;add&quot;.equals(methodInv.getName().getIdentifier())) {</span>
<span class="nc" id="L516">			return false;</span>
		}
		
		// Check if invoked on a SimpleName (collection variable)
<span class="nc" id="L520">		Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">		if (!(receiver instanceof SimpleName)) {</span>
<span class="nc" id="L522">			return false;</span>
		}
		
		// Check if add() has one argument
<span class="nc bnc" id="L526" title="All 2 branches missed.">		if (methodInv.arguments().size() != 1) {</span>
<span class="nc" id="L527">			return false;</span>
		}
		
		// Additional validation: check if the receiver is a collection type
		// This is done in CollectPatternDetector, but for preconditions checking
		// we'll allow it here and let the detector do the full validation
<span class="nc" id="L533">		return true;</span>
	}

	/**
	 * Checks if an assignment represents a Math.max or Math.min reducer pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code max = Math.max(max, x)} or {@code min = Math.min(min, x)}&lt;/p&gt;
	 * 
	 * @param assignment the assignment to check
	 * @return true if this is a Math.max/Math.min reducer pattern
	 */
	private boolean isMathMinMaxReducerPattern(Assignment assignment) {
<span class="nc" id="L545">		Expression rhs = assignment.getRightHandSide();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">		if (!(rhs instanceof MethodInvocation methodInv)) {</span>
<span class="nc" id="L547">			return false;</span>
		}
		
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (!isMathMinMaxInvocation(methodInv)) {</span>
<span class="nc" id="L551">			return false;</span>
		}
		
<span class="nc" id="L554">		return isLhsVariableInArguments(assignment.getLeftHandSide(), methodInv.arguments());</span>
	}

	/**
	 * Checks if a method invocation is Math.max or Math.min.
	 */
	private boolean isMathMinMaxInvocation(MethodInvocation methodInv) {
<span class="nc" id="L561">		Expression methodExpr = methodInv.getExpression();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">		if (!(methodExpr instanceof SimpleName className)) {</span>
<span class="nc" id="L563">			return false;</span>
		}
		
<span class="nc bnc" id="L566" title="All 2 branches missed.">		if (!&quot;Math&quot;.equals(className.getIdentifier())) {</span>
<span class="nc" id="L567">			return false;</span>
		}
		
<span class="nc" id="L570">		String methodName = methodInv.getName().getIdentifier();</span>
<span class="nc bnc" id="L571" title="All 4 branches missed.">		return &quot;max&quot;.equals(methodName) || &quot;min&quot;.equals(methodName);</span>
	}

	/**
	 * Checks if the LHS variable name appears in the method arguments.
	 */
	private boolean isLhsVariableInArguments(Expression lhs, List&lt;?&gt; arguments) {
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (!(lhs instanceof SimpleName lhsName)) {</span>
<span class="nc" id="L579">			return false;</span>
		}
		
<span class="nc bnc" id="L582" title="All 2 branches missed.">		if (arguments.size() != 2) {</span>
<span class="nc" id="L583">			return false;</span>
		}
		
<span class="nc" id="L586">		String varName = lhsName.getIdentifier();</span>
<span class="nc" id="L587">		return arguments.stream()</span>
<span class="nc" id="L588">				.filter(SimpleName.class::isInstance)</span>
<span class="nc" id="L589">				.map(SimpleName.class::cast)</span>
<span class="nc" id="L590">				.anyMatch(arg -&gt; varName.equals(arg.getIdentifier()));</span>
	}

	/**
	 * Detects anyMatch, noneMatch, and allMatch patterns in the loop.
	 * 
	 * &lt;p&gt;
	 * Patterns:
	 * &lt;ul&gt;
	 * &lt;li&gt;AnyMatch: {@code if (condition) return true;}&lt;/li&gt;
	 * &lt;li&gt;NoneMatch: {@code if (condition) return false;}&lt;/li&gt;
	 * &lt;li&gt;AllMatch: {@code if (!condition) return false;} or
	 * {@code if (condition) return false;} when negated&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * These patterns must be the only statement with a return in the loop body.
	 * 
	 * &lt;p&gt;
	 * AllMatch is typically used in patterns like:
	 * 
	 * &lt;pre&gt;
	 * for (Item item : items) {
	 * 	if (!item.isValid())
	 * 		return false;
	 * }
	 * return true;
	 * &lt;/pre&gt;
	 */
	private void detectEarlyReturnPatterns() {
<span class="pc bpc" id="L620" title="3 of 4 branches missed.">		if (!containsReturn || !(loop instanceof EnhancedForStatement forLoop)) {</span>
<span class="fc" id="L621">			return;</span>
		}

<span class="nc" id="L624">		Statement body = forLoop.getBody();</span>

		// Find all IF statements with return statements in the loop
<span class="nc" id="L627">		final List&lt;IfStatement&gt; ifStatementsWithReturn = new ArrayList&lt;&gt;();</span>

		// Use ASTVisitor to find IF statements
<span class="nc" id="L630">		body.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(IfStatement node) {
<span class="nc bnc" id="L633" title="All 2 branches missed.">				if (hasReturnInThenBranch(node)) {</span>
<span class="nc" id="L634">					ifStatementsWithReturn.add(node);</span>
				}
<span class="nc" id="L636">				return true;</span>
			}
		});

		// For anyMatch/noneMatch/allMatch, we expect exactly one IF with return
<span class="nc bnc" id="L641" title="All 2 branches missed.">		if (ifStatementsWithReturn.size() != 1) {</span>
<span class="nc" id="L642">			return;</span>
		}

<span class="nc" id="L645">		IfStatement ifStmt = ifStatementsWithReturn.get(0);</span>

		// The IF must not have an else branch for these patterns
<span class="nc bnc" id="L648" title="All 2 branches missed.">		if (ifStmt.getElseStatement() != null) {</span>
<span class="nc" id="L649">			return;</span>
		}

		// Check if the IF returns a boolean literal
<span class="nc" id="L653">		BooleanLiteral returnValue = getReturnValueFromIf(ifStmt);</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">		if (returnValue == null) {</span>
<span class="nc" id="L655">			return;</span>
		}

		// Check what statement follows the loop
<span class="nc" id="L659">		BooleanLiteral followingReturn = getReturnAfterLoop(forLoop);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (followingReturn == null) {</span>
<span class="nc" id="L661">			return;</span>
		}

		// Determine pattern based on return values
<span class="nc" id="L665">		determineMatchPattern(returnValue.booleanValue(), followingReturn.booleanValue(), ifStmt.getExpression());</span>
<span class="nc" id="L666">	}</span>

	/**
	 * Determines which match pattern (anyMatch, noneMatch, allMatch) applies based on
	 * the return values and condition.
	 * 
	 * @param returnValueInLoop the boolean value returned inside the loop
	 * @param returnValueAfterLoop the boolean value returned after the loop
	 * @param condition the condition expression in the if statement
	 */
	private void determineMatchPattern(boolean returnValueInLoop, boolean returnValueAfterLoop, Expression condition) {
<span class="nc bnc" id="L677" title="All 4 branches missed.">		if (returnValueInLoop &amp;&amp; !returnValueAfterLoop) {</span>
			// if (condition) return true; + return false; → anyMatch
<span class="nc" id="L679">			isAnyMatchPattern = true;</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">		} else if (!returnValueInLoop &amp;&amp; returnValueAfterLoop) {</span>
			// if (condition) return false; + return true; → could be noneMatch OR allMatch
			// Distinguish based on condition negation:
			// - if (!condition) return false; + return true; → allMatch(condition)
			// - if (condition) return false; + return true; → noneMatch(condition)
<span class="nc bnc" id="L685" title="All 2 branches missed.">			if (isNegatedCondition(condition)) {</span>
<span class="nc" id="L686">				isAllMatchPattern = true;</span>
<span class="nc" id="L687">			} else {</span>
<span class="nc" id="L688">				isNoneMatchPattern = true;</span>
			}
		}
<span class="nc" id="L691">	}</span>

	/**
	 * Checks if the IF statement has a return in its then branch.
	 */
	private boolean hasReturnInThenBranch(IfStatement ifStmt) {
<span class="nc" id="L697">		return getReturnStatementFromThenBranch(ifStmt).isPresent();</span>
	}

	/**
	 * Extracts the return statement from the then branch of an if statement.
	 * Handles both direct return statements and blocks with a single return statement.
	 * 
	 * @param ifStmt the if statement to check
	 * @return Optional containing the ReturnStatement, or empty if not found
	 */
	private Optional&lt;ReturnStatement&gt; getReturnStatementFromThenBranch(IfStatement ifStmt) {
<span class="nc" id="L708">		Statement thenStmt = ifStmt.getThenStatement();</span>

<span class="nc bnc" id="L710" title="All 2 branches missed.">		if (thenStmt instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L711">			return Optional.of(returnStmt);</span>
		}

<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (thenStmt instanceof Block block) {</span>
<span class="nc" id="L715">			List&lt;?&gt; stmts = block.statements();</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">			if (stmts.size() == 1 &amp;&amp; stmts.get(0) instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L717">				return Optional.of(returnStmt);</span>
			}
		}

<span class="nc" id="L721">		return Optional.empty();</span>
	}

	/**
	 * Extracts the boolean literal value from a return statement in an IF.
	 * 
	 * @return the BooleanLiteral if the IF returns a boolean literal, null
	 *         otherwise
	 */
	private BooleanLiteral getReturnValueFromIf(IfStatement ifStmt) {
<span class="nc" id="L731">		return getReturnStatementFromThenBranch(ifStmt)</span>
<span class="nc" id="L732">				.map(ReturnStatement::getExpression)</span>
<span class="nc" id="L733">				.filter(BooleanLiteral.class::isInstance)</span>
<span class="nc" id="L734">				.map(BooleanLiteral.class::cast)</span>
<span class="nc" id="L735">				.orElse(null);</span>
	}

	/**
	 * Checks if an expression is a negated condition (starts with !).
	 * Handles ParenthesizedExpression wrapping.
	 * 
	 * @param expr the expression to check
	 * @return true if the expression is a PrefixExpression with NOT operator (possibly wrapped in parentheses)
	 */
	private boolean isNegatedCondition(Expression expr) {
		// Unwrap parentheses
<span class="nc bnc" id="L747" title="All 2 branches missed.">		while (expr instanceof ParenthesizedExpression parenthesized) {</span>
<span class="nc" id="L748">			expr = parenthesized.getExpression();</span>
		}
		
<span class="nc bnc" id="L751" title="All 2 branches missed.">		return expr instanceof PrefixExpression prefixExpr</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">				&amp;&amp; prefixExpr.getOperator() == PrefixExpression.Operator.NOT;</span>
	}

	/**
	 * Gets the boolean return value from the statement immediately following the loop.
	 * 
	 * &lt;p&gt;
	 * For anyMatch/allMatch/noneMatch patterns, we expect a return statement with a
	 * boolean literal immediately after the loop. This method finds the loop's parent
	 * (usually a Block), locates the loop, and checks the next statement.
	 * &lt;/p&gt;
	 * 
	 * @param forLoop the EnhancedForStatement to check
	 * @return the BooleanLiteral returned after the loop, or null if not found
	 */
	private BooleanLiteral getReturnAfterLoop(EnhancedForStatement forLoop) {
<span class="nc" id="L768">		ASTNode parent = forLoop.getParent();</span>
		
		// The loop must be in a Block (method body, if-then block, etc.)
<span class="nc bnc" id="L771" title="All 2 branches missed.">		if (!(parent instanceof Block block)) {</span>
<span class="nc" id="L772">			return null;</span>
		}
		
<span class="nc" id="L775">		List&lt;?&gt; statements = block.statements();</span>
		
		// Find the loop in the block's statements
<span class="nc" id="L778">		int loopIndex = statements.indexOf(forLoop);</span>
<span class="nc bnc" id="L779" title="All 4 branches missed.">		if (loopIndex == -1 || loopIndex &gt;= statements.size() - 1) {</span>
			// Loop not found or is the last statement
<span class="nc" id="L781">			return null;</span>
		}
		
		// Check the next statement
<span class="nc" id="L785">		Statement nextStmt = (Statement) statements.get(loopIndex + 1);</span>
		
		// We expect a return statement with a boolean literal
<span class="nc bnc" id="L788" title="All 2 branches missed.">		if (nextStmt instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L789">			Expression expr = returnStmt.getExpression();</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">			if (expr instanceof BooleanLiteral boolLiteral) {</span>
<span class="nc" id="L791">				return boolLiteral;</span>
			}
		}
		
<span class="nc" id="L795">		return null;</span>
	}

	/**
	 * Extracts the name of the iterated collection from the loop statement.
	 * 
	 * &lt;p&gt;For enhanced for-loops: {@code for (String item : list)} → &quot;list&quot;&lt;/p&gt;
	 * 
	 * @return the collection variable name, or null if not determinable
	 */
	private String extractIteratedCollectionName() {
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">		if (loop instanceof EnhancedForStatement enhancedFor) {</span>
<span class="fc" id="L807">			Expression expression = enhancedFor.getExpression();</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">			if (expression instanceof SimpleName simpleName) {</span>
<span class="fc" id="L809">				return simpleName.getIdentifier();</span>
			}
			// Unwrap common map view-producing calls like map.entrySet(), map.keySet(), map.values()
<span class="nc bnc" id="L812" title="All 2 branches missed.">			if (expression instanceof MethodInvocation methodInvocation) {</span>
<span class="nc" id="L813">				SimpleName name = methodInvocation.getName();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">				if (name != null) {</span>
<span class="nc" id="L815">					String identifier = name.getIdentifier();</span>
<span class="nc bnc" id="L816" title="All 6 branches missed.">					if (&quot;entrySet&quot;.equals(identifier) || &quot;keySet&quot;.equals(identifier) || &quot;values&quot;.equals(identifier)) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">						if (methodInvocation.arguments().isEmpty()) {</span>
<span class="nc" id="L818">							Expression qualifier = methodInvocation.getExpression();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">							if (qualifier instanceof SimpleName qualifierName) {</span>
<span class="nc" id="L820">								return qualifierName.getIdentifier();</span>
							}
						}
					}
				}
			}
		}
<span class="nc" id="L827">		return null;</span>
	}
	
	/**
	 * Extracts the type of the iterated collection from the loop statement.
	 * 
	 * &lt;p&gt;For enhanced for-loops: {@code for (String item : list)} → type of list&lt;/p&gt;
	 * &lt;p&gt;Unwraps common map view-producing calls like {@code map.entrySet()}, 
	 * {@code map.keySet()}, {@code map.values()} to detect the underlying map type.&lt;/p&gt;
	 * 
	 * @return the collection type binding, or null if not determinable
	 */
	private ITypeBinding extractIteratedCollectionType() {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">		if (loop instanceof EnhancedForStatement enhancedFor) {</span>
<span class="fc" id="L841">			Expression expression = enhancedFor.getExpression();</span>
			
			// Unwrap common map view-producing calls like map.entrySet(), map.keySet(), map.values()
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">			if (expression instanceof MethodInvocation methodInvocation) {</span>
<span class="nc" id="L845">				SimpleName name = methodInvocation.getName();</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">				if (name != null) {</span>
<span class="nc" id="L847">					String identifier = name.getIdentifier();</span>
<span class="nc bnc" id="L848" title="All 6 branches missed.">					if (&quot;entrySet&quot;.equals(identifier) || &quot;keySet&quot;.equals(identifier) || &quot;values&quot;.equals(identifier)) {</span>
						// Only consider the simple, no-arg variants
<span class="nc bnc" id="L850" title="All 2 branches missed.">						if (methodInvocation.arguments().isEmpty()) {</span>
<span class="nc" id="L851">							Expression qualifier = methodInvocation.getExpression();</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">							if (qualifier != null) {</span>
<span class="nc" id="L853">								ITypeBinding qualifierBinding = qualifier.resolveTypeBinding();</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">								if (qualifierBinding != null) {</span>
<span class="nc" id="L855">									return qualifierBinding;</span>
								}
							}
						}
					}
				}
			}
			
<span class="fc" id="L863">			return expression.resolveTypeBinding();</span>
		}
<span class="nc" id="L865">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>