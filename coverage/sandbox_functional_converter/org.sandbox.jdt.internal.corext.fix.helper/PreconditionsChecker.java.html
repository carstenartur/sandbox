<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PreconditionsChecker.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_functional_converter</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">PreconditionsChecker.java</span></div><h1>PreconditionsChecker.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2025 Carsten Hammer and others.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Set;

import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.*;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.sandbox.jdt.internal.common.AstProcessorBuilder;
import org.sandbox.jdt.internal.common.ReferenceHolder;

import java.util.*;

/**
 * Analyzes a loop statement to check various preconditions for safe refactoring
 * to stream operations. Uses AstProcessorBuilder for cleaner AST traversal.
 * 
 * &lt;p&gt;
 * This class is final to prevent subclassing and potential finalizer attacks,
 * since the constructor calls analysis methods that could potentially throw
 * exceptions.
 * &lt;/p&gt;
 */
public final class PreconditionsChecker {
	private final Statement loop;
//    private final CompilationUnit compilationUnit;
<span class="fc" id="L39">	private final Set&lt;VariableDeclarationFragment&gt; innerVariables = new HashSet&lt;&gt;();</span>
<span class="fc" id="L40">	private boolean containsBreak = false;</span>
<span class="fc" id="L41">	private boolean containsLabeledContinue = false;</span>
<span class="fc" id="L42">	private boolean containsReturn = false;</span>
<span class="fc" id="L43">	private boolean throwsException = false;</span>
<span class="fc" id="L44">	private boolean containsNEFs = false;</span>
<span class="fc" id="L45">	private boolean containsNestedLoop = false;</span>
<span class="fc" id="L46">	private boolean hasReducer = false;</span>
<span class="fc" id="L47">	private Statement reducerStatement = null;</span>
<span class="fc" id="L48">	private boolean isAnyMatchPattern = false;</span>
<span class="fc" id="L49">	private boolean isNoneMatchPattern = false;</span>
<span class="fc" id="L50">	private boolean isAllMatchPattern = false;</span>
<span class="fc" id="L51">	private boolean hasCollectPattern = false;</span>
<span class="fc" id="L52">	private Statement collectStatement = null;</span>
<span class="fc" id="L53">	private String collectTargetVariable = null;</span>
	/**
	 * Constructor for PreconditionsChecker.
	 * 
	 * @param loop            the statement containing the loop to analyze (must not
	 *                        be null)
	 * @param compilationUnit the compilation unit containing the loop
	 */
<span class="fc" id="L61">	public PreconditionsChecker(Statement loop, CompilationUnit compilationUnit) {</span>
		// Set loop field first - if null, we'll handle it gracefully in the catch block
<span class="fc" id="L63">		this.loop = loop;</span>
//        this.compilationUnit = compilationUnit;

		// Analyze the loop in a try-catch to prevent partial initialization
		// if any exception occurs during analysis
		try {
			// Perform analysis only if loop is not null
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			if (loop != null) {</span>
<span class="fc" id="L71">				analyzeLoop();</span>
<span class="fc" id="L72">			} else {</span>
				// Null loop - treat as unsafe to refactor
<span class="nc" id="L74">				this.containsBreak = true;</span>
			}
<span class="nc" id="L76">		} catch (Exception e) {</span>
			// If analysis fails, treat loop as unsafe to refactor
			// Set flags to prevent conversion
<span class="nc" id="L79">			this.containsBreak = true; // Conservatively block conversion</span>
		}
<span class="fc" id="L81">	}</span>

	/**
	 * Checks if the loop is safe to refactor to stream operations.
	 * 
	 * &lt;p&gt;
	 * A loop is safe to refactor if it meets all of the following conditions:
	 * &lt;ul&gt;
	 * &lt;li&gt;Does not throw exceptions (throwsException == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain break statements (containsBreak == false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain labeled continue statements (containsLabeledContinue ==
	 * false)&lt;/li&gt;
	 * &lt;li&gt;Does not contain return statements OR contains only pattern-matching
	 * returns (anyMatch/noneMatch/allMatch)&lt;/li&gt;
	 * &lt;li&gt;All variables are effectively final (containsNEFs == false)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Note on continue statements:&lt;/b&gt; Unlabeled continue statements are allowed
	 * and will be converted to filter operations by StreamPipelineBuilder. Only
	 * labeled continues are rejected because they cannot be safely translated to
	 * stream operations.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * &lt;b&gt;Pattern-matching early returns:&lt;/b&gt; Early returns matching anyMatch,
	 * noneMatch, or allMatch patterns are allowed because they can be converted to
	 * the corresponding terminal stream operations.
	 * &lt;/p&gt;
	 * 
	 * @return true if the loop can be safely converted to stream operations, false
	 *         otherwise
	 * @see StreamPipelineBuilder#parseLoopBody
	 */
	public boolean isSafeToRefactor() {
		// Allow early returns if they match anyMatch/noneMatch/allMatch patterns
<span class="pc bpc" id="L117" title="7 of 8 branches missed.">		boolean allowedReturn = containsReturn &amp;&amp; (isAnyMatchPattern || isNoneMatchPattern || isAllMatchPattern);</span>
		// Note: Unlabeled continues are allowed and will be converted to filters by
		// StreamPipelineBuilder
		// Only labeled continues are rejected here
<span class="pc bpc" id="L121" title="6 of 10 branches missed.">		return !throwsException &amp;&amp; !containsBreak &amp;&amp; !containsLabeledContinue &amp;&amp; (!containsReturn || allowedReturn)</span>
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">				&amp;&amp; !containsNEFs &amp;&amp; !containsNestedLoop;</span>
	}

	/**
	 * Checks if the loop contains a reducer pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for accumulator patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;i++, i--, ++i, --i&lt;/li&gt;
	 * &lt;li&gt;sum += x, product *= x, count -= 1&lt;/li&gt;
	 * &lt;li&gt;Other compound assignments (|=, &amp;=, etc.)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a reducer pattern is detected, false otherwise
	 * 
	 * @see #getReducer()
	 */
	public boolean isReducer() {
<span class="nc" id="L141">		return hasReducer;</span>
	}

	/**
	 * Returns the statement containing the reducer pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple reducers exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the reducer, or null if no reducer was
	 *         detected
	 * 
	 * @see #isReducer()
	 */
	public Statement getReducer() {
<span class="nc" id="L158">		return reducerStatement;</span>
	}

	/**
	 * Checks if the loop matches the anyMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AnyMatch pattern: loop contains {@code if (condition) return true;}
	 * &lt;/p&gt;
	 * 
	 * @return true if anyMatch pattern is detected
	 */
	public boolean isAnyMatchPattern() {
<span class="fc" id="L171">		return isAnyMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the noneMatch pattern.
	 * 
	 * &lt;p&gt;
	 * NoneMatch pattern: loop contains {@code if (condition) return false;}
	 * &lt;/p&gt;
	 * 
	 * @return true if noneMatch pattern is detected
	 */
	public boolean isNoneMatchPattern() {
<span class="fc" id="L184">		return isNoneMatchPattern;</span>
	}

	/**
	 * Checks if the loop matches the allMatch pattern.
	 * 
	 * &lt;p&gt;
	 * AllMatch pattern: loop contains {@code if (condition) return false;} but the
	 * method returns true after the loop, or {@code if (!condition) return false;}
	 * checking all elements meet a condition.
	 * &lt;/p&gt;
	 * 
	 * @return true if allMatch pattern is detected
	 */
	public boolean isAllMatchPattern() {
<span class="fc" id="L199">		return isAllMatchPattern;</span>
	}

	/**
	 * Checks if the loop contains a collect pattern.
	 * 
	 * &lt;p&gt;
	 * Scans loop body for collection accumulation patterns such as:
	 * &lt;ul&gt;
	 * &lt;li&gt;result.add(item)&lt;/li&gt;
	 * &lt;li&gt;set.add(value)&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @return true if a collect pattern is detected, false otherwise
	 * 
	 * @see #getCollectStatement()
	 * @see #getCollectTarget()
	 */
	public boolean isCollectPattern() {
<span class="nc" id="L218">		return hasCollectPattern;</span>
	}

	/**
	 * Returns the statement containing the collect pattern.
	 * 
	 * &lt;p&gt;
	 * If multiple collect statements exist in the loop, this returns only the first one
	 * encountered.
	 * &lt;/p&gt;
	 * 
	 * @return the statement containing the collect operation, or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public Statement getCollectStatement() {
<span class="nc" id="L234">		return collectStatement;</span>
	}

	/**
	 * Returns the target collection variable name for the collect pattern.
	 * 
	 * @return the target variable name (e.g., &quot;result&quot;), or null if no collect was detected
	 * 
	 * @see #isCollectPattern()
	 */
	public String getCollectTarget() {
<span class="nc" id="L245">		return collectTargetVariable;</span>
	}

	/**
	 * Analyzes the loop statement to identify relevant elements for refactoring.
	 * 
	 * &lt;p&gt;
	 * This method uses {@link AstProcessorBuilder} for cleaner and more
	 * maintainable AST traversal. It performs the following analysis:
	 * &lt;ul&gt;
	 * &lt;li&gt;Collects variable declarations within the loop&lt;/li&gt;
	 * &lt;li&gt;Detects control flow statements (break, continue, return, throw)&lt;/li&gt;
	 * &lt;li&gt;Identifies reducer patterns (i++, sum += x, etc.)&lt;/li&gt;
	 * &lt;li&gt;Detects early return patterns (anyMatch, noneMatch, allMatch)&lt;/li&gt;
	 * &lt;li&gt;Checks if variables are effectively final&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The analysis results are stored in instance variables that can be queried via
	 * getter methods like {@link #isSafeToRefactor()}, {@link #isReducer()}, etc.
	 * &lt;/p&gt;
	 */
	private void analyzeLoop() {
<span class="fc" id="L268">		AstProcessorBuilder&lt;String, Object&gt; builder = AstProcessorBuilder.with(new ReferenceHolder&lt;String, Object&gt;());</span>

<span class="fc" id="L270">		builder.onVariableDeclarationFragment((node, h) -&gt; {</span>
<span class="nc" id="L271">			innerVariables.add(node);</span>
<span class="nc" id="L272">			return true;</span>
<span class="fc" id="L273">		}).onBreakStatement((node, h) -&gt; {</span>
<span class="nc" id="L274">			containsBreak = true;</span>
<span class="nc" id="L275">			return true;</span>
<span class="fc" id="L276">		}).onLabeledContinue((node, h) -&gt; {</span>
			// Labeled continue should prevent conversion (unlabeled continues are allowed)
<span class="nc" id="L278">			containsLabeledContinue = true;</span>
<span class="nc" id="L279">			return true;</span>
<span class="fc" id="L280">		}).onReturnStatement((node, h) -&gt; {</span>
<span class="nc" id="L281">			containsReturn = true;</span>
<span class="nc" id="L282">			return true;</span>
<span class="fc" id="L283">		}).onThrowStatement((node, h) -&gt; {</span>
<span class="nc" id="L284">			throwsException = true;</span>
<span class="nc" id="L285">			return true;</span>
<span class="fc" id="L286">		}).onEnhancedForStatement((node, h) -&gt; {</span>
			// If we encounter another EnhancedForStatement inside the loop body,
			// it's a nested loop.
			// PHASE 9: With LoopTree, nested loops are handled separately in the tree.
			// We should NOT descend into them, as they'll be analyzed independently.
			// Only mark as containsNestedLoop if this is the root loop we're analyzing.
<span class="nc bnc" id="L292" title="All 2 branches missed.">			if (node == loop) {</span>
<span class="nc" id="L293">				return true; // Continue analyzing this loop's body</span>
			}
			// Found a nested loop - don't descend into it (return false)
			// The LoopTree will handle this nested loop separately
<span class="nc" id="L297">			return false;</span>
<span class="fc" id="L298">		}).onForStatement((node, h) -&gt; {</span>
			// Traditional for loops inside the enhanced-for also prevent conversion
<span class="nc" id="L300">			containsNestedLoop = true;</span>
<span class="nc" id="L301">			return true;</span>
<span class="fc" id="L302">		}).onWhileStatement((node, h) -&gt; {</span>
			// While loops inside the enhanced-for also prevent conversion
<span class="nc" id="L304">			containsNestedLoop = true;</span>
<span class="nc" id="L305">			return true;</span>
<span class="fc" id="L306">		}).onDoStatement((node, h) -&gt; {</span>
			// Do-while loops inside the enhanced-for also prevent conversion
<span class="nc" id="L308">			containsNestedLoop = true;</span>
<span class="nc" id="L309">			return true;</span>
<span class="fc" id="L310">		}).onTryStatement((node, h) -&gt; {</span>
			// Try-catch blocks inside the loop prevent conversion
			// (exception handling in lambdas is complex)
<span class="nc" id="L313">			containsNEFs = true;</span>
<span class="nc" id="L314">			return true;</span>
<span class="fc" id="L315">		}).onSwitchStatement((node, h) -&gt; {</span>
			// Switch statements inside the loop prevent conversion
<span class="nc" id="L317">			containsNEFs = true;</span>
<span class="nc" id="L318">			return true;</span>
<span class="fc" id="L319">		}).onSynchronizedStatement((node, h) -&gt; {</span>
			// Synchronized blocks inside the loop prevent conversion
<span class="nc" id="L321">			containsNEFs = true;</span>
<span class="nc" id="L322">			return true;</span>
<span class="fc" id="L323">		}).onCompoundAssignment((node, h) -&gt; {</span>
			// Compound assignments: +=, -=, *=, /=, |=, &amp;=, etc.
<span class="nc" id="L325">			markAsReducer(node);</span>
<span class="nc" id="L326">			return true;</span>
<span class="fc" id="L327">		}).onAssignment((node, h) -&gt; {</span>
			// Check for Math.max/Math.min patterns: max = Math.max(max, x)
<span class="nc bnc" id="L329" title="All 4 branches missed.">			if (node.getOperator() == Assignment.Operator.ASSIGN &amp;&amp; isMathMinMaxReducerPattern(node)) {</span>
<span class="nc" id="L330">				markAsReducer(node);</span>
			}
<span class="nc" id="L332">			return true;</span>
<span class="fc" id="L333">		}).onPostfixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect i++, i--
<span class="nc" id="L335">			markAsReducer(node);</span>
<span class="nc" id="L336">			return true;</span>
<span class="fc" id="L337">		}).onPrefixIncrementOrDecrement((node, h) -&gt; {</span>
			// Detect ++i, --i
<span class="nc" id="L339">			markAsReducer(node);</span>
<span class="nc" id="L340">			return true;</span>
<span class="fc" id="L341">		}).onMethodInvocation((node, h) -&gt; {</span>
			// Detect collection.add() patterns for collect operation
<span class="nc bnc" id="L343" title="All 2 branches missed.">			if (isCollectPattern(node)) {</span>
<span class="nc" id="L344">				markAsCollectPattern(node);</span>
			}
<span class="nc" id="L346">			return true;</span>
		});

		// First, analyze just the loop itself
<span class="fc" id="L350">		builder.build(loop);</span>

		// Save the containsReturn flag state after analyzing only the loop body
		// This is important because we want to distinguish between:
		// 1. Returns INSIDE the loop (which may prevent conversion, except for match patterns)
		// 2. Returns AFTER the loop (which are just part of the method and shouldn't prevent conversion)
<span class="fc" id="L356">		boolean containsReturnInsideLoop = containsReturn;</span>

		// Then, if the loop is inside a Block, analyze only the immediately following
		// statement (if any). This lets us detect patterns that depend on the statement
		// right after the loop without pulling in unrelated statements.
<span class="fc" id="L361">		ASTNode parent = loop.getParent();</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">		if (parent instanceof Block) {</span>
<span class="fc" id="L363">			Block block = (Block) parent;</span>
<span class="fc" id="L364">			List&lt;Statement&gt; statements = block.statements();</span>
<span class="fc" id="L365">			int loopIndex = statements.indexOf(loop);</span>
<span class="pc bpc" id="L366" title="2 of 4 branches missed.">			if (loopIndex != -1 &amp;&amp; loopIndex + 1 &lt; statements.size()) {</span>
<span class="fc" id="L367">				Statement followingStatement = statements.get(loopIndex + 1);</span>
<span class="fc" id="L368">				builder.build(followingStatement);</span>
			}
		}

		// Detect anyMatch/noneMatch patterns
		// This needs to see if there's a return statement after the loop,
		// so containsReturn may be true from analyzing the following statement
<span class="fc" id="L375">		detectEarlyReturnPatterns();</span>

		// Restore the containsReturn flag to only reflect returns INSIDE the loop
		// This ensures that isSafeToRefactor() only rejects loops with returns inside,
		// not loops followed by return statements (like reducers)
<span class="fc" id="L380">		containsReturn = containsReturnInsideLoop;</span>
		
		// NOTE: Effectively-final variable checks for nested loops are now handled
		// by LoopToFunctional.endVisitLoop() using LoopTree/ScopeInfo, which properly
		// tracks modifications in ancestor scopes while allowing reducer patterns.
<span class="fc" id="L385">	}</span>

	/**
	 * Marks an AST node as a reducer pattern and records its statement.
	 * 
	 * @param node the AST node that represents a reducer operation
	 */
	private void markAsReducer(ASTNode node) {
<span class="nc" id="L393">		hasReducer = true;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">		if (reducerStatement == null) {</span>
<span class="nc" id="L395">			reducerStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
<span class="nc" id="L397">	}</span>

	/**
	 * Marks an AST node as a collect pattern and records its statement.
	 * 
	 * @param node the AST node that represents a collect operation (MethodInvocation)
	 */
	private void markAsCollectPattern(ASTNode node) {
<span class="nc" id="L405">		hasCollectPattern = true;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">		if (collectStatement == null) {</span>
<span class="nc" id="L407">			collectStatement = ASTNodes.getFirstAncestorOrNull(node, Statement.class);</span>
		}
		// Extract target variable from the MethodInvocation
<span class="nc bnc" id="L410" title="All 4 branches missed.">		if (node instanceof MethodInvocation methodInv &amp;&amp; collectTargetVariable == null) {</span>
<span class="nc" id="L411">			Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">			if (receiver instanceof SimpleName) {</span>
<span class="nc" id="L413">				collectTargetVariable = ((SimpleName) receiver).getIdentifier();</span>
			}
		}
<span class="nc" id="L416">	}</span>

	/**
	 * Checks if a method invocation represents a collect pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code result.add(item)} or {@code set.add(value)}&lt;/p&gt;
	 * 
	 * @param methodInv the method invocation to check
	 * @return true if this is a collect pattern
	 */
	private boolean isCollectPattern(MethodInvocation methodInv) {
		// Check if method name is &quot;add&quot;
<span class="nc bnc" id="L428" title="All 2 branches missed.">		if (!&quot;add&quot;.equals(methodInv.getName().getIdentifier())) {</span>
<span class="nc" id="L429">			return false;</span>
		}
		
		// Check if invoked on a SimpleName (collection variable)
<span class="nc" id="L433">		Expression receiver = methodInv.getExpression();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (!(receiver instanceof SimpleName)) {</span>
<span class="nc" id="L435">			return false;</span>
		}
		
		// Check if add() has one argument
<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (methodInv.arguments().size() != 1) {</span>
<span class="nc" id="L440">			return false;</span>
		}
		
		// Additional validation: check if the receiver is a collection type
		// This is done in CollectPatternDetector, but for preconditions checking
		// we'll allow it here and let the detector do the full validation
<span class="nc" id="L446">		return true;</span>
	}

	/**
	 * Checks if an assignment represents a Math.max or Math.min reducer pattern.
	 * 
	 * &lt;p&gt;Pattern: {@code max = Math.max(max, x)} or {@code min = Math.min(min, x)}&lt;/p&gt;
	 * 
	 * @param assignment the assignment to check
	 * @return true if this is a Math.max/Math.min reducer pattern
	 */
	private boolean isMathMinMaxReducerPattern(Assignment assignment) {
<span class="nc" id="L458">		Expression rhs = assignment.getRightHandSide();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">		if (!(rhs instanceof MethodInvocation methodInv)) {</span>
<span class="nc" id="L460">			return false;</span>
		}
		
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (!isMathMinMaxInvocation(methodInv)) {</span>
<span class="nc" id="L464">			return false;</span>
		}
		
<span class="nc" id="L467">		return isLhsVariableInArguments(assignment.getLeftHandSide(), methodInv.arguments());</span>
	}

	/**
	 * Checks if a method invocation is Math.max or Math.min.
	 */
	private boolean isMathMinMaxInvocation(MethodInvocation methodInv) {
<span class="nc" id="L474">		Expression methodExpr = methodInv.getExpression();</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">		if (!(methodExpr instanceof SimpleName className)) {</span>
<span class="nc" id="L476">			return false;</span>
		}
		
<span class="nc bnc" id="L479" title="All 2 branches missed.">		if (!&quot;Math&quot;.equals(className.getIdentifier())) {</span>
<span class="nc" id="L480">			return false;</span>
		}
		
<span class="nc" id="L483">		String methodName = methodInv.getName().getIdentifier();</span>
<span class="nc bnc" id="L484" title="All 4 branches missed.">		return &quot;max&quot;.equals(methodName) || &quot;min&quot;.equals(methodName);</span>
	}

	/**
	 * Checks if the LHS variable name appears in the method arguments.
	 */
	private boolean isLhsVariableInArguments(Expression lhs, List&lt;?&gt; arguments) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">		if (!(lhs instanceof SimpleName lhsName)) {</span>
<span class="nc" id="L492">			return false;</span>
		}
		
<span class="nc bnc" id="L495" title="All 2 branches missed.">		if (arguments.size() != 2) {</span>
<span class="nc" id="L496">			return false;</span>
		}
		
<span class="nc" id="L499">		String varName = lhsName.getIdentifier();</span>
<span class="nc" id="L500">		return arguments.stream()</span>
<span class="nc" id="L501">				.filter(SimpleName.class::isInstance)</span>
<span class="nc" id="L502">				.map(SimpleName.class::cast)</span>
<span class="nc" id="L503">				.anyMatch(arg -&gt; varName.equals(arg.getIdentifier()));</span>
	}

	/**
	 * Detects anyMatch, noneMatch, and allMatch patterns in the loop.
	 * 
	 * &lt;p&gt;
	 * Patterns:
	 * &lt;ul&gt;
	 * &lt;li&gt;AnyMatch: {@code if (condition) return true;}&lt;/li&gt;
	 * &lt;li&gt;NoneMatch: {@code if (condition) return false;}&lt;/li&gt;
	 * &lt;li&gt;AllMatch: {@code if (!condition) return false;} or
	 * {@code if (condition) return false;} when negated&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * These patterns must be the only statement with a return in the loop body.
	 * 
	 * &lt;p&gt;
	 * AllMatch is typically used in patterns like:
	 * 
	 * &lt;pre&gt;
	 * for (Item item : items) {
	 * 	if (!item.isValid())
	 * 		return false;
	 * }
	 * return true;
	 * &lt;/pre&gt;
	 */
	private void detectEarlyReturnPatterns() {
<span class="pc bpc" id="L533" title="3 of 4 branches missed.">		if (!containsReturn || !(loop instanceof EnhancedForStatement)) {</span>
<span class="fc" id="L534">			return;</span>
		}

<span class="nc" id="L537">		EnhancedForStatement forLoop = (EnhancedForStatement) loop;</span>
<span class="nc" id="L538">		Statement body = forLoop.getBody();</span>

		// Find all IF statements with return statements in the loop
<span class="nc" id="L541">		final List&lt;IfStatement&gt; ifStatementsWithReturn = new ArrayList&lt;&gt;();</span>

		// Use ASTVisitor to find IF statements
<span class="nc" id="L544">		body.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(IfStatement node) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">				if (hasReturnInThenBranch(node)) {</span>
<span class="nc" id="L548">					ifStatementsWithReturn.add(node);</span>
				}
<span class="nc" id="L550">				return true;</span>
			}
		});

		// For anyMatch/noneMatch/allMatch, we expect exactly one IF with return
<span class="nc bnc" id="L555" title="All 2 branches missed.">		if (ifStatementsWithReturn.size() != 1) {</span>
<span class="nc" id="L556">			return;</span>
		}

<span class="nc" id="L559">		IfStatement ifStmt = ifStatementsWithReturn.get(0);</span>

		// The IF must not have an else branch for these patterns
<span class="nc bnc" id="L562" title="All 2 branches missed.">		if (ifStmt.getElseStatement() != null) {</span>
<span class="nc" id="L563">			return;</span>
		}

		// Check if the IF returns a boolean literal
<span class="nc" id="L567">		BooleanLiteral returnValue = getReturnValueFromIf(ifStmt);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if (returnValue == null) {</span>
<span class="nc" id="L569">			return;</span>
		}

		// Check what statement follows the loop
<span class="nc" id="L573">		BooleanLiteral followingReturn = getReturnAfterLoop(forLoop);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">		if (followingReturn == null) {</span>
<span class="nc" id="L575">			return;</span>
		}

		// Determine pattern based on return values
<span class="nc" id="L579">		determineMatchPattern(returnValue.booleanValue(), followingReturn.booleanValue(), ifStmt.getExpression());</span>
<span class="nc" id="L580">	}</span>

	/**
	 * Determines which match pattern (anyMatch, noneMatch, allMatch) applies based on
	 * the return values and condition.
	 * 
	 * @param returnValueInLoop the boolean value returned inside the loop
	 * @param returnValueAfterLoop the boolean value returned after the loop
	 * @param condition the condition expression in the if statement
	 */
	private void determineMatchPattern(boolean returnValueInLoop, boolean returnValueAfterLoop, Expression condition) {
<span class="nc bnc" id="L591" title="All 4 branches missed.">		if (returnValueInLoop &amp;&amp; !returnValueAfterLoop) {</span>
			// if (condition) return true; + return false; → anyMatch
<span class="nc" id="L593">			isAnyMatchPattern = true;</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">		} else if (!returnValueInLoop &amp;&amp; returnValueAfterLoop) {</span>
			// if (condition) return false; + return true; → could be noneMatch OR allMatch
			// Distinguish based on condition negation:
			// - if (!condition) return false; + return true; → allMatch(condition)
			// - if (condition) return false; + return true; → noneMatch(condition)
<span class="nc bnc" id="L599" title="All 2 branches missed.">			if (isNegatedCondition(condition)) {</span>
<span class="nc" id="L600">				isAllMatchPattern = true;</span>
<span class="nc" id="L601">			} else {</span>
<span class="nc" id="L602">				isNoneMatchPattern = true;</span>
			}
		}
<span class="nc" id="L605">	}</span>

	/**
	 * Checks if the IF statement has a return in its then branch.
	 */
	private boolean hasReturnInThenBranch(IfStatement ifStmt) {
<span class="nc" id="L611">		return getReturnStatementFromThenBranch(ifStmt).isPresent();</span>
	}

	/**
	 * Extracts the return statement from the then branch of an if statement.
	 * Handles both direct return statements and blocks with a single return statement.
	 * 
	 * @param ifStmt the if statement to check
	 * @return Optional containing the ReturnStatement, or empty if not found
	 */
	private Optional&lt;ReturnStatement&gt; getReturnStatementFromThenBranch(IfStatement ifStmt) {
<span class="nc" id="L622">		Statement thenStmt = ifStmt.getThenStatement();</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">		if (thenStmt instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L625">			return Optional.of(returnStmt);</span>
		}

<span class="nc bnc" id="L628" title="All 2 branches missed.">		if (thenStmt instanceof Block block) {</span>
<span class="nc" id="L629">			List&lt;?&gt; stmts = block.statements();</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">			if (stmts.size() == 1 &amp;&amp; stmts.get(0) instanceof ReturnStatement returnStmt) {</span>
<span class="nc" id="L631">				return Optional.of(returnStmt);</span>
			}
		}

<span class="nc" id="L635">		return Optional.empty();</span>
	}

	/**
	 * Extracts the boolean literal value from a return statement in an IF.
	 * 
	 * @return the BooleanLiteral if the IF returns a boolean literal, null
	 *         otherwise
	 */
	private BooleanLiteral getReturnValueFromIf(IfStatement ifStmt) {
<span class="nc" id="L645">		return getReturnStatementFromThenBranch(ifStmt)</span>
<span class="nc" id="L646">				.map(ReturnStatement::getExpression)</span>
<span class="nc" id="L647">				.filter(BooleanLiteral.class::isInstance)</span>
<span class="nc" id="L648">				.map(BooleanLiteral.class::cast)</span>
<span class="nc" id="L649">				.orElse(null);</span>
	}

	/**
	 * Checks if an expression is a negated condition (starts with !).
	 * Handles ParenthesizedExpression wrapping.
	 * 
	 * @param expr the expression to check
	 * @return true if the expression is a PrefixExpression with NOT operator (possibly wrapped in parentheses)
	 */
	private boolean isNegatedCondition(Expression expr) {
		// Unwrap parentheses
<span class="nc bnc" id="L661" title="All 2 branches missed.">		while (expr instanceof ParenthesizedExpression) {</span>
<span class="nc" id="L662">			expr = ((ParenthesizedExpression) expr).getExpression();</span>
		}
		
<span class="nc bnc" id="L665" title="All 2 branches missed.">		return expr instanceof PrefixExpression</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">				&amp;&amp; ((PrefixExpression) expr).getOperator() == PrefixExpression.Operator.NOT;</span>
	}

	/**
	 * Gets the boolean return value from the statement immediately following the loop.
	 * 
	 * &lt;p&gt;
	 * For anyMatch/allMatch/noneMatch patterns, we expect a return statement with a
	 * boolean literal immediately after the loop. This method finds the loop's parent
	 * (usually a Block), locates the loop, and checks the next statement.
	 * &lt;/p&gt;
	 * 
	 * @param forLoop the EnhancedForStatement to check
	 * @return the BooleanLiteral returned after the loop, or null if not found
	 */
	private BooleanLiteral getReturnAfterLoop(EnhancedForStatement forLoop) {
<span class="nc" id="L682">		ASTNode parent = forLoop.getParent();</span>
		
		// The loop must be in a Block (method body, if-then block, etc.)
<span class="nc bnc" id="L685" title="All 2 branches missed.">		if (!(parent instanceof Block)) {</span>
<span class="nc" id="L686">			return null;</span>
		}
		
<span class="nc" id="L689">		Block block = (Block) parent;</span>
<span class="nc" id="L690">		List&lt;?&gt; statements = block.statements();</span>
		
		// Find the loop in the block's statements
<span class="nc" id="L693">		int loopIndex = statements.indexOf(forLoop);</span>
<span class="nc bnc" id="L694" title="All 4 branches missed.">		if (loopIndex == -1 || loopIndex &gt;= statements.size() - 1) {</span>
			// Loop not found or is the last statement
<span class="nc" id="L696">			return null;</span>
		}
		
		// Check the next statement
<span class="nc" id="L700">		Statement nextStmt = (Statement) statements.get(loopIndex + 1);</span>
		
		// We expect a return statement with a boolean literal
<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (nextStmt instanceof ReturnStatement) {</span>
<span class="nc" id="L704">			ReturnStatement returnStmt = (ReturnStatement) nextStmt;</span>
<span class="nc" id="L705">			Expression expr = returnStmt.getExpression();</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">			if (expr instanceof BooleanLiteral) {</span>
<span class="nc" id="L707">				return (BooleanLiteral) expr;</span>
			}
		}
		
<span class="nc" id="L711">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>