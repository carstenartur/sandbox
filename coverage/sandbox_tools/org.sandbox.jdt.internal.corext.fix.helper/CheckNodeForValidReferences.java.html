<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CheckNodeForValidReferences.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_tools</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">CheckNodeForValidReferences.java</span></div><h1>CheckNodeForValidReferences.java</h1><pre class="source lang-java linenums">package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.Iterator;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.IVariableBinding;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.internal.corext.dom.AbortSearchException;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.sandbox.ast.api.expr.ASTExpr;
import org.sandbox.ast.api.expr.MethodInvocationExpr;
import org.sandbox.ast.api.expr.SimpleNameExpr;
import org.sandbox.ast.api.jdt.FluentASTVisitor;
import org.sandbox.ast.api.jdt.JDTConverter;

class CheckNodeForValidReferences {
<span class="nc" id="L27">	private static final String ITERATOR_NAME= Iterator.class.getCanonicalName();</span>

	private final ASTNode fASTNode;
	private final boolean fLocalVarsOnly;

<span class="nc" id="L32">	public CheckNodeForValidReferences(ASTNode node, boolean localVarsOnly) {</span>
<span class="nc" id="L33">		fASTNode= node;</span>
<span class="nc" id="L34">		fLocalVarsOnly= localVarsOnly;</span>
<span class="nc" id="L35">	}</span>

	public boolean isValid() {
<span class="nc" id="L38">		FluentASTVisitor visitor= new FluentASTVisitor() {</span>

			@Override
			public boolean visit(FieldAccess visitedField) {
<span class="nc bnc" id="L42" title="All 2 branches missed.">				if (visitedField.resolveFieldBinding() == null) {</span>
<span class="nc" id="L43">					throw new AbortSearchException();</span>
				}
<span class="nc bnc" id="L45" title="All 4 branches missed.">				if (fLocalVarsOnly &amp;&amp; visitedField.getLocationInParent() == MethodInvocation.EXPRESSION_PROPERTY) {</span>
<span class="nc" id="L46">					MethodInvocation methodInvocation= ASTNodes.getParent(visitedField, MethodInvocation.class);</span>
<span class="nc" id="L47">					MethodInvocationExpr miExpr= JDTConverter.convert(methodInvocation);</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">					if (miExpr.returnsType(ITERATOR_NAME)) {</span>
<span class="nc" id="L49">						throw new AbortSearchException();</span>
					}
				}
<span class="nc" id="L52">				return true;</span>
			}

			@Override
			public boolean visit(SuperFieldAccess visitedField) {
<span class="nc bnc" id="L57" title="All 2 branches missed.">				if (visitedField.resolveFieldBinding() == null) {</span>
<span class="nc" id="L58">					throw new AbortSearchException();</span>
				}
<span class="nc bnc" id="L60" title="All 4 branches missed.">				if (fLocalVarsOnly &amp;&amp; visitedField.getLocationInParent() == MethodInvocation.EXPRESSION_PROPERTY) {</span>
<span class="nc" id="L61">					MethodInvocation methodInvocation= ASTNodes.getParent(visitedField, MethodInvocation.class);</span>
<span class="nc" id="L62">					MethodInvocationExpr miExpr= JDTConverter.convert(methodInvocation);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">					if (miExpr.returnsType(ITERATOR_NAME)) {</span>
<span class="nc" id="L64">						throw new AbortSearchException();</span>
					}
				}
<span class="nc" id="L67">				return true;</span>
			}

			@Override
			protected boolean visitMethodInvocation(MethodInvocationExpr miExpr, MethodInvocation methodInvocation) {
<span class="nc bnc" id="L72" title="All 2 branches missed.">				if (fLocalVarsOnly) {</span>
<span class="nc" id="L73">					IMethodBinding methodInvocationBinding= methodInvocation.resolveMethodBinding();</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">					if (methodInvocationBinding == null) {</span>
<span class="nc" id="L75">						throw new AbortSearchException();</span>
					}
<span class="nc" id="L77">					ITypeBinding methodTypeBinding= methodInvocationBinding.getReturnType();</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">					if (AbstractTool.isOfType(methodTypeBinding, ITERATOR_NAME)) {</span>
<span class="nc" id="L79">						Expression exp= methodInvocation.getExpression();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">						if (exp instanceof SimpleName simpleName) {</span>
<span class="nc" id="L81">							SimpleNameExpr nameExpr= JDTConverter.convert(simpleName);</span>
<span class="nc" id="L82">							IBinding binding= simpleName.resolveBinding();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">							if (binding instanceof IVariableBinding varBinding) {</span>
								// Check using fluent API for field and parameter, but use JDT for record component
<span class="nc" id="L85">								if (nameExpr.resolveVariable()</span>
<span class="nc bnc" id="L86" title="All 4 branches missed.">										.filter(var -&gt; !var.isField() &amp;&amp; !var.isParameter())</span>
<span class="nc" id="L87">										.filter(var -&gt; var.hasType(ITERATOR_NAME))</span>
<span class="nc bnc" id="L88" title="All 4 branches missed.">										.isPresent() &amp;&amp; !varBinding.isRecordComponent()) {</span>
<span class="nc" id="L89">									return true;</span>
								}
							}
						}
<span class="nc" id="L93">						throw new AbortSearchException();</span>
					}
				}
<span class="nc" id="L96">				return true;</span>
			}

			@Override
			public boolean visit(CastExpression castExpression) {
<span class="nc" id="L101">				Type castType= castExpression.getType();</span>
<span class="nc" id="L102">				ITypeBinding typeBinding= castType.resolveBinding();</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">				if (AbstractTool.isOfType(typeBinding, ITERATOR_NAME)) {</span>
<span class="nc" id="L104">					Expression exp= castExpression.getExpression();</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">					if (exp instanceof Name) {</span>
<span class="nc" id="L106">						SimpleNameExpr nameExpr= JDTConverter.convertExpression(exp)</span>
<span class="nc" id="L107">								.flatMap(ASTExpr::asSimpleName)</span>
<span class="nc" id="L108">								.orElse(null);</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">						if (nameExpr != null &amp;&amp; nameExpr.isVariable()) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">							if (!fLocalVarsOnly) {</span>
								// For non-local mode, require field, parameter, or record component
<span class="nc bnc" id="L112" title="All 2 branches missed.">								if (nameExpr.isLocalVariable()) {</span>
<span class="nc" id="L113">									throw new AbortSearchException();</span>
								}
							} else {
								// For local-only mode, reject field, parameter, or record component
<span class="nc bnc" id="L117" title="All 2 branches missed.">								if (!nameExpr.isLocalVariable()) {</span>
<span class="nc" id="L118">									throw new AbortSearchException();</span>
								}
							}
<span class="nc" id="L121">							return true;</span>
						}
					}
<span class="nc" id="L124">					throw new AbortSearchException();</span>
				}
<span class="nc" id="L126">				return true;</span>
			}

			@Override
			protected boolean visitSimpleName(SimpleNameExpr nameExpr, SimpleName simpleName) {
<span class="nc bnc" id="L131" title="All 2 branches missed.">				if (!nameExpr.isVariable()) {</span>
<span class="nc" id="L132">					return true;</span>
				}
				
<span class="nc" id="L135">				return nameExpr.resolveVariable()</span>
<span class="nc" id="L136">						.filter(var -&gt; var.hasType(ITERATOR_NAME))</span>
<span class="nc" id="L137">						.map(var -&gt; {</span>
							// Check if SimpleName is used as receiver for a method invocation
<span class="nc bnc" id="L139" title="All 2 branches missed.">							if (simpleName.getLocationInParent() == MethodInvocation.EXPRESSION_PROPERTY) {</span>
<span class="nc" id="L140">								MethodInvocation methodInvocation= ASTNodes.getParent(simpleName, MethodInvocation.class);</span>
<span class="nc" id="L141">								MethodInvocationExpr miExpr= JDTConverter.convert(methodInvocation);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">								if (!miExpr.returnsType(ITERATOR_NAME)) {</span>
<span class="nc" id="L143">									return true;</span>
								}
							}
							
							// Check variable kind based on fLocalVarsOnly flag
<span class="nc bnc" id="L148" title="All 2 branches missed.">							if (!fLocalVarsOnly) {</span>
								// For non-local mode, require field, parameter, or record component
<span class="nc bnc" id="L150" title="All 2 branches missed.">								if (nameExpr.isLocalVariable()) {</span>
<span class="nc" id="L151">									throw new AbortSearchException();</span>
								}
							} else {
								// For local-only mode, reject field, parameter, or record component
<span class="nc bnc" id="L155" title="All 2 branches missed.">								if (!nameExpr.isLocalVariable()) {</span>
<span class="nc" id="L156">									throw new AbortSearchException();</span>
								}
							}
<span class="nc" id="L159">							return true;</span>
						})
<span class="nc" id="L161">						.orElse(true);</span>
			}
		};
		try {
<span class="nc" id="L165">			fASTNode.accept(visitor);</span>
<span class="nc" id="L166">			return true;</span>
<span class="nc" id="L167">		} catch (AbortSearchException e) {</span>
			// do nothing and fall through
		}
<span class="nc" id="L170">		return false;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>