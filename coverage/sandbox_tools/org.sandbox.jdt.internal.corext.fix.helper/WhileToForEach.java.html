<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WhileToForEach.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_tools</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">WhileToForEach.java</span></div><h1>WhileToForEach.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.IVariableBinding;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.StructuralPropertyDescriptor;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite.ImportRewriteContext;
import org.eclipse.jdt.core.dom.rewrite.ImportRewrite.TypeLocation;
import org.eclipse.jdt.internal.corext.codemanipulation.ContextSensitiveImportRewriteContext;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.eclipse.jdt.internal.corext.dom.AbortSearchException;
import org.eclipse.jdt.internal.corext.dom.Bindings;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperationWithSourceRange;
import org.eclipse.jdt.internal.corext.fix.ConvertLoopOperation;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.jdt.internal.corext.refactoring.structure.ImportRemover;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.ast.api.expr.MethodInvocationExpr;
import org.sandbox.ast.api.expr.SimpleNameExpr;
import org.sandbox.ast.api.jdt.JDTConverter;
import org.sandbox.jdt.internal.common.HelperVisitor;
import org.sandbox.jdt.internal.common.HelperVisitorFactory;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.UseIteratorToForLoopFixCore;

/**
 * Find: while (it.hasNext()){ System.out.println(it.next()); }
 *
 * Rewrite: for(Object o:collection) { System.out.println(o); });
 *
 */
<span class="fc" id="L75">public class WhileToForEach extends AbstractTool&lt;WhileLoopToChangeHit&gt; {</span>

	@Override
	public void find(UseIteratorToForLoopFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed,
			boolean createForOnlyIfVarUsed) {
<span class="fc" id="L81">		ReferenceHolder&lt;ASTNode, WhileLoopToChangeHit&gt; dataholder= new ReferenceHolder&lt;&gt;();</span>
<span class="fc" id="L82">		Map&lt;ASTNode, WhileLoopToChangeHit&gt; operationsMap= new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L83">		WhileLoopToChangeHit invalidHit= new WhileLoopToChangeHit(true);</span>
<span class="fc" id="L84">		HelperVisitorFactory.callVariableDeclarationStatementVisitor(Iterator.class, compilationUnit, dataholder,</span>
<span class="fc" id="L85">				nodesprocessed, (init_iterator, holder_a) -&gt; {</span>
<span class="fc" id="L86">					List&lt;Object&gt; computeVarName= computeVarName(init_iterator);</span>
<span class="fc" id="L87">					MethodInvocation iteratorCall= computeIteratorCall(init_iterator);</span>
<span class="pc bpc" id="L88" title="1 of 4 branches missed.">					if (computeVarName != null &amp;&amp; iteratorCall != null) {</span>
<span class="fc" id="L89">						Statement iteratorAssignment= ASTNodes.getFirstAncestorOrNull(iteratorCall,</span>
<span class="fc" id="L90">								Statement.class);</span>
<span class="fc" id="L91">						HelperVisitorFactory.callWhileStatementVisitor(init_iterator.getParent(), dataholder, nodesprocessed,</span>
<span class="fc" id="L92">								(whilestatement, holder) -&gt; {</span>
<span class="fc" id="L93">									String name= computeNextVarname(whilestatement);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">									if (computeVarName.get(0).equals(name)</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">											&amp;&amp; iteratorCall.getStartPosition() &lt; whilestatement.getStartPosition()) {</span>
<span class="fc" id="L96">										WhileLoopToChangeHit hit= holder.computeIfAbsent(whilestatement,</span>
<span class="fc" id="L97">												k -&gt; new WhileLoopToChangeHit());</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">										if (!createForOnlyIfVarUsed) {</span>
<span class="fc" id="L99">											hit.iteratorDeclaration= init_iterator;</span>
<span class="fc" id="L100">											hit.iteratorCall= iteratorAssignment;</span>
<span class="fc" id="L101">											hit.iteratorName= name;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">											if (computeVarName.size() == 1) {</span>
<span class="fc" id="L103">												hit.self= true;</span>
<span class="fc" id="L104">											} else {</span>
<span class="fc" id="L105">												hit.collectionExpression= (Expression) computeVarName.get(1);</span>
											}
<span class="fc" id="L107">											hit.whileStatement= whilestatement;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">											if (hit.self) {</span>
<span class="fc" id="L109">												hit.loopVarName= ConvertLoopOperation.modifyBaseName(&quot;i&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L110">											} else {</span>
<span class="fc" id="L111">												String collectionId= JDTConverter.identifierOf(hit.collectionExpression)</span>
<span class="fc" id="L112">														.orElse(&quot;element&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L113">												hit.loopVarName= ConvertLoopOperation.modifyBaseName(collectionId);</span>
											}
<span class="fc" id="L115">											operationsMap.put(whilestatement, hit);</span>
										}
<span class="fc" id="L117">										HelperVisitorFactory.callMethodInvocationVisitor(whilestatement.getBody(), dataholder,</span>
<span class="fc" id="L118">												nodesprocessed, (mi, holder2) -&gt; {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">													String identifier= mi.getExpression() instanceof SimpleName sn ? sn.getIdentifier() : null;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">													if (identifier != null) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">														if (!name.equals(identifier)) {</span>
<span class="fc" id="L122">															return true;</span>
														}
<span class="fc" id="L124">														MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="fc" id="L125">														String method= miExpr.methodName().orElse(&quot;&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L126">														WhileLoopToChangeHit previousHit= operationsMap</span>
<span class="fc" id="L127">																.get(whilestatement);</span>
<span class="pc bpc" id="L128" title="2 of 4 branches missed.">														if (previousHit != null &amp;&amp; (previousHit == invalidHit</span>
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">																|| previousHit.nextFound || !method.equals(&quot;next&quot;))) { //$NON-NLS-1$</span>
<span class="fc" id="L130">															operationsMap.put(whilestatement, invalidHit);</span>
<span class="fc" id="L131">															return true;</span>
														}
<span class="fc bfc" id="L133" title="All 2 branches covered.">														if (ASTNodes.getFirstAncestorOrNull(mi,</span>
<span class="fc" id="L134">																ExpressionStatement.class) != null</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">																&amp;&amp; createForOnlyIfVarUsed) {</span>
<span class="nc" id="L136">															operationsMap.put(whilestatement, invalidHit);</span>
<span class="nc" id="L137">															return true;</span>
														}
<span class="fc" id="L139">														hit.nextFound= true;</span>
<span class="fc" id="L140">														hit.iteratorName= name;</span>
<span class="fc" id="L141">														hit.iteratorDeclaration= init_iterator;</span>
<span class="fc" id="L142">														hit.iteratorCall= iteratorAssignment;</span>
<span class="fc" id="L143">														hit.whileStatement= whilestatement;</span>
<span class="fc" id="L144">														hit.loopVarDeclaration= mi;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">														if (computeVarName.size() == 1) {</span>
<span class="fc" id="L146">															hit.self= true;</span>
<span class="fc" id="L147">														} else {</span>
<span class="fc" id="L148">															hit.collectionExpression= (Expression) computeVarName</span>
<span class="fc" id="L149">																	.get(1);</span>
														}
<span class="fc" id="L151">														VariableDeclarationStatement typedAncestor= ASTNodes</span>
<span class="fc" id="L152">																.getTypedAncestor(mi,</span>
<span class="fc" id="L153">																		VariableDeclarationStatement.class);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">														if (typedAncestor != null) {</span>
<span class="fc" id="L155">															ITypeBinding iteratorTypeArgument= computeTypeArgument(</span>
<span class="fc" id="L156">																	init_iterator);</span>
<span class="fc" id="L157">															ITypeBinding varTypeBinding= typedAncestor.getType()</span>
<span class="fc" id="L158">																	.resolveBinding();</span>
<span class="pc bpc" id="L159" title="2 of 4 branches missed.">															if (varTypeBinding == null || iteratorTypeArgument == null</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">																	|| (!varTypeBinding.isEqualTo(iteratorTypeArgument)</span>
<span class="fc" id="L161">																			&amp;&amp; !Bindings.isSuperType(varTypeBinding,</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">																					iteratorTypeArgument))) {</span>
<span class="fc" id="L163">																operationsMap.put(whilestatement, invalidHit);</span>
<span class="fc" id="L164">																return true;</span>
															}
<span class="fc" id="L166">															VariableDeclarationFragment vdf= (VariableDeclarationFragment) typedAncestor</span>
<span class="fc" id="L167">																	.fragments().get(0);</span>
<span class="fc" id="L168">															hit.loopVarName= vdf.getName().getIdentifier();</span>
<span class="fc" id="L169">														} else {</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">															if (hit.self) {</span>
<span class="nc" id="L171">																hit.loopVarName= ConvertLoopOperation</span>
<span class="nc" id="L172">																		.modifyBaseName(&quot;i&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L173">															} else {</span>
<span class="fc" id="L174">																String collectionId= JDTConverter.identifierOf(hit.collectionExpression)</span>
<span class="fc" id="L175">																		.orElse(&quot;element&quot;); //$NON-NLS-1$</span>
<span class="fc" id="L176">																hit.loopVarName= ConvertLoopOperation.modifyBaseName(collectionId);</span>
															}
<span class="fc" id="L178">															hit.nextWithoutVariableDeclaration= true;</span>
														}
<span class="fc" id="L180">														operationsMap.put(whilestatement, hit);</span>
<span class="fc" id="L181">														HelperVisitor&lt;ReferenceHolder&lt;ASTNode, WhileLoopToChangeHit&gt;, ASTNode, WhileLoopToChangeHit&gt; helperVisitor= holder</span>
<span class="fc" id="L182">																.getHelperVisitor();</span>
<span class="fc" id="L183">														helperVisitor.nodesprocessed.add(whilestatement);</span>
<span class="fc" id="L184">														holder2.remove(whilestatement);</span>
													}
<span class="fc" id="L186">													return true;</span>
												});
									}
<span class="fc" id="L189">									return true;</span>
								});
					}
<span class="fc" id="L192">					return true;</span>
				});
<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (WhileLoopToChangeHit hit : operationsMap.values()) {</span>
<span class="pc bpc" id="L195" title="1 of 4 branches missed.">			if (!hit.isInvalid &amp;&amp; validate(hit)) {</span>
<span class="fc" id="L196">				operations.add(fixcore.rewrite(hit));</span>
			}
		}
<span class="fc" id="L199">	}</span>

	private static boolean validate(final WhileLoopToChangeHit hit) {
<span class="fc" id="L202">		ASTNode iterDeclarationParent= hit.iteratorDeclaration.getParent();</span>
<span class="fc" id="L203">		List&lt;StructuralPropertyDescriptor&gt; descs= iterDeclarationParent.structuralPropertiesForType();</span>
<span class="fc" id="L204">		boolean hasStatements= false;</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">		for (StructuralPropertyDescriptor desc : descs) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">			if (desc.getId().equals(&quot;statements&quot;)) { //$NON-NLS-1$</span>
<span class="fc" id="L207">				hasStatements= true;</span>
<span class="fc" id="L208">				break;</span>
			}
		}
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		if (!hasStatements) {</span>
<span class="nc" id="L212">			return false;</span>
		}
<span class="fc" id="L214">		ReferenceHolder&lt;ASTNode, WhileLoopToChangeHit&gt; dataholder= new ReferenceHolder&lt;&gt;();</span>
<span class="fc" id="L215">		Set&lt;ASTNode&gt; nodesprocessed= new HashSet&lt;&gt;();</span>
<span class="fc" id="L216">		VariableDeclarationFragment iterDeclFragment= (VariableDeclarationFragment) hit.iteratorDeclaration.fragments()</span>
<span class="fc" id="L217">				.get(0);</span>
<span class="fc" id="L218">		IVariableBinding iterBinding= iterDeclFragment.resolveBinding();</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">		if (iterBinding == null) {</span>
<span class="nc" id="L220">			return false;</span>
		}
<span class="fc" id="L222">		HelperVisitorFactory.callMethodInvocationVisitor(iterDeclarationParent, dataholder, nodesprocessed, (mi, holder2) -&gt; {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			String receiverIdentifier= mi.getExpression() instanceof SimpleName sn ? sn.getIdentifier() : null;</span>
<span class="fc bfc" id="L224" title="All 4 branches covered.">			if (receiverIdentifier != null &amp;&amp; receiverIdentifier.equals(hit.iteratorName)) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">				if (mi.getStartPosition() &lt; hit.whileStatement.getStartPosition()) {</span>
<span class="nc" id="L226">					hit.isInvalid= true;</span>
<span class="nc" id="L227">					return false;</span>
				}
			} else {
<span class="fc" id="L230">				MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">				if (miExpr.isMethodNamed(&quot;iterator&quot;)) { //$NON-NLS-1$</span>
<span class="fc" id="L232">					ASTNode assignment= ASTNodes.getFirstAncestorOrNull(mi, Assignment.class);</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">					if (assignment instanceof Assignment) {</span>
<span class="nc" id="L234">						Expression leftSide= ((Assignment) assignment).getLeftHandSide();</span>
<span class="nc" id="L235">						String assignedVarId= JDTConverter.identifierOf(leftSide)</span>
<span class="nc" id="L236">								.orElse(null);</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">						if (assignedVarId != null &amp;&amp; assignedVarId.equals(hit.iteratorName)) {</span>
<span class="nc" id="L238">							Statement stmt= ASTNodes.getFirstAncestorOrNull(assignment, Statement.class);</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">							if (stmt == null || stmt.getParent() != hit.whileStatement.getParent()) {</span>
<span class="nc" id="L240">								hit.isInvalid= true;</span>
<span class="nc" id="L241">								return false;</span>
							}
						}
					}
				}
			}
<span class="fc" id="L247">			return true;</span>
		});
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">		return !hit.isInvalid;</span>
	}

	private static String computeNextVarname(WhileStatement whilestatement) {
<span class="fc" id="L253">		Expression exp= whilestatement.getExpression();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">		if (exp instanceof MethodInvocation mi) {</span>
<span class="fc" id="L255">			MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">			if (miExpr.methodName().filter(name -&gt; name.equals(&quot;hasNext&quot;)).isPresent()) { //$NON-NLS-1$</span>
<span class="fc" id="L257">				return miExpr.receiver()</span>
<span class="fc" id="L258">						.flatMap(receiver -&gt; receiver.asSimpleName())</span>
<span class="fc" id="L259">						.flatMap(SimpleNameExpr::resolveVariable)</span>
<span class="fc" id="L260">						.map(var -&gt; var.name())</span>
<span class="fc" id="L261">						.orElse(null);</span>
			}
		}
<span class="nc" id="L264">		return null;</span>
	}

	private static List&lt;Object&gt; computeVarName(VariableDeclarationStatement node_a) {
<span class="fc" id="L268">		List&lt;Object&gt; objectList= new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">		if (node_a.fragments().size() &gt; 1) {</span>
<span class="nc" id="L270">			return null;</span>
		}
<span class="fc" id="L272">		VariableDeclarationFragment bli= (VariableDeclarationFragment) node_a.fragments().get(0);</span>
<span class="fc" id="L273">		objectList.add(bli.getName().getIdentifier());</span>
<span class="fc" id="L274">		Expression exp= bli.getInitializer();</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">		if (exp == null) {</span>
<span class="nc" id="L276">			exp= computeIteratorCall(node_a);</span>
		}
<span class="fc" id="L278">		MethodInvocation mi= ASTNodes.as(exp, MethodInvocation.class);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">		if (mi == null) {</span>
<span class="fc" id="L280">			return null;</span>
		}
<span class="fc" id="L282">		MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">		if (!miExpr.isMethodNamed(&quot;iterator&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L284">			return null;</span>
		}
<span class="fc" id="L286">		ITypeBinding iterableAncestor= null;</span>
<span class="fc" id="L287">		IMethodBinding miBinding= mi.resolveMethodBinding();</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">		if (miBinding != null) {</span>
<span class="fc" id="L289">			iterableAncestor= ASTNodes.findImplementedType(miBinding.getDeclaringClass(),</span>
<span class="fc" id="L290">					Iterable.class.getCanonicalName());</span>
		}
<span class="fc bfc" id="L292" title="All 4 branches covered.">		if (iterableAncestor == null || iterableAncestor.isRawType()) {</span>
<span class="fc" id="L293">			return null;</span>
		}
<span class="fc" id="L295">		Expression sn= ASTNodes.as(mi.getExpression(), Expression.class);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (sn != null) {</span>
<span class="fc" id="L297">			objectList.add(sn);</span>
		}
<span class="fc" id="L299">		return objectList;</span>
	}

	private static MethodInvocation computeIteratorCall(VariableDeclarationStatement node_a) {
<span class="fc" id="L303">		VariableDeclarationFragment bli= (VariableDeclarationFragment) node_a.fragments().get(0);</span>
<span class="fc" id="L304">		Expression exp= bli.getInitializer();</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">		if (exp == null) {</span>
<span class="nc" id="L306">			IBinding bliBinding= bli.getName().resolveBinding();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			if (bliBinding == null) {</span>
<span class="nc" id="L308">				return null;</span>
			}
<span class="nc" id="L310">			ASTNode parent= node_a.getParent();</span>
<span class="nc" id="L311">			ReferenceHolder&lt;ASTNode, Object&gt; dataholder= new ReferenceHolder&lt;&gt;();</span>
<span class="nc" id="L312">			Set&lt;ASTNode&gt; nodesprocessed= new HashSet&lt;&gt;();</span>
<span class="nc" id="L313">			final Object Invalid= new Object();</span>
			try {
<span class="nc" id="L315">				HelperVisitorFactory.callAssignmentVisitor(parent, dataholder, nodesprocessed, (assignment, holder2) -&gt; {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">					if (assignment.getStartPosition() &gt; node_a.getStartPosition()) {</span>
<span class="nc" id="L317">						Expression leftSide= assignment.getLeftHandSide();</span>
<span class="nc" id="L318">						SimpleName sn= ASTNodes.as(leftSide, SimpleName.class);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">						if (sn != null) {</span>
<span class="nc" id="L320">							IBinding binding= sn.resolveBinding();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">							if (binding.isEqualTo(bliBinding)) {</span>
<span class="nc" id="L322">								MethodInvocation mi= ASTNodes.as(assignment.getRightHandSide(), MethodInvocation.class);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">								if (mi == null) {</span>
<span class="nc" id="L324">									dataholder.put(node_a, Invalid);</span>
<span class="nc" id="L325">									throw new AbortSearchException();</span>
								}
<span class="nc" id="L327">								MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">								if (!miExpr.isMethodNamed(&quot;iterator&quot;) || (dataholder.get(node_a) != null)) { //$NON-NLS-1$</span>
<span class="nc" id="L329">									dataholder.put(node_a, Invalid);</span>
<span class="nc" id="L330">									throw new AbortSearchException();</span>
								}
<span class="nc" id="L332">								dataholder.put(node_a, mi);</span>
							}
						}
					}
<span class="nc" id="L336">					return true;</span>
				});
<span class="nc" id="L338">			} catch (AbortSearchException e) {</span>
				// do nothing
			}
<span class="nc" id="L341">			Object holderObject= dataholder.get(node_a);</span>
<span class="nc bnc" id="L342" title="All 4 branches missed.">			if (holderObject == Invalid || holderObject == null) {</span>
<span class="nc" id="L343">				return null;</span>
			}
<span class="nc" id="L345">			return (MethodInvocation) holderObject;</span>
		}
<span class="fc" id="L347">		return ASTNodes.as(exp, MethodInvocation.class);</span>
	}

	private static ITypeBinding computeTypeArgument(VariableDeclarationStatement node_a) {
<span class="fc" id="L351">		VariableDeclarationFragment bli= (VariableDeclarationFragment) node_a.fragments().get(0);</span>
<span class="fc" id="L352">		Expression exp= bli.getInitializer();</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">		if (exp == null) {</span>
<span class="nc" id="L354">			IBinding bliBinding= bli.getName().resolveBinding();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">			if (bliBinding == null) {</span>
<span class="nc" id="L356">				return null;</span>
			}
<span class="nc" id="L358">			ASTNode parent= node_a.getParent();</span>
<span class="nc" id="L359">			ReferenceHolder&lt;ASTNode, Object&gt; dataholder= new ReferenceHolder&lt;&gt;();</span>
<span class="nc" id="L360">			Set&lt;ASTNode&gt; nodesprocessed= new HashSet&lt;&gt;();</span>
<span class="nc" id="L361">			final Object Invalid= new Object();</span>
			try {
<span class="nc" id="L363">				HelperVisitorFactory.callAssignmentVisitor(parent, dataholder, nodesprocessed, (assignment, holder2) -&gt; {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">					if (assignment.getStartPosition() &gt; node_a.getStartPosition()) {</span>
<span class="nc" id="L365">						Expression leftSide= assignment.getLeftHandSide();</span>
<span class="nc" id="L366">						SimpleName sn= ASTNodes.as(leftSide, SimpleName.class);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">						if (sn != null) {</span>
<span class="nc" id="L368">							IBinding binding= sn.resolveBinding();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">							if (binding.isEqualTo(bliBinding)) {</span>
<span class="nc" id="L370">								MethodInvocation mi= ASTNodes.as(assignment.getRightHandSide(), MethodInvocation.class);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">								if (mi == null) {</span>
<span class="nc" id="L372">									dataholder.put(node_a, Invalid);</span>
<span class="nc" id="L373">									throw new AbortSearchException();</span>
								}
<span class="nc" id="L375">								MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">								if (!miExpr.isMethodNamed(&quot;iterator&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L377">									dataholder.put(node_a, Invalid);</span>
<span class="nc" id="L378">									throw new AbortSearchException();</span>
								}
<span class="nc" id="L380">								dataholder.put(node_a, mi);</span>
							}
						}
					}
<span class="nc" id="L384">					return true;</span>
				});
<span class="nc" id="L386">			} catch (AbortSearchException e) {</span>
				// do nothing
			}
<span class="nc" id="L389">			Object holderObject= dataholder.get(node_a);</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">			if (holderObject == Invalid || holderObject == null) {</span>
<span class="nc" id="L391">				return null;</span>
			}
<span class="nc" id="L393">			exp= (Expression) dataholder.get(node_a);</span>
		}
<span class="fc" id="L395">		MethodInvocation mi= ASTNodes.as(exp, MethodInvocation.class);</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">		if (mi != null) {</span>
<span class="fc" id="L397">			MethodInvocationExpr miExpr= JDTConverter.convert(mi);</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">			if (miExpr.isMethodNamed(&quot;iterator&quot;)) { //$NON-NLS-1$</span>
<span class="fc" id="L399">				ITypeBinding iterableAncestor= null;</span>
<span class="fc" id="L400">				IMethodBinding miBinding= mi.resolveMethodBinding();</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">				if (miBinding != null) {</span>
<span class="fc" id="L402">					iterableAncestor= ASTNodes.findImplementedType(miBinding.getDeclaringClass(),</span>
<span class="fc" id="L403">							Iterable.class.getCanonicalName());</span>
				}
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">				if (iterableAncestor != null) {</span>
<span class="fc" id="L406">					ITypeBinding[] typeArgs= iterableAncestor.getTypeArguments();</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">					if (typeArgs.length &gt; 0) {</span>
<span class="fc" id="L408">						return typeArgs[0];</span>
					}
				}
			}
		} else {
<span class="nc" id="L413">			ITypeBinding varTypeBinding= node_a.getType().resolveBinding();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">			if (varTypeBinding != null) {</span>
<span class="nc" id="L415">				ITypeBinding[] typeArgs= varTypeBinding.getTypeArguments();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">				if (typeArgs.length &gt; 0) {</span>
<span class="nc" id="L417">					return typeArgs[0];</span>
				}
			}
		}
<span class="nc" id="L421">		return node_a.getAST().resolveWellKnownType(&quot;java.lang.Object&quot;); //$NON-NLS-1$</span>
	}

	@Override
	public void rewrite(UseIteratorToForLoopFixCore upp, final WhileLoopToChangeHit hit,
			final CompilationUnitRewrite cuRewrite, TextEditGroup group) {
<span class="fc" id="L427">		ASTRewrite rewrite= cuRewrite.getASTRewrite();</span>
<span class="fc" id="L428">		AST ast= cuRewrite.getRoot().getAST();</span>

<span class="fc" id="L430">		ImportRewrite importRewrite= cuRewrite.getImportRewrite();</span>
<span class="fc" id="L431">		ImportRemover remover= cuRewrite.getImportRemover();</span>

<span class="fc" id="L433">		EnhancedForStatement newEnhancedForStatement= ast.newEnhancedForStatement();</span>

<span class="fc" id="L435">		SingleVariableDeclaration result= ast.newSingleVariableDeclaration();</span>

<span class="fc" id="L437">		SimpleName name= ast.newSimpleName(hit.loopVarName);</span>
<span class="fc" id="L438">		result.setName(name);</span>

		String looptargettype;
		Type type;
<span class="fc" id="L442">		ITypeBinding varBinding= null;</span>
<span class="pc bpc" id="L443" title="1 of 4 branches missed.">		if (hit.nextWithoutVariableDeclaration || !hit.nextFound) {</span>
<span class="fc" id="L444">			type= null;</span>
<span class="fc" id="L445">		} else {</span>
<span class="fc" id="L446">			Expression expression= hit.loopVarDeclaration.getExpression();</span>
<span class="fc" id="L447">			SimpleName variable= ASTNodes.as(expression, SimpleName.class);</span>
<span class="fc" id="L448">			looptargettype= variable.resolveTypeBinding().getErasure().getQualifiedName();</span>
<span class="fc" id="L449">			VariableDeclarationStatement typedAncestor= ASTNodes.getTypedAncestor(hit.loopVarDeclaration,</span>
<span class="fc" id="L450">					VariableDeclarationStatement.class);</span>
<span class="fc" id="L451">			type= typedAncestor.getType();</span>
<span class="fc" id="L452">			varBinding= type.resolveBinding();</span>
		}
<span class="pc bpc" id="L454" title="1 of 4 branches missed.">		if (type == null || varBinding == null) {</span>
<span class="fc" id="L455">			looptargettype= &quot;java.lang.Object&quot;; //$NON-NLS-1$</span>
<span class="fc" id="L456">			ITypeBinding binding= computeTypeArgument(hit.iteratorDeclaration);</span>
<span class="fc" id="L457">			Type collectionType= null;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">			if (binding != null) {</span>
<span class="fc" id="L459">				looptargettype= binding.getErasure().getQualifiedName();</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">				if (binding.isParameterizedType()) {</span>
<span class="nc" id="L461">					collectionType= handleParametrizedType(binding, ast, cuRewrite);</span>
				}
			}
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">			if (collectionType == null) {</span>
<span class="fc" id="L465">				collectionType= ast.newSimpleType(addImport(looptargettype, cuRewrite, ast));</span>
			}
<span class="fc" id="L467">			result.setType(collectionType);</span>
<span class="fc" id="L468">		} else {</span>
<span class="fc" id="L469">			Type importType= importType(varBinding, hit.iteratorDeclaration, importRewrite,</span>
<span class="fc" id="L470">					(CompilationUnit) hit.iteratorDeclaration.getRoot(), TypeLocation.LOCAL_VARIABLE);</span>
<span class="fc" id="L471">			remover.registerAddedImports(importType);</span>

<span class="fc" id="L473">			result.setType(importType);</span>
		}
<span class="fc" id="L475">		newEnhancedForStatement.setParameter(result);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (hit.self) {</span>
<span class="fc" id="L477">			ThisExpression newThisExpression= ast.newThisExpression();</span>
<span class="fc" id="L478">			newEnhancedForStatement.setExpression(newThisExpression);</span>
<span class="fc" id="L479">		} else {</span>
<span class="fc" id="L480">			Expression loopExpression= (Expression) rewrite.createCopyTarget(hit.collectionExpression);</span>
<span class="fc" id="L481">			newEnhancedForStatement.setExpression(loopExpression);</span>
		}
<span class="fc" id="L483">		ASTNodes.removeButKeepComment(rewrite, hit.iteratorDeclaration, group);</span>
<span class="fc" id="L484">		remover.registerRemovedNode(hit.iteratorDeclaration.getType());</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">		if (hit.iteratorCall != hit.iteratorDeclaration) {</span>
<span class="nc" id="L486">			ASTNodes.removeButKeepComment(rewrite, hit.iteratorCall, group);</span>
<span class="nc" id="L487">			remover.registerRemovedNode(hit.iteratorCall);</span>
		}
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">		if (hit.nextFound) {</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">			if (hit.nextWithoutVariableDeclaration) {</span>
				// remove it.next(); expression statements
<span class="fc" id="L492">				ASTNode loopVarDeclaration= hit.loopVarDeclaration;</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">				while (loopVarDeclaration.getParent() instanceof ParenthesizedExpression) {</span>
<span class="nc" id="L494">					loopVarDeclaration= loopVarDeclaration.getParent();</span>
				}
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">				if (loopVarDeclaration.getLocationInParent() == ExpressionStatement.EXPRESSION_PROPERTY) {</span>
<span class="nc" id="L497">					rewrite.remove(loopVarDeclaration.getParent(), group);</span>
<span class="nc" id="L498">					remover.registerRemovedNode(loopVarDeclaration);</span>
<span class="nc" id="L499">				} else {</span>
<span class="fc" id="L500">					ASTNodes.replaceButKeepComment(rewrite, hit.loopVarDeclaration, name, group);</span>
<span class="fc" id="L501">					remover.registerRemovedNode(hit.loopVarDeclaration);</span>
				}
<span class="fc" id="L503">			} else {</span>
<span class="fc" id="L504">				ASTNode node= ASTNodes.getTypedAncestor(hit.loopVarDeclaration, VariableDeclarationStatement.class);</span>
<span class="fc" id="L505">				ASTNodes.removeButKeepComment(rewrite, node, group);</span>
<span class="fc" id="L506">				remover.registerRemovedNode(node);</span>
			}
		}
<span class="fc" id="L509">		newEnhancedForStatement.setBody(ASTNodes.createMoveTarget(rewrite, hit.whileStatement.getBody()));</span>
<span class="fc" id="L510">		ASTNodes.replaceButKeepComment(rewrite, hit.whileStatement, newEnhancedForStatement, group);</span>
<span class="fc" id="L511">		remover.registerRemovedNode(hit.whileStatement.getExpression());</span>
<span class="fc" id="L512">		remover.applyRemoves(importRewrite);</span>
<span class="fc" id="L513">	}</span>

	private Type handleParametrizedType(ITypeBinding binding, AST ast, CompilationUnitRewrite cuRewrite) {
<span class="nc" id="L516">		ITypeBinding[] args= binding.getTypeArguments();</span>
<span class="nc" id="L517">		String looptargettype= binding.getErasure().getQualifiedName();</span>
<span class="nc" id="L518">		Type collectionType= ast.newSimpleType(addImport(looptargettype, cuRewrite, ast));</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">		if (binding.isParameterizedType()) {</span>
<span class="nc" id="L520">			ParameterizedType pType= ast.newParameterizedType(collectionType);</span>
<span class="nc" id="L521">			Collection&lt;Type&gt; typeArgs= new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">			for (ITypeBinding arg : args) {</span>
<span class="nc" id="L523">				Type argType= null;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">				if (arg.isParameterizedType()) {</span>
<span class="nc" id="L525">					argType= handleParametrizedType(arg, ast, cuRewrite);</span>
<span class="nc" id="L526">				} else {</span>
<span class="nc" id="L527">					looptargettype= arg.getQualifiedName();</span>
<span class="nc" id="L528">					argType= ast.newSimpleType(addImport(looptargettype, cuRewrite, ast));</span>
				}
<span class="nc" id="L530">				typeArgs.add(argType);</span>
			}
<span class="nc" id="L532">			pType.typeArguments().addAll(typeArgs);</span>
<span class="nc" id="L533">			collectionType= pType;</span>
		}
<span class="nc" id="L535">		return collectionType;</span>
	}

	private static Type importType(final ITypeBinding toImport, final ASTNode accessor, ImportRewrite imports,
			final CompilationUnit compilationUnit, TypeLocation location) {
<span class="fc" id="L540">		ImportRewriteContext importContext= new ContextSensitiveImportRewriteContext(compilationUnit,</span>
<span class="fc" id="L541">				accessor.getStartPosition(), imports);</span>
<span class="fc" id="L542">		return imports.addImport(toImport, compilationUnit.getAST(), importContext, location);</span>
	}

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">		if (afterRefactoring) {</span>
<span class="nc" id="L548">			return &quot;\nfor (String s : strings) {\n\n	System.out.println(s);\n}\n\n&quot;; //$NON-NLS-1$</span>
		}
<span class="nc" id="L550">		return &quot;Iterator it = lists.iterator();\nwhile (it.hasNext()) {\n    String s = (String) it.next();\n	System.out.println(s);\n}\n\n&quot;; //$NON-NLS-1$</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>