<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SwitchIntToEnumHelper.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">sandbox_coverage</a> &gt; <a href="../index.html" class="el_bundle">sandbox_int_to_enum</a> &gt; <a href="index.source.html" class="el_package">org.sandbox.jdt.internal.corext.fix.helper</a> &gt; <span class="el_source">SwitchIntToEnumHelper.java</span></div><h1>SwitchIntToEnumHelper.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2026 Carsten Hammer.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *     Carsten Hammer
 *******************************************************************************/
package org.sandbox.jdt.internal.corext.fix.helper;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IVariableBinding;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFixCore.CompilationUnitRewriteOperationWithSourceRange;
import org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite;
import org.eclipse.text.edits.TextEditGroup;
import org.sandbox.jdt.internal.common.ReferenceHolder;
import org.sandbox.jdt.internal.corext.fix.IntToEnumFixCore;
import org.sandbox.jdt.internal.corext.fix.helper.IntToEnumHelper.IntConstantHolder;

/**
 * Helper class for converting switch statements using int constants to use enums.
 *
 * &lt;p&gt;This handles the case where a switch statement already exists with int constant
 * case labels. The transformation:&lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Detects static final int constant declarations with a common underscore-delimited prefix&lt;/li&gt;
 * &lt;li&gt;Finds switch statements that use these constants as case labels&lt;/li&gt;
 * &lt;li&gt;Verifies the switch selector is a method parameter (so the type can be updated)&lt;/li&gt;
 * &lt;li&gt;Verifies constants are not referenced outside the switch (to avoid broken references)&lt;/li&gt;
 * &lt;li&gt;Generates an enum type from the constant names&lt;/li&gt;
 * &lt;li&gt;Replaces the int constants in switch cases with enum values&lt;/li&gt;
 * &lt;li&gt;Removes the old int constant field declarations&lt;/li&gt;
 * &lt;li&gt;Updates the method parameter type from int to the enum type&lt;/li&gt;
 * &lt;/ol&gt;
 */
<span class="fc" id="L69">public class SwitchIntToEnumHelper extends AbstractTool&lt;ReferenceHolder&lt;Integer, IntConstantHolder&gt;&gt; {</span>

	@Override
	public void find(IntToEnumFixCore fixcore, CompilationUnit compilationUnit,
			Set&lt;CompilationUnitRewriteOperationWithSourceRange&gt; operations, Set&lt;ASTNode&gt; nodesprocessed) {

<span class="fc" id="L75">		compilationUnit.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(SwitchStatement node) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">				if (nodesprocessed.contains(node)) {</span>
<span class="nc" id="L79">					return true;</span>
				}

				// Only process if the switch selector is a method parameter (so we can update its type)
<span class="fc" id="L83">				Expression switchExpr = node.getExpression();</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">				if (!(switchExpr instanceof SimpleName switchName)) {</span>
<span class="nc" id="L85">					return true;</span>
				}
<span class="fc" id="L87">				MethodDeclaration method = findEnclosingMethod(node);</span>
<span class="pc bpc" id="L88" title="1 of 4 branches missed.">				if (method == null || !isMethodParameter(method, switchName.getIdentifier())) {</span>
<span class="fc" id="L89">					return true;</span>
				}

				// Collect constants from the same enclosing type as the switch
<span class="fc" id="L93">				TypeDeclaration enclosingType = findEnclosingType(node);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">				if (enclosingType == null) {</span>
<span class="nc" id="L95">					return true;</span>
				}
<span class="fc" id="L97">				Map&lt;String, FieldDeclaration&gt; intConstants = collectIntConstants(enclosingType);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">				if (intConstants.size() &lt; 2) {</span>
<span class="fc" id="L99">					return true;</span>
				}

				// Find case labels that reference collected constants (SimpleName only)
<span class="fc" id="L103">				List&lt;String&gt; usedConstants = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L104">				Map&lt;String, FieldDeclaration&gt; usedFields = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">				for (Object stmt : node.statements()) {</span>
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">					if (stmt instanceof SwitchCase switchCase &amp;&amp; !switchCase.isDefault()) {</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">						for (Object expr : switchCase.expressions()) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">							if (expr instanceof SimpleName sn) {</span>
<span class="fc" id="L110">								String constName = sn.getIdentifier();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">								if (intConstants.containsKey(constName)) {</span>
<span class="fc" id="L112">									usedConstants.add(constName);</span>
<span class="fc" id="L113">									usedFields.put(constName, intConstants.get(constName));</span>
								}
							}
						}
					}
				}

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">				if (usedConstants.size() &lt; 2) {</span>
<span class="nc" id="L121">					return true;</span>
				}

<span class="fc" id="L124">				String prefix = findCommonPrefix(usedConstants);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">				if (prefix == null) {</span>
<span class="fc" id="L126">					return true;</span>
				}

				// Validate all derived enum constant names are valid Java identifiers
<span class="fc bfc" id="L130" title="All 2 branches covered.">				for (String constName : usedConstants) {</span>
<span class="fc" id="L131">					String enumValueName = constName.substring(prefix.length());</span>
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">					if (enumValueName.isEmpty() || !Character.isJavaIdentifierStart(enumValueName.charAt(0))) {</span>
<span class="nc" id="L133">						return true;</span>
					}
				}

				// Verify constants are not referenced outside the switch statement
<span class="fc bfc" id="L138" title="All 2 branches covered.">				if (hasReferencesOutsideSwitch(compilationUnit, usedFields.keySet(), node)) {</span>
<span class="fc" id="L139">					return true;</span>
				}

<span class="fc" id="L142">				IntConstantHolder holder = new IntConstantHolder();</span>
<span class="fc" id="L143">				holder.switchStatement = node;</span>
<span class="fc" id="L144">				holder.constantFields.putAll(usedFields);</span>
<span class="fc" id="L145">				holder.constantNames.addAll(usedConstants);</span>
<span class="fc" id="L146">				holder.comparedVariable = switchName.getIdentifier();</span>
<span class="fc" id="L147">				holder.nodesProcessed = nodesprocessed;</span>

<span class="fc" id="L149">				ReferenceHolder&lt;Integer, IntConstantHolder&gt; dataholder = new ReferenceHolder&lt;&gt;();</span>
<span class="fc" id="L150">				dataholder.put(0, holder);</span>
<span class="fc" id="L151">				operations.add(fixcore.rewrite(dataholder));</span>
<span class="fc" id="L152">				nodesprocessed.add(node);</span>

<span class="fc" id="L154">				return true;</span>
			}
		});
<span class="fc" id="L157">	}</span>

	/**
	 * Collect static final int field declarations from the given type declaration.
	 */
	private static Map&lt;String, FieldDeclaration&gt; collectIntConstants(TypeDeclaration typeDecl) {
<span class="fc" id="L163">		Map&lt;String, FieldDeclaration&gt; intConstants = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">		for (FieldDeclaration field : typeDecl.getFields()) {</span>
<span class="fc" id="L165">			int modifiers = field.getModifiers();</span>
<span class="pc bpc" id="L166" title="2 of 4 branches missed.">			if (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isFinal(modifiers)) {</span>
<span class="fc" id="L167">				Type type = field.getType();</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">				if (type.isPrimitiveType()</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">						&amp;&amp; ((PrimitiveType) type).getPrimitiveTypeCode() == PrimitiveType.INT) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">					for (Object fragment : field.fragments()) {</span>
<span class="fc" id="L171">						VariableDeclarationFragment vdf = (VariableDeclarationFragment) fragment;</span>
<span class="fc" id="L172">						intConstants.put(vdf.getName().getIdentifier(), field);</span>
					}
				}
			}
		}
<span class="fc" id="L177">		return intConstants;</span>
	}

	/**
	 * Check if the given variable name is a parameter of the method.
	 */
	private static boolean isMethodParameter(MethodDeclaration method, String varName) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">		for (Object param : method.parameters()) {</span>
<span class="fc" id="L185">			SingleVariableDeclaration svd = (SingleVariableDeclaration) param;</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">			if (svd.getName().getIdentifier().equals(varName)) {</span>
<span class="fc" id="L187">				return true;</span>
			}
		}
<span class="fc" id="L190">		return false;</span>
	}

	/**
	 * Check if any of the named constants are referenced outside the given switch statement.
	 * Returns true if there are external references (meaning we should NOT transform).
	 */
	private static boolean hasReferencesOutsideSwitch(CompilationUnit cu, Set&lt;String&gt; constantNames,
			SwitchStatement switchStatement) {
<span class="fc" id="L199">		AtomicBoolean hasExternalRef = new AtomicBoolean(false);</span>
<span class="fc" id="L200">		cu.accept(new ASTVisitor() {</span>
			@Override
			public boolean visit(SimpleName node) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">				if (hasExternalRef.get()) {</span>
<span class="nc" id="L204">					return false;</span>
				}
<span class="fc bfc" id="L206" title="All 2 branches covered.">				if (!constantNames.contains(node.getIdentifier())) {</span>
<span class="fc" id="L207">					return true;</span>
				}
<span class="fc" id="L209">				IBinding binding = node.resolveBinding();</span>
<span class="pc bpc" id="L210" title="2 of 4 branches missed.">				if (!(binding instanceof IVariableBinding vb) || !vb.isField()) {</span>
<span class="nc" id="L211">					return true;</span>
				}
				// Check if this reference is inside the switch statement or in a field declaration
<span class="fc" id="L214">				ASTNode parent = node.getParent();</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">				while (parent != null) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">					if (parent == switchStatement) {</span>
<span class="fc" id="L217">						return true; // inside the switch - OK</span>
					}
<span class="fc bfc" id="L219" title="All 2 branches covered.">					if (parent instanceof FieldDeclaration) {</span>
<span class="fc" id="L220">						return true; // in the field declaration itself - OK</span>
					}
<span class="fc" id="L222">					parent = parent.getParent();</span>
				}
				// Reference found outside the switch statement
<span class="fc" id="L225">				hasExternalRef.set(true);</span>
<span class="fc" id="L226">				return false;</span>
			}
		});
<span class="fc" id="L229">		return hasExternalRef.get();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public void rewrite(IntToEnumFixCore fixCore, ReferenceHolder&lt;Integer, IntConstantHolder&gt; holder,
			CompilationUnitRewrite cuRewrite, TextEditGroup group) {

<span class="fc bfc" id="L237" title="All 2 branches covered.">		for (IntConstantHolder data : holder.values()) {</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">			if (data.switchStatement == null) {</span>
<span class="nc" id="L239">				continue;</span>
			}

<span class="fc" id="L242">			AST ast = cuRewrite.getRoot().getAST();</span>
<span class="fc" id="L243">			ASTRewrite rewrite = cuRewrite.getASTRewrite();</span>

<span class="fc" id="L245">			String prefix = findCommonPrefix(data.constantNames);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">			if (prefix == null) {</span>
<span class="nc" id="L247">				continue;</span>
			}

<span class="fc" id="L250">			String enumName = prefixToEnumName(prefix);</span>

			// 1. Create enum declaration
<span class="fc" id="L253">			EnumDeclaration enumDecl = ast.newEnumDeclaration();</span>
<span class="fc" id="L254">			enumDecl.setName(ast.newSimpleName(enumName));</span>
<span class="fc" id="L255">			enumDecl.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">			for (String constName : data.constantNames) {</span>
<span class="fc" id="L258">				EnumConstantDeclaration enumConst = ast.newEnumConstantDeclaration();</span>
<span class="fc" id="L259">				String enumValueName = constName.substring(prefix.length());</span>
<span class="fc" id="L260">				enumConst.setName(ast.newSimpleName(enumValueName));</span>
<span class="fc" id="L261">				enumDecl.enumConstants().add(enumConst);</span>
			}

			// 2. Find the enclosing TypeDeclaration
<span class="fc" id="L265">			TypeDeclaration typeDecl = findEnclosingType(data.switchStatement);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">			if (typeDecl == null) {</span>
<span class="nc" id="L267">				continue;</span>
			}

<span class="fc" id="L270">			ListRewrite bodyRewrite = rewrite.getListRewrite(typeDecl, TypeDeclaration.BODY_DECLARATIONS_PROPERTY);</span>

			// 3. Insert enum before the first constant field being removed
<span class="fc" id="L273">			FieldDeclaration firstField = data.constantFields.values().iterator().next();</span>
<span class="fc" id="L274">			bodyRewrite.insertBefore(enumDecl, firstField, group);</span>

			// 4. Remove old int constant field declarations
<span class="fc" id="L277">			Set&lt;FieldDeclaration&gt; fieldsToRemove = new HashSet&lt;&gt;(data.constantFields.values());</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">			for (FieldDeclaration field : fieldsToRemove) {</span>
<span class="fc" id="L279">				List&lt;?&gt; fragments = field.fragments();</span>
<span class="fc" id="L280">				boolean allFragmentsRemoved = true;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">				for (Object frag : fragments) {</span>
<span class="fc" id="L282">					VariableDeclarationFragment vdf = (VariableDeclarationFragment) frag;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">					if (!data.constantFields.containsKey(vdf.getName().getIdentifier())) {</span>
<span class="nc" id="L284">						allFragmentsRemoved = false;</span>
<span class="nc" id="L285">						break;</span>
					}
				}
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">				if (allFragmentsRemoved) {</span>
<span class="fc" id="L289">					bodyRewrite.remove(field, group);</span>
<span class="fc" id="L290">				} else {</span>
<span class="nc" id="L291">					ListRewrite fragRewrite = rewrite.getListRewrite(field, FieldDeclaration.FRAGMENTS_PROPERTY);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">					for (Object frag : fragments) {</span>
<span class="nc" id="L293">						VariableDeclarationFragment vdf = (VariableDeclarationFragment) frag;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">						if (data.constantFields.containsKey(vdf.getName().getIdentifier())) {</span>
<span class="nc" id="L295">							fragRewrite.remove(vdf, group);</span>
						}
					}
				}
			}

			// 5. Update switch case labels to enum values
<span class="fc bfc" id="L302" title="All 2 branches covered.">			for (Object stmt : data.switchStatement.statements()) {</span>
<span class="pc bpc" id="L303" title="1 of 4 branches missed.">				if (stmt instanceof SwitchCase switchCase &amp;&amp; !switchCase.isDefault()) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">					for (Object expr : switchCase.expressions()) {</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">						if (expr instanceof SimpleName sn) {</span>
<span class="fc" id="L306">							String constName = sn.getIdentifier();</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">							if (data.constantFields.containsKey(constName)) {</span>
<span class="fc" id="L308">								String enumValueName = constName.substring(prefix.length());</span>
<span class="fc" id="L309">								SimpleName newName = ast.newSimpleName(enumValueName);</span>
<span class="fc" id="L310">								rewrite.replace(sn, newName, group);</span>
							}
						}
					}
				}
			}

			// 6. Update method parameter type from int to enum
<span class="fc" id="L318">			MethodDeclaration method = findEnclosingMethod(data.switchStatement);</span>
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">			if (method != null &amp;&amp; data.comparedVariable != null) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">				for (Object param : method.parameters()) {</span>
<span class="fc" id="L321">					SingleVariableDeclaration svd = (SingleVariableDeclaration) param;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">					if (svd.getName().getIdentifier().equals(data.comparedVariable)) {</span>
<span class="fc" id="L323">						Type newType = ast.newSimpleType(ast.newSimpleName(enumName));</span>
<span class="fc" id="L324">						rewrite.replace(svd.getType(), newType, group);</span>
					}
				}
			}
		}
<span class="fc" id="L329">	}</span>

	/**
	 * Find the longest common prefix of all constant names, ending at an underscore boundary.
	 * Returns null if no valid underscore-delimited prefix is found.
	 */
	static String findCommonPrefix(List&lt;String&gt; names) {
<span class="pc bpc" id="L336" title="2 of 4 branches missed.">		if (names == null || names.isEmpty()) {</span>
<span class="nc" id="L337">			return null;</span>
		}
<span class="fc" id="L339">		String first = names.get(0);</span>
<span class="fc" id="L340">		int prefixEnd = first.length();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		for (String name : names) {</span>
<span class="fc" id="L342">			prefixEnd = Math.min(prefixEnd, name.length());</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			for (int i = 0; i &lt; prefixEnd; i++) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">				if (first.charAt(i) != name.charAt(i)) {</span>
<span class="fc" id="L345">					prefixEnd = i;</span>
<span class="fc" id="L346">					break;</span>
				}
			}
		}
<span class="fc" id="L350">		String prefix = first.substring(0, prefixEnd);</span>
		// Trim to last underscore for a clean prefix boundary.
		// If there is no underscore (or only at position 0), we do not
		// consider this a valid prefix according to the architecture
		// contract (which requires underscore-delimited prefixes).
<span class="fc" id="L355">		int lastUnderscore = prefix.lastIndexOf('_');</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		if (lastUnderscore &gt; 0) {</span>
<span class="fc" id="L357">			return prefix.substring(0, lastUnderscore + 1);</span>
		}
<span class="fc" id="L359">		return null;</span>
	}

	/**
	 * Convert a constant prefix like &quot;STATUS_&quot; to an enum name like &quot;Status&quot;.
	 */
	static String prefixToEnumName(String prefix) {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">		if (prefix.endsWith(&quot;_&quot;)) { //$NON-NLS-1$</span>
<span class="fc" id="L367">			prefix = prefix.substring(0, prefix.length() - 1);</span>
		}
<span class="fc" id="L369">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L370">		boolean capitalizeNext = true;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">		for (char c : prefix.toLowerCase().toCharArray()) {</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">			if (c == '_') {</span>
<span class="nc" id="L373">				capitalizeNext = true;</span>
<span class="nc" id="L374">			} else {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">				if (capitalizeNext) {</span>
<span class="fc" id="L376">					sb.append(Character.toUpperCase(c));</span>
<span class="fc" id="L377">					capitalizeNext = false;</span>
<span class="fc" id="L378">				} else {</span>
<span class="fc" id="L379">					sb.append(c);</span>
				}
			}
		}
<span class="fc" id="L383">		return sb.toString();</span>
	}

	private static TypeDeclaration findEnclosingType(ASTNode node) {
<span class="fc" id="L387">		ASTNode parent = node.getParent();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">		while (parent != null) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">			if (parent instanceof TypeDeclaration typeDecl) {</span>
<span class="fc" id="L390">				return typeDecl;</span>
			}
<span class="fc" id="L392">			parent = parent.getParent();</span>
		}
<span class="nc" id="L394">		return null;</span>
	}

	private static MethodDeclaration findEnclosingMethod(ASTNode node) {
<span class="fc" id="L398">		ASTNode parent = node.getParent();</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">		while (parent != null) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">			if (parent instanceof MethodDeclaration methodDecl) {</span>
<span class="fc" id="L401">				return methodDecl;</span>
			}
<span class="fc" id="L403">			parent = parent.getParent();</span>
		}
<span class="nc" id="L405">		return null;</span>
	}

	@Override
	public String getPreview(boolean afterRefactoring) {
<span class="nc bnc" id="L410" title="All 2 branches missed.">		if (!afterRefactoring) {</span>
<span class="nc" id="L411">			return &quot;&quot;&quot;</span>
					// Before:
					public static final int STATUS_PENDING = 0;
					public static final int STATUS_APPROVED = 1;

					switch (status) {
					    case STATUS_PENDING:
					        // handle pending
					        break;
					    case STATUS_APPROVED:
					        // handle approved
					        break;
					}
					&quot;&quot;&quot;; //$NON-NLS-1$
		}
<span class="nc" id="L426">		return &quot;&quot;&quot;</span>
				// After:
				public enum Status {
				    PENDING, APPROVED
				}

				switch (status) {
				    case PENDING:
				        // handle pending
				        break;
				    case APPROVED:
				        // handle approved
				        break;
				}
				&quot;&quot;&quot;; //$NON-NLS-1$
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>