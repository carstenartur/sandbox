name: Release Workflow

on:
  workflow_dispatch:
    inputs:
      release_version:
        description: 'Release version (e.g., 1.2.3) - check current SNAPSHOT version in pom.xml'
        required: true
        type: string
      skip_tests:
        description: 'Skip tests during release build'
        required: false
        type: boolean
        default: false
      dry_run:
        description: 'Dry run - validate everything but do not publish'
        required: false
        type: boolean
        default: false

permissions:
  contents: write       # Required to push to main branch, create tags, and push to gh-pages
  issues: read          # Required to read issues for release notes
  pull-requests: write  # Required to create pull requests for next development iteration

env:
  GH_TOKEN: ${{ github.token }}

jobs:
  preflight:
    name: Preflight Checks
    runs-on: ubuntu-latest
    outputs:
      current_version: ${{ steps.version.outputs.current }}
      suggested_release: ${{ steps.version.outputs.suggested_release }}
      suggested_next: ${{ steps.version.outputs.suggested_next }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      
      - name: Set up JDK 21
        uses: actions/setup-java@v5
        with:
          java-version: '21'
          distribution: 'temurin'
      
      - name: Extract current version from pom.xml
        id: version
        run: |
          CURRENT=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "current=$CURRENT" >> $GITHUB_OUTPUT
          
          # Berechne vorgeschlagene Versionen
          if [[ "$CURRENT" == *-SNAPSHOT ]]; then
            RELEASE="${CURRENT%-SNAPSHOT}"
            echo "suggested_release=$RELEASE" >> $GITHUB_OUTPUT
            
            # Berechne nächste Version (patch increment)
            IFS='.' read -r major minor patch <<< "$RELEASE"
            NEXT_PATCH=$((patch + 1))
            echo "suggested_next=${major}.${minor}.${NEXT_PATCH}-SNAPSHOT" >> $GITHUB_OUTPUT
          else
            echo "::error::Current version $CURRENT is not a SNAPSHOT version"
            exit 1
          fi
      
      - name: Validate release version input
        run: |
          INPUT_VERSION="${{ github.event.inputs.release_version }}"
          SUGGESTED="${{ steps.version.outputs.suggested_release }}"
          
          # Prüfe ob Version gültig ist (semver Format)
          if ! [[ "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid version format: $INPUT_VERSION (expected: X.Y.Z)"
            exit 1
          fi
          
          # Warnung wenn anders als vorgeschlagen
          if [[ "$INPUT_VERSION" != "$SUGGESTED" ]]; then
            echo "::warning::Input version $INPUT_VERSION differs from suggested $SUGGESTED"
          fi
      
      - name: Check if release tag already exists
        run: |
          VERSION="${{ github.event.inputs.release_version }}"
          if git ls-remote --tags origin | grep -q "refs/tags/v${VERSION}$"; then
            echo "::error::Tag v${VERSION} already exists!"
            exit 1
          fi
      
      - name: Check for SNAPSHOT references in codebase
        run: |
          echo "Checking for SNAPSHOT references..."
          
          # Suche nach SNAPSHOT in relevanten Dateien (außer in src/ und test/)
          SNAPSHOT_REFS=$(grep -r "SNAPSHOT" --include="pom.xml" --include="MANIFEST.MF" --include="feature.xml" --include="*.product" . \
            | grep -v "/src/" \
            | grep -v "/test/" \
            | grep -v "target/" \
            | grep -v "\.git/" \
            || true)
          
          if [ -n "$SNAPSHOT_REFS" ]; then
            echo "Found SNAPSHOT references (this is expected for current development version):"
            echo "$SNAPSHOT_REFS"
          fi
      
      - name: Check branch protection (dry-run push test)
        run: |
          echo "Checking if workflow can push to main..."
          # Dieser Check informiert nur, bricht aber nicht ab
          # Der Workflow wird später einen PR erstellen statt direkt zu pushen
          echo "Note: This workflow will create a PR for version changes instead of pushing directly to main"
      
      - name: Validate Maven configuration
        run: |
          echo "Validating Maven configuration..."
          mvn validate -q || {
            echo "::error::Maven validation failed"
            exit 1
          }
      
      - name: Summary of preflight checks
        run: |
          # Calculate what the next SNAPSHOT version will be based on INPUT release version
          INPUT_VERSION="${{ github.event.inputs.release_version }}"
          IFS='.' read -r major minor patch <<< "$INPUT_VERSION"
          NEXT_PATCH=$((patch + 1))
          ACTUAL_NEXT="${major}.${minor}.${NEXT_PATCH}-SNAPSHOT"
          
          echo "## Preflight Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Current Version | ${{ steps.version.outputs.current }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Release Version | ${{ github.event.inputs.release_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Next Dev Version | ${ACTUAL_NEXT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag exists | No ✅ |" >> $GITHUB_STEP_SUMMARY
          echo "| Maven valid | Yes ✅ |" >> $GITHUB_STEP_SUMMARY
          echo "| Dry run mode | ${{ github.event.inputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Skip tests | ${{ github.event.inputs.skip_tests }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add warning if release version differs from suggested version
          SUGGESTED="${{ steps.version.outputs.suggested_release }}"
          if [[ "$INPUT_VERSION" != "$SUGGESTED" ]]; then
            echo "⚠️ **Warning:** Release version ($INPUT_VERSION) differs from suggested ($SUGGESTED)" >> $GITHUB_STEP_SUMMARY
            echo "Next SNAPSHOT will be based on the release version: **${ACTUAL_NEXT}**" >> $GITHUB_STEP_SUMMARY
          fi

  release:
    name: Build and Release
    needs: preflight
    runs-on: ubuntu-latest
    
    steps:
    # 1. Checkout with full history
    - name: Checkout repository
      uses: actions/checkout@v6
      with:
        fetch-depth: 0  # Full history required for git describe and jgit timestamp provider

    # 2. Checkout main branch explicitly
    - name: Ensure on main branch
      run: |
        git checkout main
        echo "Checked out main branch"

    # 3. Set up JDK 21
    - name: Set up JDK 21
      uses: actions/setup-java@v5
      with:
        java-version: '21'
        distribution: 'temurin'

    # 4. Cache Maven dependencies for faster builds
    - name: Cache Maven dependencies
      uses: actions/cache@v5
      with:
        path: ~/.m2/repository
        key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml', 'sandbox_target/*.target') }}
        restore-keys: ${{ runner.os }}-maven-

    # 5. Set release version using tycho-versions-plugin
    - name: Set release version
      run: |
        TYCHO_VERSION=$(mvn -q -DforceStdout help:evaluate -Dexpression=tycho-version)
        echo "Using Tycho version ${TYCHO_VERSION} from pom.xml"
        echo "Setting version to ${{ inputs.release_version }}"
        # Include benchmark and jacoco profiles to update all modules that inherit version from parent
        mvn org.eclipse.tycho:tycho-versions-plugin:${TYCHO_VERSION}:set-version -DnewVersion=${{ inputs.release_version }} -Pbenchmark,jacoco



    # 6. Verify version update - fail if any SNAPSHOT versions remain
    - name: Verify version update
      run: |
        echo "Checking for remaining SNAPSHOT references..."
        # Check all version-related files for SNAPSHOT, excluding test resources
        if grep -r "SNAPSHOT" --include="pom.xml" --include="MANIFEST.MF" --include="feature.xml" --include="*.product" \
           --exclude-dir="src" .; then
          echo "ERROR: Found remaining SNAPSHOT references!"
          echo "All modules must be updated to release version."
          exit 1
        fi
        echo "✓ Version verification passed - no SNAPSHOT references found"

    # 7. Commit version changes
    - name: Commit version changes
      run: |
        git config user.name 'github-actions[bot]'
        git config user.email 'github-actions[bot]@users.noreply.github.com'
        git add -A
        git commit -m "Release version ${{ inputs.release_version }}"

    # 8. Build and verify
    - name: Build and verify
      run: |
        echo "Building release ${{ inputs.release_version }}..."
        TEST_FLAG=""
        if [[ "${{ inputs.skip_tests }}" == "true" ]]; then
          TEST_FLAG="-DskipTests"
          echo "Skipping tests as requested"
        fi
        xvfb-run --auto-servernum mvn -Pproduct,repo -T 1C clean verify $TEST_FLAG

    # 9. Create and push Git tag
    - name: Create and push Git tag
      if: ${{ !inputs.dry_run }}
      run: |
        git tag -a "v${{ inputs.release_version }}" -m "Release version ${{ inputs.release_version }}"
        git push origin "v${{ inputs.release_version }}"
        echo "Created and pushed tag v${{ inputs.release_version }}"
    
    - name: Dry run - Skip tag creation
      if: ${{ inputs.dry_run }}
      run: |
        echo "::notice::Dry run mode - would create tag v${{ inputs.release_version }}"

    # 10. Create and push maintenance branch
    - name: Create and push maintenance branch
      if: ${{ !inputs.dry_run }}
      run: |
        # Extract major.minor from version (e.g., 1.2.2 -> 1.2)
        MAJOR_MINOR=$(echo "${{ inputs.release_version }}" | sed 's/\.[^.]*$//')
        BRANCH_NAME="maintenance/${MAJOR_MINOR}.x"
        
        # Check if branch already exists on remote
        if git ls-remote --exit-code --heads origin "${BRANCH_NAME}" >/dev/null 2>&1; then
          echo "Branch ${BRANCH_NAME} already exists on remote, skipping creation"
        else
          echo "Creating and pushing maintenance branch: ${BRANCH_NAME}"
          git branch "${BRANCH_NAME}"
          git push origin "${BRANCH_NAME}"
          echo "Created and pushed maintenance branch: ${BRANCH_NAME}"
        fi
    
    - name: Dry run - Skip maintenance branch creation
      if: ${{ inputs.dry_run }}
      run: |
        MAJOR_MINOR=$(echo "${{ inputs.release_version }}" | sed 's/\.[^.]*$//')
        echo "::notice::Dry run mode - would create maintenance branch maintenance/${MAJOR_MINOR}.x"

    # 11. Generate release notes from closed issues (before gh-pages checkout)
    - name: Generate release notes
      run: |
        echo "Generating release notes from closed issues..."
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        if [ -n "$PREVIOUS_TAG" ]; then
          echo "Getting closed issues since $PREVIOUS_TAG"
          PREVIOUS_DATE=$(git log -1 --format=%aI $PREVIOUS_TAG)
          gh issue list --state closed --search "closed:>$PREVIOUS_DATE" --json number,title --jq '.[] | "- #\(.number): \(.title)"' > release_notes.md
          GH_STATUS=$?
          if [ $GH_STATUS -ne 0 ]; then
            echo "Error: failed to fetch closed issues from GitHub (exit code $GH_STATUS)." >&2
            exit $GH_STATUS
          fi
          if [ ! -s release_notes.md ]; then
            echo "No closed issues found since $PREVIOUS_TAG" > release_notes.md
          fi
        else
          echo "No previous tag found - first release"
          echo "Initial release" > release_notes.md
        fi
        
        echo "Release notes generated:"
        cat release_notes.md

    # 12. Create GitHub Release (now that tag exists on remote)
    - name: Create GitHub Release
      if: ${{ !inputs.dry_run }}
      run: |
        echo "Creating GitHub release for v${{ inputs.release_version }}..."
        gh release create "v${{ inputs.release_version }}" \
          --title "Release ${{ inputs.release_version }}" \
          --notes-file release_notes.md \
          --generate-notes
    
    - name: Dry run - Skip GitHub Release
      if: ${{ inputs.dry_run }}
      run: |
        echo "::notice::Dry run mode - would create GitHub release v${{ inputs.release_version }}"
        echo "Release notes preview:"
        cat release_notes.md

    # 13. Deploy release to gh-pages
    - name: Checkout gh-pages branch
      if: ${{ !inputs.dry_run }}
      uses: actions/checkout@v6
      with:
        ref: gh-pages
        path: gh-pages-repo

    - name: Prepare release directory
      if: ${{ !inputs.dry_run }}
      run: |
        mkdir -p gh-pages-repo/releases/${{ inputs.release_version }}
        cp -r sandbox_updatesite/target/repository/* gh-pages-repo/releases/${{ inputs.release_version }}/

    - name: Update composite metadata
      if: ${{ !inputs.dry_run }}
      run: |
        cd gh-pages-repo/releases
        
        # Get list of all release versions
        VERSIONS=$(find . -maxdepth 1 -type d ! -name '.' ! -name '..' -exec basename {} \; | sort -V)
        VERSION_COUNT=$(echo "$VERSIONS" | wc -l)
        
        # Generate children elements for composite metadata
        CHILDREN_XML=""
        for ver in $VERSIONS; do
          CHILDREN_XML="$CHILDREN_XML    <child location='$ver'/>\n"
        done
        
        # Create compositeContent.xml
        cat > compositeContent.xml << EOF
        <?xml version='1.0' encoding='UTF-8'?>
        <?compositeMetadataRepository version='1.0.0'?>
        <repository name='Sandbox Releases'
                    type='org.eclipse.equinox.internal.p2.metadata.repository.CompositeMetadataRepository'
                    version='1.0.0'>
          <properties size='1'>
            <property name='p2.timestamp' value='$(date +%s)000'/>
          </properties>
          <children size='$VERSION_COUNT'>
        $(echo -e "$CHILDREN_XML")  </children>
        </repository>
        EOF
        
        # Create compositeArtifacts.xml
        cat > compositeArtifacts.xml << EOF
        <?xml version='1.0' encoding='UTF-8'?>
        <?compositeArtifactRepository version='1.0.0'?>
        <repository name='Sandbox Releases'
                    type='org.eclipse.equinox.internal.p2.artifact.repository.CompositeArtifactRepository'
                    version='1.0.0'>
          <properties size='1'>
            <property name='p2.timestamp' value='$(date +%s)000'/>
          </properties>
          <children size='$VERSION_COUNT'>
        $(echo -e "$CHILDREN_XML")  </children>
        </repository>
        EOF
        
        echo "Created composite metadata for $VERSION_COUNT versions"

    - name: Commit and push to gh-pages
      if: ${{ !inputs.dry_run }}
      run: |
        cd gh-pages-repo
        git config user.name 'github-actions[bot]'
        git config user.email 'github-actions[bot]@users.noreply.github.com'
        git add .
        git commit -m "Deploy release ${{ inputs.release_version }}"
        git push origin gh-pages
    
    - name: Dry run - Skip gh-pages deployment
      if: ${{ inputs.dry_run }}
      run: |
        echo "::notice::Dry run mode - would deploy release ${{ inputs.release_version }} to gh-pages"

    # 14. Return to main repository and bump to next SNAPSHOT version
    - name: Bump to next SNAPSHOT version
      run: |
        # Ensure we're in the main repository directory (not gh-pages-repo)
        cd $GITHUB_WORKSPACE
        
        # Calculate next version based on the RELEASED version, not pom.xml
        RELEASED_VERSION="${{ inputs.release_version }}"
        IFS='.' read -r major minor patch <<< "$RELEASED_VERSION"
        NEXT_PATCH=$((patch + 1))
        NEXT_VERSION="${major}.${minor}.${NEXT_PATCH}-SNAPSHOT"
        echo "Bumping version to ${NEXT_VERSION} (based on released version ${RELEASED_VERSION})"
        
        TYCHO_VERSION=$(mvn -q -DforceStdout help:evaluate -Dexpression=tycho-version)
        echo "Using Tycho versions plugin ${TYCHO_VERSION}"
        # Include benchmark and jacoco profiles to update all modules that inherit version from parent
        mvn org.eclipse.tycho:tycho-versions-plugin:${TYCHO_VERSION}:set-version -DnewVersion=${NEXT_VERSION} -Pbenchmark,jacoco



    # 15. Create PR for next SNAPSHOT version
    - name: Create PR for next development iteration
      run: |
        # Ensure we're in the main repository directory
        cd $GITHUB_WORKSPACE
        
        # Calculate next version based on the RELEASED version (same calculation as above)
        RELEASED_VERSION="${{ inputs.release_version }}"
        IFS='.' read -r major minor patch <<< "$RELEASED_VERSION"
        NEXT_PATCH=$((patch + 1))
        NEXT_VERSION="${major}.${minor}.${NEXT_PATCH}-SNAPSHOT"
        
        # Create a branch for the next development iteration
        NEXT_VERSION_BRANCH="release/prepare-next-${NEXT_VERSION}"
        git checkout -b "${NEXT_VERSION_BRANCH}"
        
        # Commit all changes
        git add -A
        git commit -m "Prepare for next development iteration ${NEXT_VERSION}"
        
        # Push the branch
        git push origin "${NEXT_VERSION_BRANCH}"
        
        # Create PR body with release notes
        cat > /tmp/pr_body.md << EOF
        Automated PR to bump version to ${NEXT_VERSION} after release ${{ inputs.release_version }}
        
        ## Changes
        - Bump version to ${NEXT_VERSION}
        - Update all pom.xml, MANIFEST.MF, feature.xml files
        
        ## Release Notes
        
        EOF
        cat release_notes.md >> /tmp/pr_body.md
        
        # Create PR
        echo "Creating PR for next development iteration..."
        gh pr create \
          --title "Prepare for next development iteration ${NEXT_VERSION}" \
          --body-file /tmp/pr_body.md \
          --base main \
          --head "${NEXT_VERSION_BRANCH}"
        
        echo "✓ PR created successfully"

    # 16. Add Eclipse Marketplace reminder
    - name: Eclipse Marketplace reminder
      run: |
        echo "::notice::Remember to update the Eclipse Marketplace listing at https://marketplace.eclipse.org/ with the new update site URL: https://carstenartur.github.io/sandbox/releases/${{ inputs.release_version }}/"
